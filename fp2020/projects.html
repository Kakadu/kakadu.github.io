<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="Dmitrii Kosarev a.k.a. Kakadu">
<title>Список курсовых/миникурсовых</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
</head>
<body class="article">
<div id="header">
<h1>Список курсовых/миникурсовых</h1>
<div class="details">
<span id="author" class="author">Dmitrii Kosarev a.k.a. Kakadu</span><br>
<span id="email" class="email"><a href="mailto:Dmitrii.Kosarev@pm.me">Dmitrii.Kosarev@pm.me</a></span><br>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#reasonml">Темы про ReScript/OCaml</a>
<ul class="sectlevel2">
<li><a href="#_парсер_синтаксиса_rescript_с_восстановлением_от_ошибок">Парсер синтаксиса ReScript, с восстановлением от ошибок</a></li>
<li><a href="#_парсер_rescript_с_использованием_подхода_парсер_комбинаторов">Парсер ReScript, с использованием подхода парсер-комбинаторов</a></li>
</ul>
</li>
<li><a href="#_темы_про_интеграцию_ocaml_с_ide">Темы про интеграцию OCaml с IDE</a>
<ul class="sectlevel2">
<li><a href="#_семантическая_подсветка_иили_идентация">Семантическая подсветка (и/или) идентация</a></li>
<li><a href="#_поддержка_синтаксических_расширений_на_основе_camlp5">Поддержка синтаксических расширений на основе Camlp5</a></li>
</ul>
</li>
<li><a href="#_темы_про_minikanren">Темы про miniKanren</a>
<ul class="sectlevel2">
<li><a href="#_concurrencyparallelism_для_minikanren">Concurrency/parallelism для miniKanren</a></li>
<li><a href="#_про_мемоизацию">Про мемоизацию</a></li>
</ul>
</li>
<li><a href="#_темы">Темы</a>
<ul class="sectlevel2">
<li><a href="#_про_верификацию_функциональных_программ_с_smt_солверами">Про верификацию функциональных программ с SMT солверами</a></li>
<li><a href="#_active_patterns_в_ocaml">Active Patterns в OCaml</a></li>
<li><a href="#_про_gui_и_функциональное_программирование">Про GUI и функциональное программирование</a></li>
<li><a href="#_автовекторизация_в_компиляторе">Автовекторизация в компиляторе</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><strong>Темы</strong> и <strong>задачи</strong> про функциональное программирование, С++ &amp; Qt и low-level programming .</p>
</div>
<div class="paragraph">
<p>В <strong>задачах</strong> более менее понятно как и что делать, можно оценивать трудоемкость и количество
времени/труда, которые нужно положить на доделывание. В <strong>темах</strong> дается общая картина, должны быть видны первые шаги,
но оценивать трудоемкость и количество времени на выполнение затруднительно. Из тем надо выбирать подзадачи на "курсовые".</p>
</div>
<div class="paragraph">
<p>На сколько я понял, курсовой в 4м семестре нет, есть что-то типа неё, неофициальное, с примерно теми же требованиями, но
короткими сроками.</p>
</div>
<div class="paragraph">
<p><strong>11.02.2018</strong> Добавлена задача про объекты в Qt и тема про SIMD.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reasonml">Темы про ReScript/OCaml</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Так как погромисты на Java не могут никак осилить синтаксис нормальных функциональных языков программирования,
в Bloomberg (а потом и в Facebook)
было предложено совершить ход конём и немного <span class="line-through">исправить</span> испортить синтаксис уже имеющегося языка
функционального программирования OCaml, чтобы он был более
похож на привычный синтаксис с фигурными скобками и точками с запятой. Получившийся в результате <a href="https://rescript-lang.org/">Rescript</a> (ранее известный как BuckleScript/ReasomML), хомячкам вроде понравился.</p>
</div>
<div class="paragraph">
<p>С таким подходом вроде бы всё хорошо, но есть проблема для чистокровных OCaml программистов: язык действительно сильно похож, но
непохожести очень сильно бесят, никак не получается выкинуть из головы выученный синтаксис и пользоваться новым, потому что то, что
видно на экране очень сильно напоминает "старый" синтаксис OCaml. В итоге получаются ошибки, которые очень глупые, но компилятор
ReasonML всёравно не доволен. И, наоборот, с ReScript может быть сложно пересесть на OCaml по сходным причинам.</p>
</div>
<div class="paragraph">
<p>Вот пример кода на OCaml:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="ocaml"><span></span><span class="tok-k">type</span> <span class="tok-k">&#39;</span><span class="tok-n">a</span> <span class="tok-n">expr</span> <span class="tok-o">=</span> <span class="tok-nc">Const</span> <span class="tok-o">:</span> <span class="tok-kt">int</span>     <span class="tok-o">-&gt;</span> <span class="tok-k">&#39;</span><span class="tok-n">a</span> <span class="tok-n">expr</span>
             <span class="tok-o">|</span> <span class="tok-nc">App</span>   <span class="tok-o">:</span> <span class="tok-k">&#39;</span><span class="tok-n">a</span> <span class="tok-o">*</span> <span class="tok-k">&#39;</span><span class="tok-n">a</span> <span class="tok-o">-&gt;</span> <span class="tok-k">&#39;</span><span class="tok-n">a</span> <span class="tok-n">expr</span>
             <span class="tok-o">|</span> <span class="tok-nc">Lam</span>   <span class="tok-o">:</span> <span class="tok-kt">string</span> <span class="tok-o">*</span> <span class="tok-k">&#39;</span><span class="tok-n">a</span> <span class="tok-o">-&gt;</span> <span class="tok-k">&#39;</span><span class="tok-n">a</span> <span class="tok-n">expr</span>

<span class="tok-k">let</span> <span class="tok-n">foo</span> <span class="tok-n">e</span> <span class="tok-o">=</span> <span class="tok-k">match</span> <span class="tok-n">e</span> <span class="tok-k">with</span>
  <span class="tok-o">|</span> <span class="tok-nc">Const</span> <span class="tok-n">n</span> <span class="tok-o">-&gt;</span> <span class="tok-n">n</span>
  <span class="tok-o">|</span> <span class="tok-nc">App</span> <span class="tok-o">(</span><span class="tok-n">l</span><span class="tok-o">,</span><span class="tok-n">r</span><span class="tok-o">)</span> <span class="tok-o">-&gt;</span>
      <span class="tok-k">let</span> <span class="tok-bp">()</span> <span class="tok-o">=</span> <span class="tok-n">print_endline</span> <span class="tok-s2">&quot;blabla&quot;</span> <span class="tok-k">in</span>
      <span class="tok-n">r</span>
  <span class="tok-o">|</span> <span class="tok-nc">Lam</span> <span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-o">,</span> <span class="tok-n">b</span><span class="tok-o">)</span> <span class="tok-o">-&gt;</span> <span class="tok-n">b</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>А вот, что получается при <a href="https://reasonml.github.io/en/try">трансляции</a> в ReScript.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="ocaml"><span></span><span class="tok-k">type</span> <span class="tok-n">expr</span><span class="tok-o">(</span><span class="tok-k">&#39;</span><span class="tok-n">a</span><span class="tok-o">)</span> <span class="tok-o">=</span>
  <span class="tok-o">|</span> <span class="tok-nc">Const</span><span class="tok-o">(</span><span class="tok-kt">int</span><span class="tok-o">):</span> <span class="tok-n">expr</span><span class="tok-o">(</span><span class="tok-k">&#39;</span><span class="tok-n">a</span><span class="tok-o">)</span>
  <span class="tok-o">|</span> <span class="tok-nc">App</span><span class="tok-o">(</span><span class="tok-k">&#39;</span><span class="tok-n">a</span><span class="tok-o">,</span> <span class="tok-k">&#39;</span><span class="tok-n">a</span><span class="tok-o">):</span> <span class="tok-n">expr</span><span class="tok-o">(</span><span class="tok-k">&#39;</span><span class="tok-n">a</span><span class="tok-o">)</span>
  <span class="tok-o">|</span> <span class="tok-nc">Lam</span><span class="tok-o">(</span><span class="tok-kt">string</span><span class="tok-o">,</span> <span class="tok-k">&#39;</span><span class="tok-n">a</span><span class="tok-o">):</span> <span class="tok-n">expr</span><span class="tok-o">(</span><span class="tok-k">&#39;</span><span class="tok-n">a</span><span class="tok-o">);</span>

<span class="tok-k">let</span> <span class="tok-n">foo</span> <span class="tok-o">=</span> <span class="tok-n">e</span> <span class="tok-o">=&gt;</span>
  <span class="tok-n">switch</span> <span class="tok-o">(</span><span class="tok-n">e</span><span class="tok-o">)</span> <span class="tok-o">{</span>
  <span class="tok-o">|</span> <span class="tok-nc">Const</span><span class="tok-o">(</span><span class="tok-n">n</span><span class="tok-o">)</span> <span class="tok-o">=&gt;</span> <span class="tok-n">n</span>
  <span class="tok-o">|</span> <span class="tok-nc">App</span><span class="tok-o">(</span><span class="tok-n">l</span><span class="tok-o">,</span> <span class="tok-n">r</span><span class="tok-o">)</span> <span class="tok-o">=&gt;</span>
    <span class="tok-k">let</span> <span class="tok-bp">()</span> <span class="tok-o">=</span> <span class="tok-n">print_endline</span><span class="tok-o">(</span><span class="tok-s2">&quot;blabla&quot;</span><span class="tok-o">);</span>
    <span class="tok-n">r</span><span class="tok-o">;</span>
  <span class="tok-o">|</span> <span class="tok-nc">Lam</span><span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-o">,</span> <span class="tok-n">b</span><span class="tok-o">)</span> <span class="tok-o">=&gt;</span> <span class="tok-n">b</span>
  <span class="tok-o">};</span></code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_парсер_синтаксиса_rescript_с_восстановлением_от_ошибок">Парсер синтаксиса ReScript, с восстановлением от ошибок</h3>
<div class="paragraph">
<p>Необходимо,чтобы парсер лучше понимал "камлизмы", и получше восстанавливался от ошибок, связанных с ними.</p>
</div>
<div class="paragraph">
<p>Замечание: в ReScript есть также старый парсер, который разбирает язык похожий на OCaml.
Можно исправлять его (ссылку найдете сами).</p>
</div>
<div class="paragraph">
<p><strong>Уровень</strong>: курсовая второго-третьего курса; может быть бакалаврская, если откроются много интересных подзадач.</p>
</div>
<div class="paragraph">
<p>С чего начинать: Вот <a href="https://github.com/rescript-lang/syntax">тут</a>  можно найти парсер, написанный рекурсивным спуском. Можно смотреть как он ведет себя на программах, где синтаксис двух языков перемешан.</p>
</div>
</div>
<div class="sect2">
<h3 id="_парсер_rescript_с_использованием_подхода_парсер_комбинаторов">Парсер ReScript, с использованием подхода парсер-комбинаторов</h3>
<div class="paragraph">
<p>На данный момент парсер ReasonML написан методом рекурсивного спуска. Скорее всего от парсер-комбинаторов отказались из-за опасений недостаточной производительности (хотя видео Джонатана Блоу, создателя Brain, я не смотрел). Хочется</p>
</div>
<div class="ulist">
<ul>
<li>
<p>подтвердить или опровергнуть, что парсер-комбинаторы торомозят.</p>
</li>
<li>
<p>проверять, что с ними писать более удобно не нужно (потому, что это вроде как очевидно).</p>
</li>
<li>
<p>предъявить техники написания парсер-комбинаторов, которые повышают производительность итогового парсера.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Уровень</strong>: курсовая; возможно, последующий апгрейд до бакалаврской.</p>
</div>
<div class="paragraph">
<p>С чего начинать:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>посмотреть на библиотеки парсер-комбинаторов;</p>
</li>
<li>
<p>разобраться с особенностями-недостатками похода: левая рекурсия, longest match first.</p>
</li>
<li>
<p>начать переписывать парсер на основе кодовой базы <a href="https://github.com/rescript-lang/syntax">ReScript</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Требования к обучающемуся:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>желательно знакомство с ФП языками (OCaml, Haskell, Scala 3);</p>
</li>
<li>
<p>желателен общий кругозор в области синтаксического анализа (LL, LR, GLR, GLL, Packrat, Meerkat).</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_темы_про_интеграцию_ocaml_с_ide">Темы про интеграцию OCaml с IDE</h2>
<div class="sectionbody">
<div class="paragraph">
<p>На данный момент интеграцию с IDE для языка OCaml предоставляет проект <a href="https://github.com/ocaml/merlin/">merlin</a>. Также существует надстаройка над ним <a href="https://github.com/ocaml-lsp/ocaml-language-server">OCaml Language Server</a>, реализующая
<a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a>, которая позволяет соединять бэкэнд интеграции IDE c любимым текстовым редактором. Фронт работ в этой области связан с</p>
</div>
<div class="ulist">
<ul>
<li>
<p>добавлением новых рефакторингов и т.п.</p>
</li>
<li>
<p>поддержка модификаций синтаксиса, а также восстановление от ошибок синтаксиса.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>TODO: видео с Spb Rust Meetup 2019 от matklad.</p>
</div>
<div class="paragraph">
<p>Публикации из этой области могут выглядеть так:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://icfp18.sigplan.org/details/icfp-2018-papers/19/">Merlin, ICFP 2018</a></p>
</li>
<li>
<p><a href="https://dl.acm.org/doi/pdf/10.1109/IWoR.2019.00013">RoToR, IWoR 2019</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_семантическая_подсветка_иили_идентация">Семантическая подсветка (и/или) идентация</h3>
<div class="paragraph">
<p>В функциональном программиовании часто используется паттерн проектирования, заключающийся в создании встраиваемых предметно-ориентированных языков (Embedded Domain Specific languages, EDSLs) для некоторых видов API, например:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>eDSL для создания запросов к реляционной базе данных</p>
</li>
<li>
<p>для описания XML</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Такие встраиваемые языки часто требуют особых правил подстветки и отступов по сравнению с host-языком, куда они встроены.
Сейчас в LSP уже <a href="https://github.com/microsoft/language-server-protocol/issues/18">ведется работа</a> по добавлению в спецификацию возможностей semantic highlighting.</p>
</div>
<div class="paragraph">
<p>Что надо сделать:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>расширить реализацию <a href="https://github.com/ocaml/ocaml-lsp">OCaml Language Server</a> поддержкой раскрашивания синтаксиса</p>
</li>
<li>
<p>сделать возможность описывать правила подстветки кода библиотекам на OCaml</p>
</li>
<li>
<p>доделать редактор кода, который умеет общаться с LSP сервером (например, <a href="https://marketplace.visualstudio.com/items?itemName=ocamllabs.ocaml-platform">VS Code</a>), чтобы он научился показывать то, что прислал сервер.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Замечание: настраиваемые авто-отступы можно выделить в отдельную похожую тему.</p>
</div>
<div class="paragraph">
<p><strong>Уровень</strong>: курсовая; возможен последующий апгрейд до бакалаврской.</p>
</div>
<div class="paragraph">
<p>Пожелания к обучающемуся:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>знакомство с OCaml;</p>
</li>
<li>
<p>знакомство с eDSL;</p>
</li>
<li>
<p>знакомство с технологией разработки/расширения соответствующего редактора (для VS Code это язык TypeScript);</p>
</li>
<li>
<p>отсутствие страха окунуться в большие проекты.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_поддержка_синтаксических_расширений_на_основе_camlp5">Поддержка синтаксических расширений на основе Camlp5</h3>
<div class="paragraph">
<p>На данный момент в OCaml/Merlin поддерживаются синтаксические расширения на основе PPX. Последовательность обработки примерно такая:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>входной код на OCaml разбирается парсером merlin в абстрактное синтаксическое дерево (AST)</p>
</li>
<li>
<p>merlin&#8217;у объяснены используемые compile-time синтаксические расширения, он их применяет, чтобы преобразовать OCaml AST в другое OCaml AST</p>
</li>
<li>
<p>после всех преобразований он запускает проверку типов, поиск рефакторингов и т.п.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Особенности данного подхода:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>синтаксический анализ проводится только над AST OCaml, что не дает расширять синтаксис произвольным способом с помощью PPX.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>При этом в экосистеме OCaml присутствует альтернативный способ расширения синтаксиса с помощью <a href="https://github.com/camlp5/camlp5/">Camlp5</a>. Его особенности</p>
</div>
<div class="ulist">
<ul>
<li>
<p>расширяемый парсер, отличный от используемого в компиляторе OCaml, позволяет описывать модификации синтаксиса на интересном eDSL.</p>
</li>
<li>
<p>позволяет изменять грамматику очень сильно; у этого есть как особенности, так и недостатки.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Что надо сделать</strong>. Необходимо добавить в OCamlMelrin+OCamlLSP поддержку синтаксических расширений:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>научить merlin понимать информацию о подключенных синтаксических расширениях Camlp5</p>
</li>
<li>
<p>изменить логику так, чтобы в присутствии Camlp5 сначала применялся парсер Camlp5, который на выходе даст AST компилятора OCaml, уже после это применять расширения синтаксиса на основе PPX.</p>
</li>
<li>
<p>уже после этого запускать поиск рефакторингов и т.п.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Уровень</strong>: курсовая; возможен последующий апгрейд до бакалаврской.</p>
</div>
<div class="paragraph">
<p>Пожелания к обучающемуся:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>знакомство с OCaml;</p>
</li>
<li>
<p>отсутствие страха окунуться в большие проекты.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Замечание: если в ходе работы окажется, что парсер Camlp5 очень плохо восстанавливается от ошибок, то возможно выделение отдельной темы по этому поводу.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_темы_про_minikanren">Темы про miniKanren</h2>
<div class="sectionbody">
<div class="paragraph">
<p>У нас в лаборатории есть некоторая "тусовка" на тему реляционного (логического) программирования на
<a href="http://minikanren.org/">miniKanren</a>. Если кратко,
то это DSL, чтобы относительно естественно решать переборные задачи, например, "перебери мне все программы, и дай те, которые
возвращают свой текст". Есть ещё своя реализация miniKanren, которая называется <a href="https://github.com/dboulytchev/ocanren">OCanren</a>,
на функциональном языке программирования
OCaml (он более дружелюбен к новичку, чем Haskell, ИМХО, конечно же).</p>
</div>
<div class="paragraph">
<p>Скажу сразу, miniKanren&#8201;&#8212;&#8201;это околонаучная штука на любителя.</p>
</div>
<div class="paragraph">
<p>TODO: добавить мотивирующее видео от Matthew Might&#8217;а с miniKanren Workshop 2020</p>
</div>
<div class="sect2">
<h3 id="_concurrencyparallelism_для_minikanren">Concurrency/parallelism для miniKanren</h3>
<div class="paragraph">
<p>Полный перебор жутко тормозит по определению, а его мы пока запускаем только на одном ядре. Хотелось бы поставить эксперимент
с использованием concurrency, которая есть в "изкоробочном" компиляторе OCaml. А затем, если всё продолжит работать правильно,
то воспользоваться неофициальной версией компилятора multicore OCaml (она в разработке). Они там сделали что-то прикольное с
использованием algebraic effects и утверждают, что API многопоточности гораздо адекватнее, чем в Java. Я не проверял и поверил
товарищам из английского Cambridge на слово.</p>
</div>
<div class="paragraph">
<p>Заранее отвечаю на вопрос с попыткой развести срач. Python.</p>
</div>
</div>
<div class="sect2">
<h3 id="_про_мемоизацию">Про мемоизацию</h3>
<div class="paragraph">
<p>Евгений Моисеенко сделал tabling (связанные понятия: мемоизация и кеширование) для OCanren некоторым способом, но есть ещё и другой, на основе Substitution Tree Indexing by Peter Graph.
Разумеется, всё придумали до нас, и нужно только прочитать и реализовать.</p>
</div>
<div class="paragraph">
<p><strong>Уровень</strong>: курсования</p>
</div>
<div class="paragraph">
<p>От студента требуется:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>отсутствия страха читать статьи на английском</p>
</li>
<li>
<p>желание попрограммировать немного на OCaml.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_темы">Темы</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_про_верификацию_функциональных_программ_с_smt_солверами">Про верификацию функциональных программ с SMT солверами</h3>
<div class="paragraph">
<p>Очень непрактичная тема, потому что в функциональных программах багов нет. :)</p>
</div>
<div class="paragraph">
<p>И да, это не верификация в стиле Coq.</p>
</div>
<div class="paragraph">
<p>Когда пытаются сделать верификатор языка, первым вопросом встает дилемма: будем мы делать верификатор какого-то ограниченного
искусственного языка программировния с минимальным набором фич, или мы возьмем какой-нибудь существующий практичный язык программирования
и сделаем верификацию для него?</p>
</div>
<div class="paragraph">
<p>Плюсы первого случая в том, что набор фич, которые нужно поддержать мал и известен заранее, т.е. виден конец
задачи и работа может планироваться. Недостатком первого подхода является то, что даже если верификатор будет работать хорошо, то он бесполезен
в том смысле, что его нельзя натравить на программу из реального мира. Инкрементальное добавление фич в язык может оказаться трудной задачей
по нескольким причинам:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Их нужно добавить очень много, чтобы получилось что-то соответсвующее реальному языку.</p>
</li>
<li>
<p>Нужно планировать новые фичи, чтобы не приходилось всё переписывать. В некотором смысле список фич, которыми будем расширять, должен быть известен заранее.</p>
</li>
<li>
<p>Добавление одной
"неправильной" фичи, может сделать задачу верификации неразрешимой. Другими словами приблизиться к концу и доделать может не хватить
сил по объективным и субъективным причинам. Подход к верификации может оказаться полностью несостоятельным в самом конце, когда
появится фича, которую невозможно поддержать при данном подходе</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Другой подход, заключающийся в верификации реального языка программирования, имеет другие проблемы</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Очень часто надо будет поддержать <em>все</em> фичи языка до конца, потому что даже стандартная библиотека использует все фичи (потому что может).
Т.е. нет никакой промежуточной точки, что сказать, что мы решили задачу частично</p>
</li>
<li>
<p>Практические языки очень богаты, поэтому это просто уйма работы. К тому же арифметика указателей это жуткая боль для верифицирования,
много где она есть, но лучше бы её не было.</p>
</li>
<li>
<p>Практические языки дизайнились как попало, так что поприветсвуйте кучу странных граблей, когда в С# у значения <em>null</em> нет типа от слова совсем.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>На 4м этаже бойцы занимаются верификаций с SMT солверами языка C# и имеют там некоторые неразрешимые проблемы. Хочется сделать верификацию языка,
который адекватно задизайнен (в отличие от C#), а именно Haskell или OCaml. Ожидается, что это должно быть лучше C# потому что</p>
</div>
<div class="ulist">
<ul>
<li>
<p>язык адекватный и поменьше.</p>
</li>
<li>
<p>меньше программ с присваиванием&#8201;&#8212;&#8201;меньше проблем с верификацией.</p>
</li>
<li>
<p>Кучу алгебраических типов верифицировать должны быть проще, чем кучу объектов. В SMT солверах уже есть процедуры для верификации в присутствии
алгебраических типов.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Замечание: OCaml можно заменить на Haskell. Просто первый и компилятор его я знаю лучше и больше смогу помочь.</p>
</div>
<div class="paragraph">
<p>Замечание: Задача чрезвычайно <span class="line-through">сложная</span> интересная.</p>
</div>
<div class="paragraph">
<p>Milestone номер какой-то (к чему пока надо стремиться). Чтобы программа</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="haskell"><span></span><span class="tok-nf">add</span> <span class="tok-n">x</span> <span class="tok-n">y</span> <span class="tok-ow">=</span> <span class="tok-n">x</span><span class="tok-o">+</span><span class="tok-n">y</span>
<span class="tok-nf">iter</span> <span class="tok-n">f</span> <span class="tok-n">s</span> <span class="tok-n">n</span> <span class="tok-o">|</span> <span class="tok-n">n</span><span class="tok-o">&lt;</span><span class="tok-mi">0</span> <span class="tok-ow">=</span> <span class="tok-n">s</span>
<span class="tok-nf">iter</span> <span class="tok-n">f</span> <span class="tok-n">s</span> <span class="tok-n">n</span>       <span class="tok-ow">=</span> <span class="tok-n">f</span> <span class="tok-n">n</span> <span class="tok-p">(</span><span class="tok-n">iter</span> <span class="tok-n">f</span> <span class="tok-n">s</span> <span class="tok-p">(</span><span class="tok-n">n</span><span class="tok-o">-</span><span class="tok-mi">1</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>превращалась в формулы (в синтаксисе SMT2lib)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="lisp"><span></span><span class="tok-p">(</span><span class="tok-nv">rule</span> <span class="tok-p">(</span><span class="tok-nv">=&gt;</span> <span class="tok-p">(</span><span class="tok-nb">=</span> <span class="tok-nv">z</span> <span class="tok-p">(</span><span class="tok-nb">+</span> <span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">))</span>
          <span class="tok-p">(</span><span class="tok-nv">add</span> <span class="tok-nv">x</span> <span class="tok-nv">y</span> <span class="tok-nv">z</span> <span class="tok-p">)</span>
<span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nv">rule</span> <span class="tok-p">(</span><span class="tok-nv">=&gt;</span> <span class="tok-p">(</span><span class="tok-nb">and</span> <span class="tok-p">(</span><span class="tok-nb">&lt;=</span> <span class="tok-nv">n</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
               <span class="tok-p">(</span><span class="tok-nb">=</span> <span class="tok-nv">m</span> <span class="tok-nv">s</span><span class="tok-p">))</span>
          <span class="tok-p">(</span><span class="tok-nv">iter</span> <span class="tok-nv">f</span> <span class="tok-nv">s</span> <span class="tok-nv">n</span> <span class="tok-nv">m</span><span class="tok-p">)</span>
<span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nv">rule</span> <span class="tok-p">(</span><span class="tok-nv">=&gt;</span> <span class="tok-p">(</span><span class="tok-nb">and</span> <span class="tok-p">(</span><span class="tok-nb">&gt;</span> <span class="tok-nv">n</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
               <span class="tok-p">(</span><span class="tok-nv">iter</span> <span class="tok-nv">f</span> <span class="tok-nv">s</span> <span class="tok-p">(</span><span class="tok-nb">-</span> <span class="tok-nv">n</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-nv">p</span> <span class="tok-p">)</span>
               <span class="tok-p">(</span><span class="tok-nv">f</span> <span class="tok-nv">n</span> <span class="tok-nv">p</span> <span class="tok-nv">m</span><span class="tok-p">))</span>
          <span class="tok-p">(</span><span class="tok-nv">iter</span> <span class="tok-nv">f</span> <span class="tok-nv">s</span> <span class="tok-nv">n</span> <span class="tok-nv">m</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Всё можно делать в лоб, но если очень хочется, то можно и что-то почитать: <a href="https://github.com/ksluckow/awesome-symbolic-execution">раз</a> и <a href="https://github.com/season-lab/survey-symbolic-execution">два</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_active_patterns_в_ocaml">Active Patterns в OCaml</h3>
<div class="paragraph">
<p>В Haskell они есть (называются Pattern Synonyms), в F#&#8201;&#8212;&#8201;тоже, а в OCaml непорядок.</p>
</div>
<div class="paragraph">
<p>Задача изначально появилась в <a href="https://github.com/ocamllabs/compiler-hacking/wiki/Add-a-%22with%22-syntax-for-patterns">Кембридже</a>.
По ссылке есть описание поддержки не их, но сходной фичи; написано в каком порядке что делать, чтобы начать приближаться к Active Pattern&#8217;ам.
Иными словами задачи разбивается на две связанные</p>
</div>
<div class="ulist">
<ul>
<li>
<p>With syntax for patterns</p>
</li>
<li>
<p>Pattern Synonyms a.k.a. Active Patterns</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Про OCaml можно спрашивать людей на <a href="https://discuss.ocaml.org/">форуме</a> или в <a href="https://discordapp.com/invite/cCYQbqN">Discord</a>.</p>
</div>
<div class="paragraph">
<p>Формально это сделано в F\# и Haskell, почитать формальный текст можно
<a href="https://web.engr.oregonstate.edu/~erwig/papers/PGandTP_Haskell00.pdf">тут</a> и
<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf">тут</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_про_gui_и_функциональное_программирование">Про GUI и функциональное программирование</h3>
<div class="paragraph">
<p>Вообще, проектирование GUI можно делать двумя разными способами: можно делать GUI на том же языке, что и бизнес-логику, а можно разносить в несколько языков.
Преимуществом первого подхода является то, что разработка ведется на одном и том же языке (не надо учить ничего нового лишнего). Недостатком первого
и преимуществом второго подходов является то, что у нас появляется некоторый DSL для проектирования GUI. Этот DSL удобнее чем просто писать код: создавать
объекты-кнопочки и складывать их в контейнеры (кто делал GUI на Java+Swing, тот меня поймет).</p>
</div>
<div class="paragraph">
<p>В мире GUI интерфейсы фреймворки эволюционировали большую часть времени только в рамках объектно-ориентированной парадигмы (хотя в
последнее время в моду вошла реактивность). Поэтому, большинство крутых GUI фреймворков делалось для С++ и подобных языков. Функциональным
языкам оставалось налаживать взаимодействие с писаными на C++ классами, чтобы элементы управления можно было создавать из кода на
OCaml/Haskell. В результате получились биндинги к Tck/Tk, GTK+, которые выглядят так же отвратительно как Swing в Java. Создавать
GUI фреймворки только для функциональных языков являлось непрактичным.</p>
</div>
<div class="paragraph">
<p>В нулевых-десятых годах появились способы проектирования GUI, которые не так явно завязаны на использовании ООП, они предлагают
в том числе DSL
для проектирования GUI и подерживают аппаратно ускоренный рендеринг через OpenGL. Примерами могут быть WPF, JavaFX и
<a href="https://qmlbook.github.io/">Qt/QML</a>.  Лично
я <a href="https://github.com/Kakadu/lablqml">занимался</a>
созданием библиотеки для использования Qt/Qml для OCaml. По сути QML является языком разметки GUI с поддержкой реактивного программирования, и скриптов
на Javascript, чтобы делать простые действия в GUI (например менять цвет чего-то там в зависимости от выбранного в ComboBox). Бизнес-логика,
от которой требуется надежность и производительность (чатайте, типобезопасность и скорость), по задумке Qtшников должна писться на С++ и легко
интегрироваться с Qt/Qml.</p>
</div>
<div class="paragraph">
<p>Поделку про OCaml и Qt/QML я сделал, но она не была оценена по достоинству у сообщества камлистов, я полагаю потому, что статически типизированные
программисты априори с подозрением смотрят на плохотипизированный скрипт внутри Qt/QML.</p>
</div>
<div class="paragraph">
<p>Также, говоря про GUI, нельзя не упомянуть веб и браузеры. Javascript захватил мир веба по историческому недоразумению; народ плачет, плюется,
но продолжает есть кактус, потому что поделки в стиле TypeScript с gradual typing на борту как-то не взлетают. Но программы на Javascript как-то
делаются и кое-как работают. Сейчас движки для создания приложений на основе Javascript и движка HTML страниц (читайте, Electron) заползают и
на десктоп, поэтому мы радостно наблюдаем как Discord, банальный групповой чатик, зависает с пожиранием гигабайта оперативы.</p>
</div>
<div class="paragraph">
<p>Пару лет назад появился ещё один способ для типобезопасного программирования для web, а именно, <a href="https://reasonml.github.io/">ReasonML</a>,
который является</p>
</div>
<div class="ulist">
<ul>
<li>
<p>языком OCaml, который прозрачно компилируется в Javascript</p>
</li>
<li>
<p>языком OCaml с "испорченным" синтаксисом: фигурные скобочки возле каждого объявления функции, как в Javascript;
некаррированный синтаксис для вызова функций (с кучей ненужных скобочек и запятых), как в Javascript; объекты с синтаксисом как
Javascript; изкоробочной поддержкой библотеки дизайна компонент интерфейсов React (от Facebook). Короче, всё чтобы хомячки из Javascript приняли новый язык. и они походу его действительно принимают.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Теперь стоит сказать про новоиспеченный проект <a href="https://github.com/revery-ui/revery">Revery</a>, где народ на ReasonML делает новый
(ещё один новый с нуля, Карл!) фреймворк
для клепания GUI, с блекджеком, OpenGL и реактивным программированием. Мотивацией служит отказ от Electron для создания шустрого
легковесного кроссплатформенного тулкита. Это всё конечно логично, но давайте лучше</p>
</div>
<div class="ulist">
<ul>
<li>
<p>возьмем синтаксис ReasonML;</p>
</li>
<li>
<p>HTML+ReactJs синтаксис будем транслировать в компоненты Qt/Qml;</p>
</li>
<li>
<p>OCaml/ReasonML логику будем транслировать в Javascript (ReasonML уже умеет это делать);</p>
</li>
<li>
<p>автоматически получить возможность линковаться с большим количество проектов, которые уже сделаны в инфраструктуре Qt;</p>
</li>
<li>
<p>PROFIT.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Сейчас Revery на уровне синтаксического дерева транслирует синтаксис HTML в отрисовку GUI. Хочется поставить эксперимент, чтобы
HTML/ReactJs компоненты транслировались в Qt/Qml, всё линковалось и запускалось.</p>
</div>
<div class="paragraph">
<p>Первый milestone. Все HTML-like конструкции <code>&lt;view бла-бла&gt; бла-бла&lt;/view&gt;</code> должны транслироваться в отрисовку Qt/QML окошка с "Hello world". Функция
<code>UI.start</code> должно просто показывать это новое окошко.</p>
</div>
</div>
<div class="sect2">
<h3 id="_автовекторизация_в_компиляторе">Автовекторизация в компиляторе</h3>
<div class="paragraph">
<p>Тема для инетерсующихся ассемблером</p>
</div>
<div class="paragraph">
<p>В компиляторе OCaml, на сколько я знаю, с автовекторизацией SIMD дела обстоят никак.
<a href="https://github.com/ocaml/ocaml/blob/trunk/asmcomp/x86_ast.mli#L97">Вот тут</a> те инстукции, которые компилятор знает.
Предлагается найти какие-нибудь примеры, где SIMD дает прирост производительности. И наладить автовекторизацию.</p>
</div>
<div class="paragraph">
<p>Вон некоторые реализации JVM умеют это делать при JITтинги, чем мы хуже?</p>
</div>
<div class="paragraph">
<p>Вот какие-то ссылки</p>
</div>
<div class="paragraph">
<p><a href="https://news.ycombinator.com/item?id=12352959">Does a compiler use all x86 instructions?</a></p>
</div>
<div class="paragraph">
<p><a href="https://www.agner.org/optimize/optimizing_assembly.pdf" class="bare">https://www.agner.org/optimize/optimizing_assembly.pdf</a></p>
</div>
<div class="paragraph">
<p><a href="https://www.felixcloutier.com/x86/index.html">Список инструкций</a></p>
</div>
<div class="paragraph">
<p><a href="https://blog.janestreet.com/what-is-gained-and-lost-with-63-bit-integers/" class="bare">https://blog.janestreet.com/what-is-gained-and-lost-with-63-bit-integers/</a></p>
</div>
<div class="paragraph">
<p><a href="https://github.com/OpenDreamKit/OpenDreamKit/issues/118">Write an assembly superoptimiser supporting AVX and upcoming Intel processor extensions for the MPIR library and optimise MPIR for modern processors</a></p>
</div>
<div class="paragraph">
<p><a href="https://dl.acm.org/citation.cfm?id=3306172">Про автовекторизацию в LLVM</a></p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-09-01 19:32:09 +0300
</div>
</div>
<link rel="stylesheet" href="./pygments-monokai.css">
</body>
</html>