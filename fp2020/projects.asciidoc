:source-highlighter: pygments
:pygments-style: monokai
:local-css-style: pastie
:toc:

Список курсовых/миникурсовых
============================
:Author: Dmitrii Kosarev a.k.a. Kakadu
:email:  Dmitrii.Kosarev@pm.me


*Темы* преимущественно про функциональное программирование. Во всех темах de facto консультирует mailto:Dmitrii.Kosarev@protonmail.ch[Дмитрий Косарев] (записываться на тему у него), а mailto:rsdpisuy@gmail.com[Семен Григорьев] руководит de jure, а de facto читает тексты и презентации.

Такой же документ за прошлый год link:../fp2019/projects.html[здесь].

TODO: задачи на допуск к допуску на вход.


[[reasonml]]
Про ReScript/OCaml
------------------

Так как погромисты на Java не могут никак осилить синтаксис нормальных функциональных языков программирования,
в Bloomberg (а потом и в Facebook)
было предложено совершить ход конём и немного [.line-through]#исправить# испортить синтаксис уже имеющегося языка
функционального программирования OCaml, чтобы он был более
похож на привычный синтаксис с фигурными скобками и точками с запятой. Получившийся в результате https://rescript-lang.org/[Rescript] (ранее известный как BuckleScript/ReasomML), хомячкам вроде понравился.

С таким подходом вроде бы всё хорошо, но есть проблема для чистокровных OCaml программистов: язык действительно сильно похож, но
непохожести очень сильно бесят, никак не получается выкинуть из головы выученный синтаксис и пользоваться новым, потому что то, что
видно на экране очень сильно напоминает "старый" синтаксис OCaml. В итоге получаются ошибки, которые очень глупые, но компилятор
ReasonML всёравно не доволен. И, наоборот, с ReScript может быть сложно пересесть на OCaml по сходным причинам.

Вот пример кода на OCaml:
[source,ocaml]
----
type 'a expr = Const : int     -> 'a expr
             | App   : 'a * 'a -> 'a expr
             | Lam   : string * 'a -> 'a expr

let foo e = match e with
  | Const n -> n
  | App (l,r) ->
      let () = print_endline "blabla" in
      r
  | Lam (s, b) -> b
----

А вот, что получается при https://reasonml.github.io/en/try[трансляции] в ReScript.
[source,ocaml]
----
type expr('a) =
  | Const(int): expr('a)
  | App('a, 'a): expr('a)
  | Lam(string, 'a): expr('a);

let foo = e =>
  switch (e) {
  | Const(n) => n
  | App(l, r) =>
    let () = print_endline("blabla");
    r;
  | Lam(s, b) => b
  };

----

[[rescript-recovery]]
Парсер синтаксиса ReScript, с восстановлением от ошибок
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Необходимо,чтобы парсер лучше понимал "камлизмы", и получше восстанавливался от ошибок, связанных с ними.

Замечание: в ReScript есть также старый парсер, который разбирает язык похожий на OCaml.
Можно исправлять его (ссылку найдете сами).

*Уровень*: курсовая второго-третьего курса; может быть бакалаврская, если откроются много интересных подзадач.

С чего начинать: Вот https://github.com/rescript-lang/syntax[тут]  можно найти парсер, написанный рекурсивным спуском. Можно смотреть как он ведет себя на программах, где синтаксис двух языков перемешан.



[[rescript-combinators]]
Парсер ReScript, с использованием подхода парсер-комбинаторов
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

На данный момент парсер ReasonML написан методом рекурсивного спуска. Скорее всего от парсер-комбинаторов отказались из-за опасений недостаточной производительности (хотя видео Джонатана Блоу, создателя Braid, я не смотрел). Хочется

. Подтвердить или опровергнуть, что парсер-комбинаторы торомозят.
. Проверять, что с ними писать более удобно не нужно (потому, что это вроде как очевидно).
. Предъявить техники написания парсер-комбинаторов, которые повышают производительность итогового парсера. Например
.. В таких-то случаях нам нужна мемоизация, а в таких-то она не поможет
.. Тогда-то стандартный подход лучше как-то видоизменить
.. Здесь лучше рекурсию сменить на итерацию
.. А тут аппликативные парсеры работают шустрее, чем монадические.
.. Ну или "мы тупо пишем с парсер-комбинаторами, код в 10 раз короче, работает всего лишь на 10% медленнее. Победа"

*Уровень*: курсовая/ВКР в зависимости от поставленных задач.

С чего начинать:

. посмотреть на библиотеки парсер-комбинаторов;
.. https://github.com/inhabitedtype/angstrom[Angstrom]
.. https://github.com/dboulytchev/ostap/[Ostap] и т.п.
. разобраться с особенностями-недостатками похода: левая рекурсия, longest match first.
. начать переписывать парсер на основе кодовой базы https://github.com/rescript-lang/syntax[ReScript]

Требования к обучающемуся:

- желательно знакомство с ФП языками (OCaml, Haskell, Scala 3);
- желателен общий кругозор в области синтаксического анализа (LL, LR, GLR, GLL, Packrat, Meerkat).

+++ <details><summary> +++
[.underline]#*Подробнее (спойлер)*#
+++ </summary><div> +++

Тип работы: эксперимент.

В результате **не должно** казаться так, что это работа на выходные про "закодить парсер какого-то подмножества ReScript".

. В OCaml/ReScript существует много библиотек парсер-комбинаторов. Студент должен выбрать одну, быть способен обосновать выбор и кратко сказать в чем преимущества и недостатки остальных реализаций парсер-комбинаторов.
. В используемой библиотеке парсер-комбинаторов может чего-то не хватать, например, может отсутствовать поддержка мемоизации парсер-функций высшего порядка. Если студент доделает и улучшит библиотеку чем-то таким, то это будет плюсом для оценки работы в целом.
. Если в процессе работы будет поддержан весь ReScript, т.е. можно будет заменить парсер в компиляторе ReScript и собрать некоторое количество пакетов с ним, то это тоже будет плюсом.
. Если новый парсер будет
  .. занимать меньше строк
  .. не сильно проседлать по производительности
  .. поддерживать всё, что умеет предыдущий парсер (фичи языка, восстановление от ошибок)
+
то это тоже будет существенным плюсом работы.

+++ </div></details> +++

[[ocaml-ide]]
Про интеграцию OCaml с IDE
--------------------------

На данный момент интеграцию с IDE для языка OCaml предоставляет проект https://github.com/ocaml/merlin/[merlin]. Также существует надстройка над ним https://github.com/ocaml-lsp/ocaml-language-server[OCaml Language Server], реализующая
https://microsoft.github.io/language-server-protocol/[Language Server Protocol], которая позволяет соединять бэкэнд интеграции IDE c любимым текстовым редактором. Фронт работ в этой области связан с

- добавлением новых рефакторингов и т.п.
- поддержка модификаций синтаксиса, а также восстановление от ошибок синтаксиса.

TODO: видео с Spb Rust Meetup 2019 от matklad.

Публикации из этой области могут выглядеть так:

- https://icfp18.sigplan.org/details/icfp-2018-papers/19/[Merlin, ICFP 2018]
- https://dl.acm.org/doi/pdf/10.1109/IWoR.2019.00013[RoToR, IWoR 2019]


[[semantich-highlighting]]
Семантическая подсветка (и/или) идентация
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В функциональном программиовании часто используется паттерн проектирования, заключающийся в создании встраиваемых предметно-ориентированных языков (Embedded Domain Specific languages, EDSLs) для некоторых видов API, например:

- eDSL для создания запросов к реляционной базе данных
- для описания XML

Такие встраиваемые языки часто требуют особых правил подстветки и отступов по сравнению с host-языком, куда они встроены.
Сейчас в LSP уже https://github.com/microsoft/language-server-protocol/issues/18[ведется работа] по добавлению в спецификацию возможностей semantic highlighting. (P.S. Похоже её таки уже добавили в спецификацию: вот https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_colorPresentation[про цвета] и вот https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_formatting[про форматирование])

Что надо сделать:

- расширить реализацию https://github.com/ocaml/ocaml-lsp[OCaml Language Server] поддержкой раскрашивания синтаксиса
- сделать возможность описывать правила подстветки кода библиотекам на OCaml
- доделать редактор кода, который умеет общаться с LSP сервером (например, https://marketplace.visualstudio.com/items?itemName=ocamllabs.ocaml-platform[VS Code]), чтобы он научился показывать то, что прислал сервер.

Замечание: настраиваемые авто-отступы можно выделить в отдельную похожую тему.

*Уровень*: курсовая; возможен последующий апгрейд до бакалаврской.

Пожелания к обучающемуся:

- знакомство с OCaml;
- знакомство с eDSL;
- знакомство с технологией разработки/расширения соответствующего редактора (для VS Code это язык TypeScript);
- отсутствие страха окунуться в большие проекты.

[[ide-camlp5]]
Поддержка синтаксических расширений на основе Camlp5
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

На данный момент в OCaml/Merlin поддерживаются синтаксические расширения на основе PPX. Последовательность обработки примерно такая:

- входной код на OCaml разбирается парсером merlin в абстрактное синтаксическое дерево (AST)
- merlin'у объяснены используемые compile-time синтаксические расширения, он их применяет, чтобы преобразовать OCaml AST в другое OCaml AST
- после всех преобразований запускается проверка типов, поиск рефакторингов и т.п.

Особенности данного подхода:

- синтаксический анализ проводится только над AST OCaml, что не дает расширять синтаксис произвольным способом.

При этом в экосистеме OCaml присутствует альтернативный способ расширения синтаксиса с помощью https://github.com/camlp5/camlp5/[Camlp5]. Его особенности

- расширяемый парсер, отличный от используемого в компиляторе OCaml, позволяет описывать модификации синтаксиса на интересном eDSL.
- позволяет изменять грамматику очень сильно; у этого есть как особенности, так и недостатки.

*Что надо сделать*. Необходимо добавить в OCamlMelrin+OCamlLSP поддержку синтаксических расширений на основе Camlp5:

- научить merlin понимать информацию о подключенных синтаксических расширениях Camlp5
- изменить логику так, чтобы в присутствии Camlp5 сначала применялся парсер Camlp5, который на выходе даст AST компилятора OCaml, уже после это применять расширения синтаксиса на основе PPX.
- уже после этого запускать поиск рефакторингов и т.п.

*Уровень*: курсовая; возможен последующий апгрейд до бакалаврской.

Пожелания к обучающемуся:

- знакомство с OCaml;
- отсутствие страха окунуться в большие проекты.


Замечание: если в ходе работы окажется, что парсер Camlp5 плохо восстанавливается от ошибок, то возможно выделение отдельной темы по этому поводу.



[[miniKanren]]
miniKanren
----------

У нас в лаборатории есть некоторая "тусовка" на тему реляционного (логического) программирования на
http://minikanren.org/[miniKanren]. Если кратко,
то это DSL, чтобы относительно естественно решать переборные задачи, например, "перебери мне все программы, и дай те, которые
возвращают свой текст". Есть ещё своя реализация miniKanren, которая называется https://github.com/dboulytchev/ocanren[OCanren],
на функциональном языке программирования
OCaml (он более дружелюбен к новичку, чем Haskell, ИМХО, конечно же).

Скажу сразу, miniKanren -- это околонаучная штука на любителя.

TODO: добавить мотивирующее видео от Matthew Might'а с miniKanren Workshop 2020

// Concurrency/parallelism для miniKanren
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// Полный перебор жутко тормозит по определению, а его мы пока запускаем только на одном ядре. Хотелось бы поставить эксперимент
// с использованием concurrency, которая есть в "изкоробочном" компиляторе OCaml. А затем, если всё продолжит работать правильно,
// то воспользоваться неофициальной версией компилятора multicore OCaml (она в разработке). Они там сделали что-то прикольное с
// использованием algebraic effects и утверждают, что API многопоточности гораздо адекватнее, чем в Java. Я не проверял и поверил
// товарищам из английского Cambridge на слово.

// Заранее отвечаю на вопрос с попыткой развести срач. Python.

[[mk-memoization]]
Про мемоизацию
~~~~~~~~~~~~~~

Евгений Моисеенко сделал tabling (связанные понятия: мемоизация и кеширование) для OCanren некоторым способом, но есть ещё и другой, на основе Substitution Tree Indexing by Peter Graph.
Разумеется, всё придумали до нас, и нужно только прочитать и реализовать.

*Уровень*: курсования

От студента требуется:

- отсутствия страха читать статьи на английском
- желание попрограммировать немного на OCaml.


// Error messages
// ~~~~~~~~~~~~~~

// Когда мы адаптировали miniKanren c нетипизированного Scheme на строго статически типизированный OCaml у нас получились довольно длинные типы,
// которые неудобно читать в тексте сообщений об ошибках компиляции. Хочется сделать плагин к компиялтору, который будет преобразовывать
// сообщения об ошибках в более специфичный для miniKanren вид. В самом компиляторе уже есть плагины
// (https://caml.inria.fr/pub/docs/manual-ocaml/plugins.html[мануал]), которые позволяют добавлять хуки кое-куда, но не туда куда нам надо.
// Нужно докрутить хуки, чтобы можно было видоизменять сообщения об ошибках на более читаемые для предметной области.



// Про доделываение механизма quotation/antiquotation
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// У нас есть проект https://github.com/Kakadu/GT/tree/ppx[GT], про генерацию кода (код представляется как AST) по объявлениям типов.
// В нём поддерживается работа с AST OCaml (a.k.a. PPX),
//  а также с несколько устаревшей AST Camlp5. И для той и другой штуки существуют механизмы quotation/antiquotation, но каждая реализация
// работает со своим видом синтаксического дерева и не совместима с другим видом синтаксического дерева.
// Поэтому в GT мы вынуждены генерировать синтаксические деервья (т.е. код) без quotations, а с использованием банальных вызовов функций
// конструирования, что очень неудобно.

// Предлагается посмотреть на то, как сделан https://github.com/ocaml-ppx/ppxlib/blob/master/metaquot/ppxlib_metaquot.ml[механизм quotation] для PPX,
// почитать https://github.com/ocaml-ppx/ppx_tools/blob/master/ppx_metaquot.ml[README] и сделать клон, который

// * генерирует не какое-то AST, а вызовы https://github.com/Kakadu/GT/blob/ppx/common/GTHELPERS_sig.ml[функций],
// которые генерируют AST. Так мы сможем подменять реализации и получать генерацию разного вида AST
// * понять как устроен metaquot и может быть поддержать неподдержанные синтаксические конструкции: например сейчас никак нельзя использовать quoataiton
// для классов и объектов


[[pandoc]]
Pandoc
------

Сегодня СПбГУ засталвляет преподов создавать документ "РПУД" (Рабочая программа учебной деятельности) в DOCX формате.
Редактировать такое в Word -- это боль, поэтому преподы хотели бы использовать LaTeX для этого (или какой-либо другой текстовый формат, где хорошо работает версионирование и облегчено комментирование изменений). Поэтому, надо научиться преобразовывать документы из LaTex в DOCX.

Проект https://github.com/jgm/pandoc[Pandoc] (написанный на Haskell) существует как раз для этого. Он уже умеет преобразоывать
заголовки и прочий кириллический текст в DOCХ (и в большое количество других форматов документов), но, по-видимому, поддержка таблиц и тутульной страницы не реализована никак.

*Задача*: доработать Pandoc до состояния, при котором можно адекватно преобразовать проект РПУДа из LaTeХ в DOCX.

В общем виде преобразовывать произвольный LaTeX нереально, так как там есть даже встроенный язык программирования. Необходимо поддержать только те фичи, которые нужны для преобразования документов РПУД.

*Уровень*: курсовая.


[[incremental]]
Инкрементальные вычисления с матрицами
--------------------------------------

Существует некоторая тусовка инженеров-исследователей, которые сводит все задачи (например, синтаксический анализ графов) к перемножению матриц (например, инциденций) на GPU. При этом, если меняется одна ячейка в матрице (доабвляется новое ребро в графе) или появляются новые строки/столбцы в матрице (добавляется новая вершина в
граф), то новые результаты перемножения матриц получаются *повторным* перемножением на GPU.

Есть предложение оптимизировать это стандартными способами, например применением *инкрементальных* вычислений.
Идея инкрементальных вычислений заключается в том, что по вычисляемой функции строится некоторая модель
вычисления, зависящая от входных аргументов, и когда меняется один из аргументов, то перевычисляются только
те подвыражения, которые зависят от этих изменившихся аргументов. Например, для случая изменения одной ячейки
матрицы, нам нужно перевычислить некоторое количетсво сумм, линейно пропорциональное размерам матрица, в то
время как перемножение матриц заново имеет квадратичную сложность (пусть и на GPGPU).

Задача заключается в том, чтобы поэкспериментировать с инкрементальными вычислениями матриц (например,
с помощью библиотеки инкрементальных вычислений https://github.com/janestreet/incremental[для языка OCaml])
и попробовать разобраться, можно ли таким способом ускорить перевычисление при изменении матриц.

*Уровень*: курсовая

В планах лежит попытка это опубликовать на тематическм воркшопе GRADES NDA (ну или на нашем родном SEIM).

// Руководители mailto:rsdpisuy@gmail.com[Семен Григорьев] и mailto:Dmitrii.Kosarev@protonmail.ch[Дмитрий Косарев]


[[ic3]]
Про Eldarica и IC3
------------------

Как-то один человек попросил меня придумать тему про Scala, но ничего лучше, чем это у меня не получилось.

https://github.com/uuverifiers/eldarica[Eldarica] --- это SAT/SMT солвер написанный на Scala. Идея работы заключается в добавлении туда чего-нибудь. В код я особо не лазал, в чем Эльдарика особенно хороша я не знаю, по хорошему надо бы написать письмо Рюммеру и поинтересоваться куда он хочет её развивать.

Предлагается в каком-то виде прикрутить алгоритм IC3 к Эльдарике. Вот какие-то https://www.cs.tau.ac.il/~msagiv/courses/asv/IC3.pdf[слайды] про алгоритм, умные научные статьи сможете найти сами. Алгоритм мудрёный, там замешана мат. логика, так что пока разберётесь, то придется пострадать.

. Как минимум,  должен быть реализован рабочий алгоритм на Scala.
. По хорошему, он ещё должен интегрироваться с Эльдарикой, использовать наработки, которые там уже сделаны и т.п.
. Алгоритм должен получиться максимально аккуратно реализован и хорошо читаем. Основная цель работы: полшучить реализацию, с помощью которой можно максимально быстро объяснить новым людям (базово знакомым с мат. логикой) "потроха".
. В идеале алгоритм должен параметризовываться модулем, который
.. либо ничего интересного не делает и на производительность не влияет
.. либо логгирует трассировку промежуточных состояний (графически отображает, что происходит) для  облегчения понимания того, что происходит.
. Совсем идеальный вариант: алгоритм должен работать не сильно медленнее, чем аналогичная реализация на С++.




// Про верификацию функциональных программ с SMT солверами
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// Очень непрактичная тема, потому что в функциональных программах багов нет. :)

// И да, это не верификация в стиле Coq.

// Когда пытаются сделать верификатор языка, первым вопросом встает дилемма: будем мы делать верификатор какого-то ограниченного
// искусственного языка программировния с минимальным набором фич, или мы возьмем какой-нибудь существующий практичный язык программирования
// и сделаем верификацию для него?

// Плюсы первого случая в том, что набор фич, которые нужно поддержать мал и известен заранее, т.е. виден конец
// задачи и работа может планироваться. Недостатком первого подхода является то, что даже если верификатор будет работать хорошо, то он бесполезен
// в том смысле, что его нельзя натравить на программу из реального мира. Инкрементальное добавление фич в язык может оказаться трудной задачей
// по нескольким причинам:

// *  Их нужно добавить очень много, чтобы получилось что-то соответсвующее реальному языку.
// * Нужно планировать новые фичи, чтобы не приходилось всё переписывать. В некотором смысле список фич, которыми будем расширять, должен быть известен заранее.
// * Добавление одной
// "неправильной" фичи, может сделать задачу верификации неразрешимой. Другими словами приблизиться к концу и доделать может не хватить
// сил по объективным и субъективным причинам. Подход к верификации может оказаться полностью несостоятельным в самом конце, когда
// появится фича, которую невозможно поддержать при данном подходе

// Другой подход, заключающийся в верификации реального языка программирования, имеет другие проблемы

// * Очень часто надо будет поддержать _все_ фичи языка до конца, потому что даже стандартная библиотека использует все фичи (потому что может).
// Т.е. нет никакой промежуточной точки, что сказать, что мы решили задачу частично
// * Практические языки очень богаты, поэтому это просто уйма работы. К тому же арифметика указателей это жуткая боль для верифицирования,
// много где она есть, но лучше бы её не было.
// * Практические языки дизайнились как попало, так что поприветсвуйте кучу странных граблей, когда в С# у значения _null_ нет типа от слова совсем.

// На 4м этаже бойцы занимаются верификаций с SMT солверами языка C# и имеют там некоторые неразрешимые проблемы. Хочется сделать верификацию языка,
// который адекватно задизайнен (в отличие от C#), а именно Haskell или OCaml. Ожидается, что это должно быть лучше C# потому что

// * язык адекватный и поменьше.
// * меньше программ с присваиванием -- меньше проблем с верификацией.
// * Кучу алгебраических типов верифицировать должны быть проще, чем кучу объектов. В SMT солверах уже есть процедуры для верификации в присутствии
// алгебраических типов.

// Замечание: OCaml можно заменить на Haskell. Просто первый и компилятор его я знаю лучше и больше смогу помочь.

// Замечание: Задача чрезвычайно [.line-through]#сложная# интересная.

// Milestone номер какой-то (к чему пока надо стремиться). Чтобы программа

// [source,haskell]
// ----------------
// add x y = x+y
// iter f s n | n<0 = s
// iter f s n       = f n (iter f s (n-1))
// ----------------

// превращалась в формулы (в синтаксисе SMT2lib)

// [source,lisp]
// -------------
// (rule (=> (= z (+ x y))
//           (add x y z )
// ))

// (rule (=> (and (<= n 0)
//                (= m s))
//           (iter f s n m)
// ))

// (rule (=> (and (> n 0)
//                (iter f s (- n 1) p )
//                (f n p m))
//           (iter f s n m))
// -------------

// Всё можно делать в лоб, но если очень хочется, то можно и что-то почитать: https://github.com/ksluckow/awesome-symbolic-execution[раз] и https://github.com/season-lab/survey-symbolic-execution[два].

// // Active Patterns в OCaml
// // ~~~~~~~~~~~~~~~~~~~~~~~

// // В Haskell они есть (называются Pattern Synonyms), в F# -- тоже, а в OCaml непорядок.

// // Задача изначально появилась в https://github.com/ocamllabs/compiler-hacking/wiki/Add-a-%22with%22-syntax-for-patterns[Кембридже].
// // По ссылке есть описание поддержки не их, но сходной фичи; написано в каком порядке что делать, чтобы начать приближаться к Active Pattern'ам.
// // Иными словами задачи разбивается на две связанные

// // * With syntax for patterns
// // * Pattern Synonyms a.k.a. Active Patterns

// // Про OCaml можно спрашивать людей на https://discuss.ocaml.org/[форуме] или в https://discordapp.com/invite/cCYQbqN[Discord].

// // Формально это сделано в F\# и Haskell, почитать формальный текст можно
// // https://web.engr.oregonstate.edu/~erwig/papers/PGandTP_Haskell00.pdf[тут] и
// // https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf[тут].


// Про GUI и функциональное программирование
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// Вообще, проектирование GUI можно делать двумя разными способами: можно делать GUI на том же языке, что и бизнес-логику, а можно разносить в несколько языков.
// Преимуществом первого подхода является то, что разработка ведется на одном и том же языке (не надо учить ничего нового лишнего). Недостатком первого
// и преимуществом второго подходов является то, что у нас появляется некоторый DSL для проектирования GUI. Этот DSL удобнее чем просто писать код: создавать
// объекты-кнопочки и складывать их в контейнеры (кто делал GUI на Java+Swing, тот меня поймет).

// В мире GUI интерфейсы фреймворки эволюционировали большую часть времени только в рамках объектно-ориентированной парадигмы (хотя в
// последнее время в моду вошла реактивность). Поэтому, большинство крутых GUI фреймворков делалось для С\++ и подобных языков. Функциональным
// языкам оставалось налаживать взаимодействие с писаными на C++ классами, чтобы элементы управления можно было создавать из кода на
// OCaml/Haskell. В результате получились биндинги к Tck/Tk, GTK+, которые выглядят так же отвратительно как Swing в Java. Создавать
// GUI фреймворки только для функциональных языков являлось непрактичным.

// В нулевых-десятых годах появились способы проектирования GUI, которые не так явно завязаны на использовании ООП, они предлагают
// в том числе DSL
// для проектирования GUI и подерживают аппаратно ускоренный рендеринг через OpenGL. Примерами могут быть WPF, JavaFX и
// https://qmlbook.github.io/[Qt/QML].  Лично
// я https://github.com/Kakadu/lablqml[занимался]
// созданием библиотеки для использования Qt/Qml для OCaml. По сути QML является языком разметки GUI с поддержкой реактивного программирования, и скриптов
// на Javascript, чтобы делать простые действия в GUI (например менять цвет чего-то там в зависимости от выбранного в ComboBox). Бизнес-логика,
// от которой требуется надежность и производительность (чатайте, типобезопасность и скорость), по задумке Qtшников должна писться на С++ и легко
// интегрироваться с Qt/Qml.

// Поделку про OCaml и Qt/QML я сделал, но она не была оценена по достоинству у сообщества камлистов, я полагаю потому, что статически типизированные
// программисты априори с подозрением смотрят на плохотипизированный скрипт внутри Qt/QML.

// Также, говоря про GUI, нельзя не упомянуть веб и браузеры. Javascript захватил мир веба по историческому недоразумению; народ плачет, плюется,
// но продолжает есть кактус, потому что поделки в стиле TypeScript с gradual typing на борту как-то не взлетают. Но программы на Javascript как-то
// делаются и кое-как работают. Сейчас движки для создания приложений на основе Javascript и движка HTML страниц (читайте, Electron) заползают и
// на десктоп, поэтому мы радостно наблюдаем как Discord, банальный групповой чатик, зависает с пожиранием гигабайта оперативы.

// Пару лет назад появился ещё один способ для типобезопасного программирования для web, а именно, https://reasonml.github.io/[ReasonML],
// который является

// * языком OCaml, который прозрачно компилируется в Javascript
// * языком OCaml с "испорченным" синтаксисом: фигурные скобочки возле каждого объявления функции, как в Javascript;
// некаррированный синтаксис для вызова функций (с кучей ненужных скобочек и запятых), как в Javascript; объекты с синтаксисом как
// Javascript; изкоробочной поддержкой библотеки дизайна компонент интерфейсов React (от Facebook). Короче, всё чтобы хомячки из Javascript приняли новый язык. и они походу его действительно принимают.

// Теперь стоит сказать про новоиспеченный проект https://github.com/revery-ui/revery[Revery], где народ на ReasonML делает новый
// (ещё один новый с нуля, Карл!) фреймворк
// для клепания GUI, с блекджеком, OpenGL и реактивным программированием. Мотивацией служит отказ от Electron для создания шустрого
// легковесного кроссплатформенного тулкита. Это всё конечно логично, но давайте лучше

// * возьмем синтаксис ReasonML;
// * HTML+ReactJs синтаксис будем транслировать в компоненты Qt/Qml;
// * OCaml/ReasonML логику будем транслировать в Javascript (ReasonML уже умеет это делать);
// * автоматически получить возможность линковаться с большим количество проектов, которые уже сделаны в инфраструктуре Qt;
// * PROFIT.

// Сейчас Revery на уровне синтаксического дерева транслирует синтаксис HTML в отрисовку GUI. Хочется поставить эксперимент, чтобы
// HTML/ReactJs компоненты транслировались в Qt/Qml, всё линковалось и запускалось.

// Первый milestone. Все HTML-like конструкции `<view бла-бла> бла-бла</view>` должны транслироваться в отрисовку Qt/QML окошка с "Hello world". Функция
// `UI.start` должно просто показывать это новое окошко.
