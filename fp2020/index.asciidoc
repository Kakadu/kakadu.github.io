:source-highlighter: pygments
:pygments-style: monokai
:local-css-style: pastie

Функциональное Программирование (матмех, осень 2020)
====================================================
:Author: Dmitrii Kosarev a.k.a. Kakadu
:email:  Dmitrii.Kosarev@pm.me


Пока просто несортированная свалка ссылок.


Домашка будет сдаваться merge request'ами https://gitlab.com/Kakadu/fp2020hw[сюда].
Слайды будут https://gitlab.com/Kakadu/fp2020hw[тут].

https://marketplace.visualstudio.com/items?itemName=ocamllabs.ocaml-platform[Плагин для VS Code].


Свалка ссылок
-------------

https://vimeo.com/153042584[Yaron Minsky - Why OCaml]. Хорошо для общего развития: какие языки бывают, что от хорошего языка программирования требуется, и т.д.

http://queue.acm.org/detail.cfm?id=2038036[OCaml for the Masses] Большинстов аргументов переносимо и на Haskell

// https://www.youtube.com/watch?v=zFPEuI8i9Ds[Functional Programming: The Enterprise Edition] Где ФП стреляет в продакшене на примере Scala. Также о том, как пиарить ФП и почему оно медленно взлетает.

// https://www.youtube.com/watch?v=uqKxB3eRKlY[Мартин Одерски про Scala 3]



Проекты/(полу)курсовые
----------------------

link:projects.html[Тут] есть список проектов которые можно попытаться сделать как курсовую/миникурсовую/бакалаврскую. Как задача на 5 автоматом они выглядят чересчур сложными (а может и нет).

А ещё вы можете попробовать найти что-нибудь интересное у других людей из нашей лаборатории по понедельникам.


// [[questions]]
// Теоретические вопросы к экзамену в январе 2020 года
// ---------------------------------------------------
// За мямленье в ответ на вопрос с ☦ будет особенно больно.

// . ☦ Алгебраические типы и сопоставление с образцом. Что как называется, что писать можно, а что нельзя.
// . Классы типов. Мотивация.
// . ☦ Алгебра типов. Простейшие типы из которых можно много чего построить. Операции над типами. Получение зипперов по типу (конкретные типы есть в слайдах).
// . ☦ Эквивалентность, равенство и изоморфизм. И для типов тоже. Как из простейших типов построить что-то изоморфное данному алгебраическому типу?
// . Типы данных. Левоориентированные кучи. Основные свойства/инварианты. Сложность операций. Реализация.
// . Типы данных. Биномиальные кучи. Внутреннее устройство. Сравнение c левоориентированными.
// . Типы данных. ☦ Красно-черные деревья. Балансировка для чисто функциональный реализации. (Удаление не надо)
// . ☦ Лямбда-исчисление. Подстановки. Редукция. ☦ Capture avoiding substitution.
// +
// Также требуется умение демонстрировать на бумажке/доске, что студент может провести редукцию в той или иной стратегии.
// . Стратегии вычисления лямбда-термов: applicative order, ☦ call-by-name, ☦ call-by-value, normal order.
//   Когда одно лучше/хуже другого?
// . Безымянные представления: индексы де Брёйна и SKI. Редукция в SKI
// . ☦ Лямбда исчисление как Тьюринг полный язык программирования. Числа и арифметика. ☦ Рекурсия.
// . ☦ Функторы. Законы функторов. Примеры стандартных функторов из Haskell и примеры из домашнего задания.
// . ☦ Аппликативные функторы. Законы аппликативов. Примеры из Haskell и домашнего задания.
// . ☦ Монады. ☦ Законы монад. ☦ Выражение функторов и аппликативов, если монада уже описана.
//   ☦ Стандартные монады: Reader, Writer, ☦ State, ☦ List, ☦ Maybe.
// +
// Где в домашнем задании их уместно применить?
// . ☦ Понятие чистой функции. Чистые и нечистые функции в Haskell. Монада IO.
// . Continuation monad и continuation passing style. Пример про `callCC`.
// +
// Также требует от студента показать умение переписывать код из домашки в continuation passing style.
// . ☦ Do-нотация. Преобразование монадического кода из do-нотации и обратно.
// . ☦ Парсер-комбинаторы и их связь с аппликативами и монадами.
// +
// Требуется умение писать простые парсеры прямо в REPL, например:
// +
// .. Парсер языка `aⁿbⁿcⁿ` --  язык из букв `a,b,c`, где они всегда идут подряд и встречаются одинаковое количество раз.
// . Преобразования кода с list comprehension в do-нотацию и обратно.
// . ☦ Стандартные функции над ленивыми списками.
// +
// Будьте готовы написать простую функцию и запустить прямо в REPL. Например:
// +
// .. Решето Эратосфена
// .. Функция `concat :: [[a]] -> [a]` такая, что если `∃ m<∞ ∃n<∞ ∃x: x = ((xs !! m) !! n)` то
// `∃ i<∞ (Just x = elemIndex i (concat xs))`.
// . Free monad. Пример. Сравнение монады для списка и результата специализации Free monad (вопрос из слайдов).
// . Фантомные типы. Мотивация. Пример.
// . GADT. Мотивация. Как получить обычный алгебраический тип из GADT, пользуясь  только одиним GADT `Eq a`?
// . ФП vs. Интуиционистская логика. Как по типу получить терм, его населяющий?
// // Возможно это билет стоит не рассказывать на след. год.
// . Трансформеры. Мотивация. Использование в домашнем задании (если есть).
// . Полиморфные типы. Вывод типов в системе типов Hindley-Milner'a. Унификация. Типизация Y-комбинатора.
// +
// Следует ожидать допы про вывод типов для конкретных лямбда-выражений.


// Следует также ожидать ожидать вопросы на адекватность/неадекватность:

// . Какой предмет сдаете? Как зовут лектора?
// . Что такое функциональное программирование?
// . Какую домашку делали и что было самое сложное?
// . Как читается вон то страшное слово из 3го с конца билета?
// . Как звали американского математика Карри?
// . Как в этом коде стоят скобочки?
// . А что это за код написан в домашке и Вы ли её делали?
// . и т.п.

// P.S. Не забудьте про степик.


// Вопрос: data State s a = S (s -> (a,s)) От какого слова происходит сокращение s
// Что такое тип
// Почему в парсере лучше писать `do _ <- adsf` а не просто  `do asdf`
// Не забывать спрашивать про CPS
