\documentclass[aspectratio=169
  , xcolor={svgnames}
  , hyperref={ colorlinks,citecolor=DeepPink4
             , linkcolor=DarkRed,urlcolor=DarkBlue}
  , russian
  ]{beamer}
\usetheme{CambridgeUS}
\beamertemplatenavigationsymbolsempty % remove navigation bar

\usefonttheme{professionalfonts}
\input{heading.tex}
\usepackage{tabulary}
\usepackage{verbatim}
% \usepackage{tabularx}  % for 'tabularx' environment
% \usepackage{ragged2e} % for \Centering macro
% \newcolumntype{C}{>{\Centering\arraybackslash}X}m
% sudo aptget install ttf-mscorefonts-installer
\defaultfontfeatures{Ligatures={TeX}} 
\setmainfont{Times New Roman}
\setsansfont{CMU Sans Serif}

\setmonofont[Scale=1.0,
    BoldFont=lmmonolt10-bold.otf,
    ItalicFont=lmmono10-italic.otf,
    BoldItalicFont=lmmonoproplt10-boldoblique.otf
]{lmmono9-regular.otf}

\newcommand{\term}[2]{\textit{#1} (#2)}

\usepackage[cache=true]{minted}
\usepackage{amsthm}

\newtheorem{remark}{\textbf{Замечание}}[section]
\newtheorem{hint}{\textbf{Указание разработчикам}}[section]

\newtheoremstyle{exerciseStyle1}
{}                % Space above
{}                % Space below
{}        % Theorem body font % (default is "\upshape")
{}                % Indent amount
{\bfseries}       % Theorem head font % (default is \mdseries)
{.}               % Punctuation after theorem head % default: no punctuation
{ }               % Space after theorem head
{}                % Theorem head spec
\theoremstyle{exerciseStyle1}
\newtheorem{exercise}{\textbf{Упражнение}}[section]


\deftranslation[to=russian]{Theorem}{Теорема}
\deftranslation[to=russian]{theorem}{теорема}

\usepackage{tikz}
\usetikzlibrary{trees}

%%%%%%%%%%%%%%%%%%
\makeatletter
\newenvironment{tabminted}{%
  \let\FV@ListVSpace\relax  
  \minted
}{%
  \endminted
  \unskip   
  \aftergroup\@tabmintedend
}
\newcommand*{\tabminted@finalstrut}[1]{%
  \ifdim\prevdepth>0pt
    \ifdim\dp#1>\prevdepth
      \vskip\dimexpr(\dp#1)-\prevdepth\relax
    \fi
  \else
    \vskip\dimexpr(\dp#1)\relax
  \fi
}
\newcommand*{\@tabmintedend}{%
  \let\@finalstrut\tabminted@finalstrut
}
\makeatother
%%%%%%%%%%%%%%%%%%%%%5
\title[]{Чисто функциональные структуры данных}
\author{Косарев Дмитрий }

\institute{матмех СПбГУ}

\date{\today}
 
\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Оглавление}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\newcommand{\verbatimfont}[1]{\def\verbatim@font{#1}}

\usepackage{verbatimbox}

\begin{document}
\maketitle

% For every picture that defines or uses external nodes, you'll have to
% apply the 'remember picture' style. To avoid some typing, we'll apply
% the style to all pictures.
\tikzstyle{every picture}+=[remember picture] 

% By default all math in TikZ nodes are set in inline mode. Change this to
% displaystyle so that we don't get small fractions.
\everymath{\displaystyle}

% Uncomment these lines for an automatically generated outline.
\begin{frame}{Оглавление}
  \tableofcontents
\end{frame}

\section{Индуктивные типы данных}


\begin{frame}[fragile]{Сигнатура Stack. Реализация через встроенные списки}
\begin{minipage}{.48\textwidth}
\inputminted{haskell}{code/Stack.hs}
\end{minipage}
\begin{minipage}{.48\textwidth}
\inputminted{haskell}{code/ListStack.hs}
\end{minipage}
\end{frame}

\begin{frame}[fragile]{Сигнатура Stack. Реализация через новый тип данных}
\begin{minipage}{.48\textwidth}
  \inputminted{haskell}{code/Stack.hs}
\end{minipage}
\begin{minipage}{.48\textwidth}
  \inputminted{haskell}{code/CustomStack.hs}
\end{minipage}
\end{frame}

\begin{frame}[fragile]{Конкатенация списков}
\begin{minted}{haskell}
(++) :: Stack l => l a -> l a -> l a
\end{minted}
В императивной среде легко сделать за O(1), если хранить указатель на конец.
\end{frame}

\begin{frame}[fragile]{Конкатенация в императивной среде}
\begin{figure}[h]
%	\centering
	\input{figures/fig.2.4.before.tex}\par
	(до)\par
%	\vspace{0.5cm}
	\input{figures/fig.2.4.after.tex}\par
	(после)\par
%	\vspace{0.5cm}
	\caption{Выполнение xs concat ys в императивной среде. Эта операция уничтожает списки-аргументы xs и ys (их использовать больше нельзя)}
	\label{fig:2.4}
\end{figure}
\end{frame}


\begin{frame}[fragile]{Конкатенация в функциональной среде}
В функциональной среде мы не можем деструктивно модифицировать. Поэтому
\begin{itemize}
\item добавляем последний элемент первого списка ко второму
\item добавляем \emph{пред}последний элемент первого списка к резульату
\item и т.д.
\end{itemize}

\inputminted[firstline=43,lastline=47] {haskell}{code/Stacks.hs}
\end{frame}

\begin{frame}[fragile]{}
\inputminted[firstline=43,lastline=47] {haskell}{code/Stacks.hs}
Если нам доступно внутреннее представление, то можно написать более короткий идиоматичный код
\inputminted[firstline=50,lastline=51] {haskell}{code/Stacks.hs}
\end{frame}

\begin{frame}[fragile]{Конкатенация}
\begin{figure}[h]
	\centering
	\input{figures/fig.2.5.before.tex}\par
	(до)\par
	\vspace{0.5cm}
	\input{figures/fig.2.5.after.tex}\par
	(после)\par
	\vspace{0.5cm}
	\caption{Выполнение \texttt{zs = xs ++ ys} в функциональной среде. Заметим, что списки-аргументы \texttt{xs} и \texttt{ys} не затронуты операцией.
	}
	\label{fig:2.5}
\end{figure}
Несмотря на большой объем копирования, заметим, что второй список копировать не пришлось
\end{frame}

\begin{frame}[fragile]{Update}
\inputminted[firstline=61,lastline=64] {haskell}{code/Stacks.hs}
%Если нам доступно внутреннее представление, то можно написать более короткий идиоматичный код
Здесь мы не копируем весь список-аргумент.\\

Копировать приходится
только сам узел, подлежащий модификации (узел $i$) и узлы,
содержащие прямые или косвенные указатели на $i$. \\

Другими словами,
чтобы изменить один узел, мы копируем все узлы на пути от корня
к изменяемому. Все узлы, не находящиеся на этом пути, используются как
исходной, так и обновленной версиями. 
%На Рис.
%~\ref{fig:2.6} 
%показан
%результат изменения третьего узла в пятиэлементном списке: первые
%три узла копируются, а последние два используются совместно.
\end{frame}

\begin{frame}[fragile]{}
\begin{figure}[h]
	\centering
	\input{figures/fig.2.6.before.tex}\par
	(до)\par
	\vspace{0.5cm}
	\input{figures/fig.2.6.after.tex}\par
	(после)\par
	\vspace{0.5cm}	
	\caption{Выполнение \texttt{ys = update(xs, 2, 7)}. Обратите
		внимание на совместное использование структуры списками \texttt{xs} и \texttt{ys}.}
	\label{fig:2.6}
\end{figure}
\end{frame}

\begin{frame}[fragile]
\begin{remark}
	Такой стиль программирования очень сильно упрощается при наличии
	автоматической сборки мусора. Очень важно освободить память от тех
	копий, которые больше не нужны, но многочисленные совместно используемые
	узлы делают ручную сборку мусора нетривиальной задачей.
\end{remark}
\begin{exercise}\label{ex:2.1}
  Напишите функцию \texttt{suffixes} типа \mintinline{haskell}{[a] -> [a]}, которая принимает как
  аргумент список \texttt{xs} и возвращает список всех его
  суффиксов в убывающем порядке длины. Например,
  \begin{minted}{haskell}
  suffixes [1,2,3,4] = [[1,2,3,4],[2,3,4],[3,4],[4],[]]
  \end{minted}
  Покажите, что список суффиксов можно породить за время $O(n)$ и
  занять при этом $O(n)$ памяти.
\end{exercise}

\end{frame}

\section{Двоичные деревья поиска}

\begin{frame}{Двоичные деревья поиска}
Если узел структуры содержит более одного указателя, оказываются
возможны более сложные сценарии совместного использования памяти. Хорошим примером
совместного использования такого вида служат \emph{двоичные деревья поиска}.

\inputminted[firstline=10, lastline=10] {haskell}{code/SearchTree.hs}

Двоичные деревья поиска~--- это двоичные деревья, в которых элементы
хранятся во внутренних узлах в \term{симметричном}{symmetric}
порядке, то есть, элемент в каждом узле больше любого элемента в
левом поддереве этого узла и меньше любого элемента в правом
поддереве.
\end{frame}

\begin{frame}[fragile]{}
\begin{figure}[h]
  \centering
  \inputminted[firstline=12, lastline=16] {haskell}{code/SearchTree.hs}
  \caption{Сигнатура для множеств.}
\label{fig:2.7}
\end{figure}

На Рис.~\ref{fig:2.7} показана минимальная сигнатура для множеств. Она
содержит значение <<пустое множество>>, а также функции добавления
нового элемента и проверки на членство.  В более практической
реализации, вероятно, будут присутствовать и многие другие функции,
например, для удаления элемента или перечисления всех элементов.
\end{frame}

\begin{frame}[fragile]{Функция member}
  \inputminted[firstline=22, lastline=25] {haskell}{code/SearchTree.hs}

Функция \texttt{member} ищет в дереве, сравнивая запрошенный
элемент с находящимся в корне дерева. Если запрошенный элемент меньше
корневого, мы рекурсивно ищем в левом поддереве.

 Если он больше,
рекурсивно ищем в правом поддереве. 

Наконец, в оставшемся случае
запрошенный элемент равен корневому, и мы возвращаем значение
<<истина>>. \\

Если мы когда-либо натыкаемся на пустое дерево, значит,
запрашиваемый элемент не является членом множества, и мы возвращаем
значение <<ложь>>. 
\end{frame}

\begin{frame}[fragile]{Функция insert}
\inputminted[firstline=27, lastline=30] {haskell}{code/SearchTree.hs}

Функция \lstinline{insert} проводит поиск в дереве по той же стратегии,
что и \lstinline{member}, но только по пути она копирует каждый
элемент.

Когда, наконец, оказывается достигнут пустой узел, он
заменяется на узел, содержащий новый элемент.
 
\end{frame}

\begin{frame}[fragile]{}
\begin{minipage}{.48\textwidth}
		\input{figures/fig.2.8.before.tex}\par
\end{minipage}
\begin{minipage}{.48\textwidth}
	\input{figures/fig.2.8.after.tex}
\end{minipage}
Выполнение \texttt{ys = insert("e", xs)}. 
%Как и прежде,
%обратите внимание на совместное использвание структуры деревьями \texttt{xs} и \texttt{ys}.

%Каждый скопированный узел использует одно из поддеревьев 
%совместно с исходным деревом; речь о том поддереве,
%которое не оказалось на пути поиска. 
Для большинства деревьев путь
поиска содержит лишь небольшую долю узлов в дереве. Громадное
большинство узлов находятся в совместно используемых поддеревьях.
\end{frame}

\begin{frame}
\begin{exercise}\textbf{Андерсон \cite{Andersson1991}}\label{ex:2.2}
  В худшем случае \lstinline{member} производит $2d$ сравнений, где
  $d$~--- глубина дерева. Перепишите ее так, чтобы она делала не более
  $d+1$ сравнений, сохраняя элемент, который \emph{может} оказаться
  равным запрашиваемому (например, последний элемент, для которого
  операция $<$ вернула значение <<истина>> или $\le$~--- <<ложь>>, и
  производя проверку на равенство только по достижении дна дерева.
\end{exercise}

\begin{exercise}\label{ex:2.3}
  Вставка уже существующего элемента в двоичное дерево поиска копирует
  весь путь поиска, хотя скопированные узлы неотличимы от
  исходных. Перепишите \lstinline{insert} так, чтобы она избегала
  копирования с помощью исключений. Установите только один обработчик
  исключений для всей операции поиска, а не по обработчику на итерацию.
\end{exercise}

\begin{exercise}\label{ex:2.4}
  Совместите улучшения из предыдущих двух упражнений, и получите
  версию \lstinline{insert}, которая не делает ненужного копирования и
  использует не более $d+1$ сравнений.
\end{exercise}
\end{frame}

\begin{frame}
\begin{exercise}\label{ex:2.5}
  Совместное использование может быть полезно и внутри одного объекта, не
  обязательно между двумя различными.  Например, если два поддерева
  одного дерева идентичны, их можно представить одним и тем же
  деревом.
  \begin{enumerate}
    \item Используя эту идею, напишите функцию \lstinline{complete} типа
    \mintinline{haskell}{Elem -> Int -> Tree}, такую, что
    \mintinline{haskell}{complete(x,d)} создает полное двоичное дерево глубины
    \lstinline{d}, где в каждом узле содержится \lstinline{x}.
    (Разумеется, такая функция бессмысленна для абстракции множества,
    но она может оказаться полезной для какой-либо другой абстракции,
    например, мультимножества.) Функция должна работать за время $O(d)$.
    \item Расширьте свою функцию, чтобы она строила сбалансированные
    деревья произвольного размера. Эти деревья не всегда будут полны,
    но они должны быть как можно более сбалансированными: для любого
    узла размеры поддеревьев должны различаться не более чем на
    единицу. Функция должна работать за время $O(\log n)$. (Подсказка:
    воспользуйтесь вспомогательной функцией \lstinline{create2},
    которая, получая размер $m$, создает пару деревьев~--- одно размера
    $m$, а другое размера $m+1$)
  \end{enumerate}
\end{exercise}
\end{frame}

\begin{frame}
\begin{exercise}\label{ex:2.6}
  Измените функтор \texttt{UnbalancedSet} так, чтобы он служил
  реализацией не множеств, а \term{конечных отображений}{finite maps}. На
  Рис.~\ref{fig:2.10} приведена минимальная сигнатура для конечных
  отображений. (Заметим, что исключение \texttt{NotFound} не
  является встроенным в Стандартный ML~--- Вам придется его определить
  самостоятельно. Это исключение можно было бы сделать частью
  сигнатуры \texttt{FiniteMap},  чтобы каждая реализация
  определяла собственное исключение \texttt{NotFound}, но удобнее,
  если все конечные отображения будут использовать одно и то же
  исключение.)
\end{exercise}

\end{frame}

\section{Левоориентированные кучи}

\begin{frame}[fragile]{}
\inputminted[firstline=3, lastline=11] {haskell}{code/Heap.hs}
\end{frame}
% 
% \begin{frame}[allowframebreaks]
%   \frametitle<presentation>{Ссылки}
%   \begin{thebibliography}{10}
%   \bibitem{paper}
%     \href{http://conal.net/papers/compiling-to-categories/compiling-to-categories.pdf}{paper}
%     \newblock {\em Conal Elliot }    
%   \bibitem{conal}
%     Slides
%     \newblock {\em Conal Elliot }
%     \newblock \href{http://conal.net/talks/compiling-to-categories.pdf}{ссылка}
%   \bibitem{video}    
%     \href{http://podcasts.ox.ac.uk/compiling-categories}{ICFP 2017 video}
%     \newblock {\em Conal Elliot }
%   \bibitem{}
%     \href{https://github.com/conal/concat}{Project repo}
%   \end{thebibliography}
% \end{frame}

\end{document}
