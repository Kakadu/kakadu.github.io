\section{Введение}

Фредерк Брукс (Frederic Brooks) в своей известной книге по инженерии
программ  ``Мифический человеко-месяц'' (``The Mythical Man-Month'')~\cite{MMM} охарактеризовал сущность программирования следующим образом:

\blockquote{``Программист, подобно поэту, работает почти непосредственно с чистой мыслью. Он строит свои замки в воздухе и из воздуха, творя силой воображения. Трудно найти другой материал, используемый в творчестве, который столь же гибок, прост для шлифовки или переработки и доступен для воплощения грандиозных замыслов. (Как мы позднее увидим, такая податливость таит свои проблемы.)''}

Действительно, нематериальность программ и гибкость их представления  призывает к структурированию; отсутствие подходящей структуры легко может привести к катастрофическим последствиям
(как это случалось с некоторыми промышленными проектами в прошлом). Одним из наиболее распространенных способов структурировать программы является использование \emph{типов данных}. Они позволяют описывать свойства данных; что можно с ними сделать, а что нельзя; а также в некоторой степени описывают семантику структур данных. Если информация о типах данных присутствует во время работы программы, то становится возможным реализовать мета-преобразования путём анализа типов (\emph{интроспекция}) или путём создания новых типов данных на лету (\emph{рефлексия}).

Однако, в статически типизированных языках, как правило, типы полностью стираются 
после фазы компиляции и отсутствуют во время исполнения. Статическая типизация обладает серьёзным преимуществом по сравнению с динамической, потому что программам
не нужно инспектировать типы во время выполнения и больше количество плохих поведений программ -- ошибок типизации -- не случается. С другой стороны, некоторые преобразования, которые в динамических языках могли быть реализованы ``раз и навсегда'' не проходят проверку типов и должны быть перереализованы для каждого конкретного типа по отдельности. Одни из подходов к преодолению этого недостатка является разработка более выразительной системы типов, где большее количество функций может быть протипизировано. Примером этому подходу будет поддержка перегрузки (\emph{ad hoc} полиморфизма) в языке Haskell в виде классов 
типов~\cite{TypeClasses} и семейств типов~\cite{TypeFamilies}. Однако, по причине требования тотальности к алгоритму проверки типов и фундаментальной неразрешимости проблемы проверки типов, всегда будут существовать ``хорошие'' программы, которые
не могут быть протипизированы. Другим подходом является \emph{обобщенное программирование}~\cite{DGP} (\emph{datatype-generic programming}), целью которого является разработка методов для реализации практически важных семейств функций
индексированных типами, использую имеющиеся возможности языка. Например, типы могут быть закодированы на внутреннем языке~\cite{Hinze,InstantGenerics,GenericOCaml}, либо часть информации о типах может быть сделана доступной во время исполнения, или 
обобщенные функции для конкретного типа данных могут быть сгенерированы во время
компиляции автоматически~\cite{Yallop,PPXLib}. Два похода, описанные нами, дополняют друг друга: чем более мощной является система типов, тем больше возможностей для обобщенного программирования язык может предложить. Например, параметрический полиморфизм позволяет естественно выразить функцию для вычисления длины списка произвольных элементов и т.п.

Мы представляем библиотеку для обобщенного программирования \textsc{GT}\footnote{\url{https://github.com/kakadu/GT/tree/ppx}} (\emph{Generic Transformers}), которая находится в активной разработке с 2014 года. Одним из важных наблюдений, которые спровоцировали разработку, является то, что многие обобщенные функции можно рассматривать как модификации некоторых других обобщенных функций. Наш подход, являясь генеративным (мы создаем функции на основе объявлений типов), также позволяет конечным пользователям легко получать новые преобразования видоизменяя некоторые части уже имеющихся. Это достигается путём кодирования конструкторов один к одному в методы классов, что несколько напоминает подход, называемый алгебрами объектов~\cite{ObjectAlgebras}.

Отличительным особенностями нашего подхода являются:

\begin{itemize}
\item каждое преобразование выражается с помощью \emph{функции преобразования} и \emph{объекта преобразования}, которые содержат в себе ``интересные'' части преобразования;
\item функция преобразования уникально для данного типа и всех объектов преобразования, которые являются образцами уникального класса;
\item и функция преобразования, и класс генерируются из объявления типа; мы поддерживаем регулярные алгебраические типы данных, структуры, полиморфные вариантные типы и базовые заранее описанные типы;
\item мы предоставляем несколько плагинов, для того, чтобы генерировать практически полезные преобразования в виде конкретных классов;
\item система плагинов расширяема -- программист может реализовать свои собственные плагины.
\end{itemize}

Представленная в данной работе библиотека является логическим продолжением более ранней работы~\cite{SYBOCaml} на тему реализации подхода ``Scrap Your Boilerplate''~\cite{SYB,SYB1,SYB2}. Однако, опыт показал, что выразительность и расширяемость SYB недостаточна, к тому же преобразования, которые зависят только от типа, не очень удобно использовать. Изначальной идеей данной работы было совмещение комбинаторов и объектно-ориентированного подхода: первый позволит делать реализовать параметризацию удобным образом, а второй предоставит расширяемость за счет позднего связывания (late binding). Идея в виде конкретного шаблона проектирования была успешно апробирована~\cite{SCICO}, а затем реализована в виде библиотеки и синтаксического расширения~\cite{TransformationObjects}. Последующий опыт, связанный с разработкой библиотеки~\cite{OCanren}, снова указал на некоторые недостатки в реализации. В данной работе представляется почти полностью переписанная реализация, где найденные недостатки были исправлены.

Оставшаяся часть работы организована следующим образом. В следующем разделе \ref{sec:expo} мы неформально опишем наш подход с помощью примеров. Затем \ref{sec:implementation} опишем реализацию в деталях, подчеркнув аспекты, которые считаем важными или интересными. Далее представим несколько примеров, реализованных \ref{sec:examples} с помощью нашей библиотеки. В разделе \ref{sec:relatedworks} обсудим аналогичные подходы и библиотеки и сравнимся с ними. В последнем разделе \ref{sec:futurework} укажем направления для дальнейшего развития.


