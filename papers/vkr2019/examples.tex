!\section{Примеры}
\label{sec:examples}

В этом разделе мы представим несколько примеров, реализованных с помощью нашей библиотеки. В этих примерах используются синтаксические расширения \cd{camlp5}, хотя всё может быть переписано с использованием \cd{ppxlib}. Как было сказано выше данная работа является прямым наследником~\cite{TransformationObjects} и все примеры из той статьи работают в этой версии. Здесь мы покажем несколько новых.

\subsection{Типизированные логические значения}

Первый пример появился во врем работы на строго типизированным логическим предметно-ориентированным языком для \textsc{OCaml}~\cite{OCanren}. 
Одной из самых важных конструкций была унификация термов со свободными логическими переменными, работать с такими структурами данных сложно, а допустить ошибку --- легко. Типичным сценарием взаимодействия  между логическими и нелогическими частями программ является 
создание так называемых \emph{целей вычислений} (англ. goal), содержащих структуры данных со свободными логическими переменными в них.
Решением логической цели, является подстановка переменных, правые части которой в идеальном случае не содержит свободных переменных. Чтобы
сконструировать цель вычислений систематически вводить логические переменные в некоторую типизированную структуру данных,  а для восстановления ответа -- систематически извлекать из логических представлений ответы в нелогическом представлении.

Упрощённый тип для логических переменных может быть описан следующим образом:

\begin{lstlisting}
@type 'a logic =
| V     of int
| Value of 'a       with show, gmap
\end{lstlisting}
Логическое значение может быть либо свободной логической переменной (``\lstinline{V}'') или каким-то другим значением (``\lstinline{Value}''), которое не является свободной переменной, но потенциально может содержать свободные переменные внутри себя. Чтобы преобразовывать в и из логических значений, можно воспользоваться следующими функциями:

\begin{lstlisting}
let lift x = Value x

let reify  = function
| V     _ -> invalid_arg "Free variable"
| Value x -> x
\end{lstlisting}

Функция ``\lstinline{reify}'' бросает исключение для свободных переменных, так как в присутствии вхождений свободных переменных
логическое значение нельзя рассматривать как обыкновенную (нелогическую) структуру данных.

Когда мы работает с логическими структурами данных, на необходима возможность вставлять логические переменные в произвольные позиции.
Это означает, что мы должны переключиться на использование другого типа, который принадлежит домену логических типов. Например,
для арифметических выражений, которые мы использовали как пример, нам понадобится конструировать значения вида

\begin{lstlisting}
Value (
  Binop (
    V 1, 
    Value (Const (V 2)),
    V 3
  )
)
\end{lstlisting}
которые будут иметь тип ``\lstinline{lexpr}'', объявленный как

\begin{lstlisting}
type expr' = Var of string logic | Const of int logic 
           | Binop of lexpr * lexpr
and  lexpr = expr' logic
\end{lstlisting}

Нам также нужно реализовать две функции преобразования. Все эти определения представляют собой типичный пример однотипного (boilerplate) кода.

С измользование нашего подхода решение почти полностью декларативно\footnote{При условии включения ключа компиляции \cd{-rectypes}}.
Во-первых, мы абстрагируемся от интересующего нас типа, заменяя все его вхождения типовой переменной с не встречающимся ранее именем:

\begin{lstlisting}
@type ('string, 'int, 'expr) a_expr =
| Var   of 'string
| Const of 'int
| Binop of 'string * 'expr * 'expr with show, gmap
\end{lstlisting}

Здесь мы абстрагировали тип от всего конкретного, но мы могли обойтись абстрагированием только от самого себя. Заметьте, что 
мы воспользовались двумя видами обобщенных преобразований~--- ``\lstinline{show}'' и ``\lstinline{gmap}''. 
Первое будет полезно для отладочных целей, а второе является необходимым для нашего решения.

Теперь мы можем объявить логические и нелогические составляющие как специализации исходного типа:

\begin{lstlisting}
@type expr  = (string, int, expr) a_expr 
  with show, gmap
@type lexpr = (string logic, int logic, lexpr) a_expr logic 
  with show, gmap
\end{lstlisting}

Обратите внимание, что ``новый'' тип ``\lstinline{expr}'' эквивалентен старому, следовательно, такое переписывание типов не нарушает существующий код.

Наконец, определения функций преобразования воспользуются преобразованием, полученным с помощью плагина ``\lstinline{gmap}'', предоставляемого библиотекой:

\begin{lstlisting}
let rec to_logic   expr = gmap(a_expr) lift  lift  to_logic  expr
let rec from_logic expr = gmap(a_expr) reify reify from_logic @@ 
                           reify expr
\end{lstlisting}

Как вы видите, поддержка типовых операторов существенна для этого примера. В предыдущей реализации~\cite{TransformationObjects} типовые операторы не были поддержаны и их было не так просто добавить.

\subsection{Преобразование в безымянное представление}

Полиморфные вариантные типы позволяют описывать структуры данных композиционально, статически типизировано и в разных модулях 
компоновки~\cite{PolyVarReuse}.
Объявлять преобразования таких структур данных отдельно является естественной идеей. Проблема конструирования преобразований 
раздельно объявленных строго типизированных компонент известна как ``проблема выражений'' (``The Expression Problem''~\cite{ExpressionProblem}), которая часто используется как ``лакмусовый тест'' для оценивания подходов к обобщенному программированию~\cite{ObjectAlgebras,ALaCarte}. 
В этом разделе мы покажем решение проблемы выражений в рамках нашего подхода. В качестве конкретной задачи мы реализуем преобразование лямбда-термов в безымянное представление.

Во-первых, опишем часть языка термов без связывающих конструкций:

\begin{lstlisting}
@type ('name, 'lam) lam = [
| `App of 'lam * 'lam
| `Var of 'name
] with show
\end{lstlisting}

Отделение этого типа выглядит логичной идей, так как потенциально в языке может появить множество конструкций, связывающих переменные 
($\lambda$-абстракции, \lstinline=let=-определения и т.д.) и комбинируя их с не связывающей частью и с ними самими можно получать множество языков с согласованным поведением.

Тип ``\lstinline{lam}'' полиморфен. Первый параметр используется для представления имен или индексов де Брауна, второй необходим для открытой рекурсии (здесь мы следуем уже исследованному подходу по описанию расширяемых структур данных с помощью полиморфных 
вариантов~\cite{PolyVarReuse}).

Как должно выглядеть преобразование в безымянное представление для такого типа? А именно, как должен выглядеть класс преобразования? Это показано ниже:

\begin{lstlisting}
class ['lam, 'nameless] lam_to_nameless
  (flam : string list -> 'lam -> 'nameless) =
object
  inherit [string list, string, int,
          string list, 'lam, 'nameless,
          string list, 'lam, 'nameless] $\inbr{lam}$
  method $\inbr{App}$ env _ l r = `App (flam env l, flam env r)
  method $\inbr{Var}$ env _ x   = `Var (index env x)
end
\end{lstlisting}

Здесь мы используем список строк для хранения подстановки переменных и  передаем его как наследуемый атрибут. Затем мы воспользуемся функцией 
``\lstinline{index}'' чтобы найти строку в подстановки, т.е.  эта функция преобразуем имея в индекс де Брауна. 
Интересной часть преобразования является типизация общего класса предка ``$\inbr{lam}$''. 
Первая тройка параметров описывает преобразование первого типового параметра. Как Вы видите, мы преобразуем строки в числа используя подстановку.
Здесь типовая переменная ``\lstinline{'lam}'', как мы знаем, приравняется открытой версии типа ``\lstinline{lam}''.
Наконец. результат преобразование типизируется с помощью типовой переменной ``\lstinline{'nameless}''. 
Так происходит именно так потому, что, как будет понятно позднее,  это будет действительно другой тип.
Так как второй типовый параметр обычно ссылается рекурсивно на себя, третья тройка типовых параметров совпадает со второй.

Давайте теперь добавим связывающую конструкцию -- $\lambda$-абстракцию:

\begin{lstlisting}
@type ('name, 'lam) abs = [ `Abs of 'name * 'lam ] with show
\end{lstlisting}

Те же самые рассуждения применимы и тут: мы пользуется открытой рекурсией и параметризируем представление относительно имени.
Класс для преобразования будет выглядеть похожим образом:

\begin{lstlisting}
class ['lam, 'nameless] abs_to_nameless
  (flam : string list -> 'lam -> 'nameless) =
object
  inherit [string list, string, int,
            string list, 'lam, 'nameless,
            string list, 'lam, 'nameless] $\inbr{abs}$
  method $\inbr{Abs}$ env name term = `Abs (flam (name :: env) term)
end
\end{lstlisting}

Заметьте, что метод ``$\inbr{Abs}$'' конструирует значения \emph{другого} типа, чем любая возможная параметризация типа ``\lstinline{abs}''. Действительно, безымянное представление типа не должно содержать никаких суррогатов имён.

Теперь мы можем объединить эти два типа, чтобы получить тип термов со связывающими конструкциями:

\begin{lstlisting}
@type ('name, 'lam) term = 
  [ ('name, 'lam) lam | ('name, 'lam) abs) ] with show
\end{lstlisting}

Мы можем предоставить два новых типа для именованного и безымянного представления\footnote{Нам понадобится использовать ключ компиляции
\cd{-rectypes}, чтобы эти определения типов скомпилировались .}:

\begin{lstlisting}
@type named    = (string, named) term with show
@type nameless = [ (int, nameless) lam | `Abs of nameless] with show
\end{lstlisting}

Наконец, мы может описать преобразование, которое превращает именованные термы в их безымянное представление:

\begin{lstlisting}
class to_nameless
  (fself : string list -> named -> nameless) =
object
  inherit [string list, named, nameless] $\inbr{named}$
  inherit [named, nameless] lam_to_nameless fself
  inherit [named, nameless] abs_to_nameless fself
end
\end{lstlisting}

Это преобразование получается путём наследования всех важных составляющих: общего класса для всех трансформаций типа ``\lstinline{named}'' 
и друз конкретных преобразований его составляющих. Функция трансформации может быть получена стандартным способом:

\begin{lstlisting}
let to_nameless term =
  transform(named) (fun fself -> new to_nameless fself) [] term
\end{lstlisting}

Только что мы построили реализацию, комбинируя реализации для его составляющих. Эти частичные решения могут быть раздельно скомпонованы, а вся система при этом остается строго типизированной.

\subsection{Пример пользовательского плагина}
\label{pluginExample}

Наконец, мы продемонстрируем использование системы плагинов на свежем примере реализации плагина. Для этой цели мы выбрали широко известное преобразование \emph{hash-consing}~\cite{HC}. Это преобразование превращает структуры данных в их максимально компактное представление в памяти, при котором структурно равные части представляются в памяти как один физический объект. Например, синтаксическое дерево выражения

\begin{lstlisting}
let t =
  Binop ("+",
    Binop ("-",
      Var "b",
      Binop ("*", Var "b", Var "a")),
    Binop ("*", Var "b", Var "a"))
\end{lstlisting}
может быть переписано  как

\begin{lstlisting}
let t =
  let b  = Var "b" in
  let ba = Binop ("*", b, Var "a") in
  Binop ("+", Binop ("-", b, ba), ba)  
\end{lstlisting}
где равные подвыражения представляются как равные поддеревья.
 
Наш плагин по типу  ``\lstinline|$\left\{\alpha_i\right\}$ t|'' предоставит функцию для 
hash-consing ``\lstinline{hc(t)}'' с сигнатурой 

\begin{lstlisting}
$\{$ H.t -> $\alpha_i$ -> H.t * $\alpha_i$ $\}$ -> H.t -> $\left\{\alpha_i\right\}$ t -> H.t * $\left\{\alpha_i\right\}$ t
\end{lstlisting}
где ``\lstinline{H.t}''~--- это гетерогенная хэш таблица для произвольных типов. Интерфейс у неё следующий:

\begin{lstlisting}
module H : sig
  type t
  val hc : t -> 'a -> t * 'a
end
\end{lstlisting}

Функция  ``\lstinline{H.hc}'' принимает хэш таблицу и некоторое значение и возвращает потенциально обновленную хэш таблицу и значение, которое структурно эквивалентно поданному на вход. Мы не будет описывать реализацию этого модуля, а приведем пример использования в конструкторе:

\begin{lstlisting}
method $\inbr{Binop}$ h _ op l r =
  let h, op = hc(string) h op in
  let h, l  = fself h l in
  let h, r  = fself h r in
  H.hc h (Binop (op, l, r))
\end{lstlisting}

Этот метод принимает как наследуемый атрибут хэш таблицу ``\lstinline{h}'', преобразуемое целиком, которое здесь не потребуется; три аргумента конструктора: ``\lstinline{op}'' типа \lstinline{string}, а также ``\lstinline{l}'' и ``\lstinline{r}'' типа \lstinline{expr}. 
Мы вначале обрабатываем аргументы, что создает нам новую хэш таблицу и три новых значения тех же типов. Затем мы применяем конструктор и запускаем функцию для hash-consing ещё раз.  Для обработки аргументов конструктора мы используем функции, предоставленные библиотекой:

для типа \lstinline{string} это ``\lstinline{hc(string)}''\footnote{В общем случае, на было бы необходимо реализовать функцию hash-consing для каждого примитивного типа. В нашем же случае мы можем воспользоваться функцией ``\lstinline{H.hc}''.}, а оба подвыражения мы обработаем с помощью ``\lstinline{fself}''.

Ещё надо разобраться с параметрами класса, наследоваться от которого мы будем в классе для преобразования типа ``\lstinline|$\{\alpha_i\}$ t|''. 
Очевидно, что все наследуемые атрибуты будут иметь тип  ``\lstinline{H.t}'', а синтезированные --- ``\lstinline{H.t * $a$}'' для каждого интересующего нас типа ``$a$''.
Это приводит нас к следующему объявлению класса трансформации:

\begin{lstlisting}
class [$\{\alpha_i\}$, $\epsilon$] $\inbr{hc_t}$ $\dots$ = object
  inherit [$\{$ H.t, $\alpha_i$, H.t * $\alpha_i$ $\}$, H.t, $\epsilon$, H.t * $\epsilon$] $\inbr{t}$
  $\dots$
end
\end{lstlisting}

Для простоты мы опустили спецификацию параметров-фукнций для класса, так как их сигнатуры могут быт легко восстановлены.

Теперь надо реализовать эту логику с помощью системы плагинов.

Код инфраструктуры для плагинов указан ниже:

\begin{lstlisting}
let trait_name = "hc"

module Make (AstHelpers : GTHELPERS_sig.S) = struct
  open AstHelpers
  module P = Plugin.Make (AstHelpers)
  class g tdecls = object (self : 'self)
    inherit P.with_inherited_attr tdecls 
    $\ldots$
  end
end

let _ = Expander.register_plugin trait_name 
          (module Make : Plugin_intf.Plugin)
\end{lstlisting}

Чтобы реализовать плагин, необходимо реализовать функтор, параметризованный дополнительным модулем, который напоминает модуль ''\texttt{Ast\_builder}'' из библиотеки 
\cd{ppxlib}, который используется для конструирования абстрактного инстаксического дерева  \textsc{OCaml}. Нам необходимо реализовывать функтор, потому что мы поддерживаем два вида синтаксических расшируений: для \cd{camlp5} и для \cd{ppxlib}. Главная сущностью в теле фукнцтора является класс ``\lstinline{g}'' (``генератор''), который мы для простоты будем наследовать от базового класса нашей бибилотеки.
В данном случае мы создаем модуль с базовой реализацией плагина в модуле 
``\lstinline{P}'' на основе ``\lstinline{AstHelpers}'' и затем наследуемся от класса 
``\lstinline{P.with_inherited_attr}'', что означает, что хотим получить плагин, где наследуемый атрибут содержательно используется (не является типом ``\lstinline|unit|'').
Этот класс принимает объявления типов как параметры.
В конце, мы региструиуем функтор как модуль первого класса, что делает его доступным для использования.

Сейчас мы покажем как выглядят методы класса-генератора. Во-первых, надо указать какие типы будут у наследуемыех и синтезированных атрибутов:

\begin{lstlisting}
method main_inh ~loc _tdecl = ht_typ ~loc

method main_syn ~loc ?in_class tdecl =
  Typ.tuple ~loc
    [ ht_typ ~loc
    ; Typ.use_tdecl tdecl
    ]

method inh_of_param tdecl _name =
  ht_typ ~loc:(loc_from_caml tdecl.ptype_loc)

method syn_of_param ~loc s =
  Typ.tuple ~loc
    [ ht_typ ~loc
    ; Typ.var ~loc s
    ]
\end{lstlisting}

Здесь мы предполагаем, что тип ``\lstinline{ht_typ}'' объявлен как

\begin{lstlisting}
let ht_typ ~loc =
  Typ.of_longident ~loc (Ldot (Lident "H", "t"))
\end{lstlisting}

Другими словами, мы объявляем, что типом наследуемого атрибут всегда будет 
 ``\lstinline{H.t}'', а типом синтезированного атрибута будет пара
``\lstinline{H.t * t}''.

Следующая группа методов описывает параметры классов плагина:

\begin{lstlisting}
method plugin_class_params tdecl =
  let ps = List.map tdecl.ptype_params 
             ~f:(fun (t, _) -> typ_arg_of_core_type t)
  in
  ps @
  [ named_type_arg ~loc:(loc_from_caml tdecl.ptype_loc) @@
    Naming.make_extra_param tdecl.ptype_name.txt
  ]

method prepare_inherit_typ_params_for_alias ~loc tdecl rhs_args =
  List.map rhs_args ~f:Typ.from_caml
\end{lstlisting}

Первый метод описывает типовые параметры класса плагина: для данного случая это типовые параметры самого объявления типа плюс дополнительный типовый параметр 
``$\varepsilon$''. Второй метод описывает вычисление типовых параметров для применения конструктора типа. В случае, если объявление типа выглядит как 

\begin{lstlisting}
type $\{\alpha_i\}$ t = $\{a_i\}$ tc
\end{lstlisting}

нам необходимо построить реализацию преобразовния для типа ``\lstinline{t}'' 
из реализации оного для типа  ``\lstinline{tc}'', наследуясь от правильного 
инстанциированного соответвующего класса. Для нашего случая класс параметризуется теми же 
типовыми параметрами, что и объяляемый тип, поэтому мы оставляем их как есть.

Последняя группа методов отвечает за генерацию тел методов для трансформаций  конструкторов.
Мы поддерживаем регулярные конструкторы алгебраических типов, где аргументами может быть и кортеж, и запись, а также записи и кортежи на верхнем уроне, преобразование которые, как правило, имеет много общих частией. Всего за это отвечают 4 метода, но здесь мы покажем только один:

\begin{lstlisting}
method on_tuple_constr ~loc ~is_self_rec ~mutual_decls 
                            ~inhe tdecl constr_info ts =
  $\dots$ 
  match ts with
  | [] -> Exp.tuple ~loc [ inhe; c [] ]
  | ts ->
     let res_var_name = sprintf "%s_rez" in
     let argcount = List.length ts in
     let hfhc = Exp.of_longident ~loc (Ldot (Lident "H", "hc")) in
     List.fold_right
       (List.mapi ~f:(fun n x -> (n, x)) ts)
       ~init:$\dots$
       ~f:(fun (i, (name, typ)) acc ->
            Exp.let_one ~loc
              (Pat.tuple ~loc 
                 [ Pat.sprintf ~loc "ht%d" (i+1)
                 ; Pat.sprintf ~loc "%s" @@ res_var_name name])
              (self#app_transformation_expr ~loc
                 (self#do_typ_gen ~loc ~is_self_rec 
                                  ~mutual_decls tdecl typ)
                 (if i = 0 then inhe else Exp.sprintf ~loc "ht%d" i)
                 (Exp.ident ~loc name)
              )
              acc
          )
  $\dots$
\end{lstlisting}

Реализация использует заранее заготовленный метод нашей библиотеки
``\lstinline{self#app_transformation_expr}'', который генерируется применение фукцнии преобразования к соответсвующему типу.

Конечной компонентой реализации является сам  модуль ``\lstinline{H}''. Стандартный функтор ``\lstinline{Hashtbl.Make}'' создает хэш таблицы, используя некотрую хэш фукнцию и предикат равенства, предоставленные пользователем. В целом, следуем мы следуем такому соглашению: как хэш фукнцию используем полиморфную ``\lstinline{Hashtbl.hash}'', а качестве равенства используем физическое равенство ``\lstinline{==}''. Однако, присутсвуют две сложности:

\begin{itemize}
\item Так как таблице гетерогенная нам необходимо использовать небезопасное приведение типов ``\lstinline{Obj.magic}''.
\item Наша реализация равенства чуть более сложная, чем обычное ``\lstinline{==}''. Нам необходимо стравнивать верхнеуровневые конструкторы и количества их аргументов  \emph{структурно}, а только затем сравнивать соответствующие аргументы взическим равенством. Технически, мы может считать равными структурно равные значения   \emph{различных} типов.
\end{itemize}

Мы полагаемся здесь на следующее наблюдение: hash-consing корректно использовать тольео для структур данных, которые прозрачны по ссылкам, мы предполагаем что равные структуры данных взаимозаменяемы не смотря на их типы. 

Полную реализацию плагина может быть увидеть в главном репозитории. Она занимает 164 строчки кода, учитывая комментарии и пустые строки.
