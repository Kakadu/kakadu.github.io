\documentclass[10pt]{article}

\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}

\newcommand{\code}{\texttt}

\title{Уменьшение цены абстракции при типобезопасном встраивании реляционного языка программирования в OCaml}
\author{
        Дмитрий Косарев\\ \texttt{Dmitrii.Kosarev@protonmail.ch}
}
\date{
  Санкт-Петербургский государственный университет\\
  Математико-механический факультет\\
  \today
}

\begin{document}
\maketitle

\begin{abstract}
В данной работе затронуты детали OCanren~--- типобезопасной реализации реляционного языка программирования
из семейства miniKanren на OCaml, а именно, два подхода для организации типов логических значений. Первый,
наивный, подход позволил получить типобезопасную реализацию, однако привел к понижению производительности
на стадии унификации по сравнению с реализацией miniKanren на Racket. Второй подход не страдает этим 
недостатком.

\end{abstract}

\textbf{Ключевые слова:} OCaml, miniKanren, унификация, цена абстракции.

\vspace{5mm}

Реляционный язык программирования miniKanren позволяет записывать программы как формулы, состоящие из отношений
(relations). Относительная простота miniKanren привела к появлению целого семейства реализаций, большинство из
которых были сделаны либо для различных диалектов LISP, либо на типизируемых языках в бестиповой манере. OCanren 
является типизированной реализацией miniKanren на OCaml~--- языке программирования со строгой статической 
типизацией.

В OCanren разрешается унифицировать между собой только те логические переменные и значения, которые инкапсулируют
значения одинакового типа. Это позволяет находить на стадии компиляции случаи, при которых унифицируются 
значения разных типов, и, следовательно, унификация не может завершиться успешно ни при каких условиях. Также
компилятор, теоретически, может генерировать вызов специализированной для конкретного типа унификации вместо 
обобщенной.

При создании новой реализации miniKanren необходимо обдумать два аспекта: в каком порядке будут вычисляться 
результаты (порядок поиска), и как именно будет происходить процесс унификации. В OCanren была реализована истинно 
полиморфная унификация: единая (для всех типов агументов) функция позволяет унифицировать любые значения одинаковых типов. 
Унификация производится
путём сравнения ориентированных графов (в случае miniKanren~--- деревьев), т.к. все значения OCaml хранятся в 
памяти именно в таком виде.

Однако наивный подход, связанный с объявлением алгебраического типа логических значений \verb|'a logic|, который содержит в себе 
либо логические переменные (конструктор \verb|Var|), либо обычные значения (конструктор \verb|Value|), приводит к тому, что 
размер представлений (деревьев) значений в памяти увеличивается. 
Например, целые числа типа \verb|int| хранятся в виде одного блока памяти. Логическое представление для этих чисел
будет состоять из двух блоков памяти: один для конструктора \verb|Value| и один непосредственно для числа, тем 
самым увеличивая высоту дерева представления в два раза: с единицы до двух. 

%Для списков (и других \emph{рекурсивных} структур данных) высота деревьев также увеличивается в два раза. Рассмотрим
%список целых чисел, содержащий один элемент: он состоит из трех блоков памяти (число, \verb|Cons|-блок и блок для пустого списка),
%которые образуют дерево высотой два. Переход к логическим значениям типа \verb|int| добавит блок для конструктора \verb|Value|
%между \verb|Cons|-блоком и блоком числа. Затем, переход к логическому эквиваленту списков, во-первых, добавит \verb|Value|-блок, который будет
%ссылаться на \verb|Cons|-блок и, во-вторых, добавит \verb|Value|-блок между \verb|Cons|-блоком и хвостом списка, так как второй потомок
%\verb|Cons|-блока должен указывать на значения типа логического списка. Таким образом, переход к логическому представлению
%превращает дерево размером 3 и высотой 2 в дерево размером 6 и высотой 4, что существенно сказывается на производительности унификации.
%Таким образом, общая производительность OCanren оказывается в разы меньше, чем изначальный вариант, несмотря на статическую
%типизацию и ожидаемый от неё выигрыш.

Для списков (и других \emph{рекурсивных} структур данных) высота деревьев также увеличивается в два раза. Например,
список чисел из одного элемента будет занимать в памяти три блока и образовывать дерево высотой два. Логический
эквивалент такого же списка будет прeдставляться в памяти деревом размером 6 и высотой 4, что будет сказываться 
на производительности унификации. Таким образом, общая производительность OCanren оказывается в разы меньше чем 
изначальный вариант.

Альтернативный подход не использует алгебраических типов данных при объявлении типа логических значений 
(если говорить упрощенно, то \verb|type 'a injected = 'a|).
Таким образом, не появляется дополнительных блоков памяти в представлении данных, размер деревьев не увеличивается,
и производительность унификации увеличивается по сравнению с первым случаем. Данный подход требует некоторых преобразований 
получившихся значений, если они содержат в себе свободные логические переменные. Эти преобразования, однако, происходят один раз в конце 
вычислений и влияют на производительность существенно меньшим образом. Также подход требует специфической
работы на уровне системы типов, а именно использования примитивов для конструирования логических значений.

 \verb|val lift: 'a -> ('a,'a) injected|

 \verb|val inj: ('a, 'b) injected -> ('a, 'b logic) injected|

 \verb|val distribute: ('a,'b) injected t -> ('a t, 'b t) injected|

Первые два примитива универсальны, последний вид примитивов не объявлен заранее для каждого вида \verb|t|, 
его можно сгенерировать, если тип \verb|t| представим как функтор.

\begin{thebibliography}{99}

\bibitem{uKanren}
Jason Hemann, Daniel P. Friedman. $\mu$Kanren: A Minimal Core for Relational Programming //
Proceedings of the 2013 Workshop on Scheme and Functional Programming (Scheme '13).

\bibitem{OCanren}
Dmitrii Kosarev, Dmitri Boulytchev. Typed Embedding of a Relational Language in OCaml //
Workshop on ML, 2016.
 
\end{thebibliography}

\end{document}
