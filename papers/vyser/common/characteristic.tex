
{\actuality}
Логическое программирование давно привлекает внимание исследователей тем, что оно предоставляет возможность не реализовывать конкретный алгоритм непосредственно, а вместо этого с некоторой степенью декларативности описывать условие решаемой задачи. Роль алгоритма в данном случае выполняет встроенная в систему логического программирования процедура поиска решения.

Программа-запрос на логическом языке выражается в виде отношений (relations), а результат представляется в виде последовательности кортежей, возможно пустой.
Каждый кортеж в последовательности ответов должен принадлежать запрошенному отношению. Таким образом, роль n-местных функций в логическом программировании играют (n+1)-местные отношения. Эти отношения можно использовать в прямую сторону, конкретизировав аргументы и подставив вместо результата свободную переменную, т.е. как функции. Также является возможным запускать их ``в обратную сторону'', конкретизировав результат и некоторые аргументы, по сути подбирая входные данные, на которых конкретный алгоритм, записанный на логическом языке программирования, выдаст ожидаемый результат.

Обладание свойством декларативности полезно для логических программ. Оно заключается в том, что программист не реализует непосредственно алгоритм как последовательность действий, от него требуется только корректное описание задачи на языке логического программирование. В декларативных описаниях программ результат не зависит от того как именно и в каком порядке описывается предметная область. Это снимает некоторый груз ответственности с программиста. 

Исторически исследование логического программирования началось с изучения языка Prolog, который использует внутри себя  алгоритм поиска в глубину. Этот алгоритм, если находит ответ, показывает хорошую производительность. Однако он обладает свойством неполноты: алгоритм может бесконечно искать ответ в некоторой ветви дерева поиска решения и в итоге не зайти в другие ветви, где решение находится быстрее. Таким образом программы не Prolog не являются декларативными в общем случае.

Противоположный подход к поиску решения --- поиск в ширину --- является алгоритмом полного поиска, но работает недостаточно быстро, и поэтому почти не используется.

Недостаток неполноты поиска в литературе разрешается несколькими способами. Одним из вариантов является добавление Prolog дополнительных конструкций для управления поиском: отсечения (cuts), копирование термов (copyterm) и других. Но корректная расстановка программистом этих конструкций невозможна без обладания информацией о конкретности аргументов отношения. Более того, при различных запросах к логической программе изменяется степень конкретизации используемых данных, и поэтому правильная расстановка конструкций управления поиском невозможна, так как она существенно зависит от входных данных. Это нарушает свойство декларативности логических программ на языке Prolog.

Другим способом борьбы с неполнотой поиска является подход, применяемый в языке Datalog. Этот язык наследует синтаксис и процедуру поиска из Prolog, но некоторые программы и сочетания синтаксических конструкций считаются некорректными. Ограничения выбраны таким образом, что пространство поиска запросов на Datalog является конечным, и, следовательно, поиск в глубину является полным поиском на таких программах. 

Язык Datalog нашел своё применения в различных предметных областях: компиляторы, запросы к базам данных, запросы к интернет-серверам и прочее\footnote{дописать подробнее со ссылками}.

Третьим способом решения проблемы является использование языка программирования miniKanren, который является темой Ph.D. диссертации Уилла Бёрда (Will Byrd). Основных свойств miniKanren можно назвать два.

Во-первых, в нём используется новый алгоритм поиска (interleaving search), являющийся чем-то средним между поисками в глубину и ширину. Как и поиск в ширину он является полным, и, следовательно, если на данный запрос существует ответ, то алгоритм поиска находит этот ответ за конечный, но, возможно, очень длительный, промежуток времени. При этом поиск в miniKanren является направленным в том же смысле, что и поиск в глубину. Программист может записывать программы так, что некоторые случаи (наиболее часто встречающиеся или конечные) будут рассмотрены перед случаями, в которых пространство поиска больше.

Во-вторых, miniKanren не является непосредственно языком программирования, а семейством встраиваемых языков программирования. Его можно реализовывать как библиотеку в языках программирования общего назначения, и так как ядро языка не очень большое, то реализовать miniKanren относительно просто. Флагманской является реализация на различных диалектах Scheme, при этом существуют \footnote{Ссылка на оф. сайт со списком реализаций} реализации miniKanren для других языков: функциональных и императивных, статически и динамически типизированных.

На данный момент сочетанием этих двух свойств обладают только языки семейства miniKanren. В своей Ph.D. диссертации Will Bird вводит термин \emph{реляционное программирование}, приравнивая его к программированию на miniKanren.

За счет использования полного поиска miniKanren обладает свойством декларативности в большей степени, чем Prolog, что позволяет содержательно использовать miniKanren для запуска реляционных запросов в обратную сторону. В 2012 году исследователи Will Byrd, Eric Hold и Daniel Fridman применили miniKanren для написания \emph{реляционного интерпретатора} (интерпретатора некоторого подмножества Scheme на miniKanren) и воспользовались декларативностью и запускаемостью интерпретатора в обратном направлении для синтеза квайнов (quines) для подмножества Scheme.

Реализация miniKanren на строго типизированных языках сопряжена с некоторыми проблемами, так как непосредственное переписывание кода, спроектированного для динамического языка программирования, на строго типизированный языке ведет к ошибкам типизации. Обычно, реализации miniKanren на строго типизированных языках предоставляют для использования встроенный язык программирования с поддержкой некоторого \emph{конечного и заготовленного заранее} набора типов данных. Другими словами программист не может использовать свои типы данных при написании реляционных запросов и вынужден преобразовывать свои данные в реляционный домен.

\paragraph{} Таким образом, для развития реляционного программирования в строго типизированных языках необходимо улучшать реализации miniKanren путём поддержки использования большего количества типов. 

\paragraph{} Возможность запуска реляционных запросов в различных направлениях и большая декларативность относительно Prolog являются привлекательными причинами для использования miniKanren в задачах, где достаточно просто описать проблему и довольно сложно написать эффективный алгоритм поиска решения. Является интересным изучить возможности реляционного программирования для применения в компиляторах функциональных языков\footnote{что-то мотивация страдает}.

{\progress}
%С 1990-х годов велась работа по
%разработке семантики многопоточности с учетом слабых сценариев поведения.
%Формальные модели для наиболее распространенных процессорных архитектур (x86, Power, ARM)
%были разработаны J. Alglave, S. Ishtiaq, L. Maranget, F. Zappa Nardelli, S. Sarkar, P. Sewell и др.
%исследователями\cscite{Alglave-al:TOPLAS14,Sewell-al:CACM10,Owens-al:TPHOL09}.
%Новые версии моделей продолжают появляться в связи с развитием процессорных архитектур.
%В частности, в 2016 и 2017 годах были представлены модели памяти для архитектур ARMv8.0 и
%ARMv8.3\cscite{Flur-al:POPL16,Pulte-al:POPL18}.
%% В настоящее время также ведутся работы по формализации моделей памяти графических процессоров.
%В 1995 году была стандартизована слабая модель памяти для языка Java\cscite{Manson-al:POPL05};
%в дальнейшем модель существенно менялась вплоть до 2005 года.
%В 2011 году появилась аксиоматическая модель памяти для языков C/C++\cscite{Batty-al:POPL11}.
%% Так модель памяти Java некорректна по отношению к базовым оптимизациям, а модель памяти C/С++ разрешает сценарии поведения
%% программ, в которых появляются т.н. \emph{значения из воздуха} (Out-Of-Thin-Air values),
%% что делает некорректными даже базовые рассуждения о программах.
%
%В 2017 году исследователи J. Kang, C.-K. Hur, O. Lahav, V. Vafeiadis и D. Dreyer
%представили обещающую модель памяти (promising memory model, $\Promise$)\cscite{Kang-al:POPL17}, которая является перспективным
%решением проблемы задания семантики для языка с многопоточностью. Авторы 
%доказали, что модель допускает большинство необходимых оптимизаций, а также показали корректность
%эффективных схем компиляции в архитектуры x86 и Power. Открытым остался вопрос о корректности компиляции
%в архитектуру ARM.

%% Один из основополагающих результатов в области формальной верификации, логика Хоара (Hoare logic), была
%% предложена Hoare в 1969 году. В конце 1990-ых Reynolds, O'Hearn и другие разработали ее расширение,
%% логику разделения (separation logic), которая позволила доказывать свойства однопоточных программ
%% композиционально относительно использованной памяти. Далее O'Hearn и Reynolds предложили логику разделения
%% для многопоточности (concurrent separation logic). Она базируется на денотационной семантике Brookes,
%% которая, в свою очередь, является композициональным представлением модели памяти последовательной
%% консистентности Lamport. С помощью логики разделения для многопоточности десятки многопоточных алгоритмов
%% были верифицированы в модели последовательной консистентности
%% (работы Birkedal, Dreyer, Gardner, Gotsman, Nanevski, Sergey, Vafeiadis и других).

%% Параллельно с развитием логик для последовательной консистентности,

%% \cite{Kang-al:POPL17}

%% Этот раздел должен быть отдельным структурным элементом по
%% ГОСТ, но он, как правило, включается в описание актуальности
%% темы. Нужен он отдельным структурынм элемементом или нет ---
%% смотрите другие диссертации вашего совета, скорее всего не нужен.

{\aim} данной работы является применение реляционного программирования в компиляторах, а также поиск подзадач во время процесса компиляции, которые могут получить выгоду от использования реляционного программирования.

Для~достижения поставленной цели были сформулированы следующие {\tasks}.
\begin{enumerate}
  %% \item Провести обзор существующих операционных моделей слабой памяти.
  \item Разработать и реализовать предментно-ориентированный язык семейства miniKanren для встраивания в OCaml.
  %% \item Формализовать модель памяти ARMv8 и доказать дополнительные свойства о ней, необходимые для
  %%       доказательства корректности компиляции. 
  %% \item Разработать метод для доказательства корректности компиляции из обещающей модели в модели памяти
  %%       процессорных архитектур.
  %% \item Апробировать применимость метода на примере доказательства корректности компиляции из обещающей модели памяти в
  %%       операционныую модель памяти ARMv8 POP и аксиоматическую модели памяти процессора ARMv8.3.
  \item Исследовать алгоритмы, которые используются в компиляторе OCaml, выделить те части компилятора, где использование реляционного программирования выгодно.
  \item Проверить успешность реляционного программирования для написания частей компилятора функционального языка.
\end{enumerate}

Постановка цели и задач исследования соответствует следующим пунктам паспорта специальности 05.13.11:
модели, методы и алгоритмы проектирования и анализа программ и программных систем, их эквивалентных преобразований, верификации и тестирования (пункт 1);
языки программирования и системы программирования, семантика программ (пункт 2);
модели и методы создания программ и программных систем для параллельной и распределенной обработки данных,
языки и инструментальные средства параллельного программирования (пункт 8).

{\methods}
%Методология исследования базируется на подходах информатики
%к описанию и анализу формальных семантик языков программирования.
%% Также используется концепция симуляции систем переходов.

%В работе используется представление операционной семантики программы с помощью помеченной системы переходов\cscite{Keller:CACM76},
%а также метода вычислительных контекстов, предложенного M. Felleisen\cscite{Felleisen-Hieb:TCS92}.
%Для доказательств корректности компиляции используется техника прямой симуляции\cscite{Lynch-Vaandrager:IC95,Lynch-Vaandrager:IC96}.
%Программная реализация интерпретатора операционной модели памяти C/C++11 выполнена на языке Racket\cscite{Flatt-PLT:TR10,RacketLang}
%с использованием предметно-ориентированного расширения PLT/Redex\cscite{Felleisen-al:BOOK09,Klein-al:POPL12}.

%% \filbreak
{{\defpositions}
\begin{enumerate}
  %% \item Проведён обзор существующих операционных моделей слабой памяти.
  %%       \todo{(пока не сделано)}
%  \item Предложена операционная модель памяти C/С++11, для этой модели реализован интерпретатор.
  \item Разработка и реализация OCanren в виде библиотеки: предметно-ориентированного, встраиваемого (в OCaml) языка реляционного программирования.
  \item Разработка и реализация библиотеки обобщенного программирования Generic Transformers для языка OCaml, которая упрощает обобщенное программирование в OCaml в общем, а в частности облегчает написание реляционных запросов с помощью OCanren.
  \item Применение реляционного программирования для компилятора функционального языка OCaml (планируется). 
  \begin{itemize}
  \item Применение реляционного алгоритма поиска для компиляции языковой конструкции “сопоставление с образцом” (pattern matching) для языка OCaml, а исследование трудоемкости расширения процедуры компиляции при расширении конструкции сопоставления с образцом.
  \item Добавление расширений компиляции расширений конструкции сопоставления с образцом.
  \item Реализация выделения регистров с помощью решения пазлов (puzzle solving).
  \end{itemize}



  
  
  %% \item Создан компонентный метод описания интерпретаторов для модели C/C++11 в системе PLT/Redex.
  %% \item Разработан реляционный интерпретатор для модели C/C++11, позволяющий исправлять ошибки синхронизации
  %%       в программах.
  %%       \todo{(пока не сделано)}
  %% \item Реализован метод автоматического поиска сертификата в обещающей \; модели памяти.
  %%       \todo{(пока не сделано)}
  %% \item Проведена формализация операционной модели памяти ARMv8 POP, доказаны вспомогательные утверждения про
  %%       модель, полезные для проверки корректности компиляции.
%  \item Доказана корректность компиляции из существенного подмножества обещающей модели в операционную модель памяти ARMv8 POP.
  %% \item Разработан метод доказательства корректности компиляции из обещающей модели памяти в аксиоматические модели памяти,
  %%       который основан на построении операционной семантики по аксиоматической.
%  \item Доказана корректность компиляции из существенного подмножества обещающей модели в аксиоматическую модель памяти ARMv8.3.
  %% с помощью метода, основанного на построении операционной семантики по аксиоматической.
\end{enumerate}
}

{\novelty} результатов, полученных в рамках исследования, заключается в следующем.
\begin{enumerate}
  \item 
%  Альтернативная модель памяти для стандарта C/C++11, предложенная в работе, отличается от обещающей модели
%  памяти\cscite{Kang-al:POPL17} тем, что является запускаемой,
%  т.е. для нее возможно создание интерпретатора (что и было выполнено в рамках данной диссертационной работы).
%  Это отличие является следствием того, что для получения эффекта отложенного чтения предложенная модель использует
%  синтаксический подход (буферизация инструкций), тогда как обещающая модель --- семантический (обещание потоком сделать
%  запись в будущем).
  \item 
%  Доказательство корректности компиляции из обещающей модели памяти в аксиоматическую модель
%        ARMv8.3\cscite{Pulte-al:POPL18}
%        не опирается на специфические свойства целевой модели, такие как представимость модели в виде
%        набора оптимизаций поверх более строгой модели.
%        Это отличает его от аналогичных доказательств для моделей x86 и Power
%        (работы O. Lahav, V.Vafeiadis и других\cscite{Lahav-Vafeiadis:FM16,Kang-al:POPL17}).
  \item 
%  Доказательства корректности компиляции из обещающей модели памяти в
%  модели ARMv8 POP\cscite{Flur-al:POPL16} и ARMv8.3\cscite{Pulte-al:POPL18}, представленные
%  в работе, являются первыми результатами о компиляции для данных моделей.
  %% Кроме того, представленный подход может быть использован и для доказательства
  %% корректности компиляции в модели x86 и Power, а значит обладает большой областью применимости.
\end{enumerate}

{\influence}
%Диссертационное исследование предлагает новый
%операционный способ представления реалистичной семантики многопоточности с помощью меток времени и фронтов, который
%может быть полезен при верификации многопоточных программ с неблокирующей синхронизацией, а также при анализе
%реализации примитивов блокирующей синхронизации.
%
%Предложенный в диссертационном исследовании метод доказательства корректности компиляции из обещающей в
%аксиоматические модели памяти может быть использован для доказательств корректности компиляции
%из обещающей модели в архитектуры других процессоров.
%Последнее актуально в свете того, что
%в комитетах по стандартизации языков C и C++ активно обсуждается вопрос о смене модели памяти, и обещающая модель 
%является одной из возможных альтернатив. 

%% \textcolor{blue}{План публикаций ВАК:}
%% \begin{enumerate}
%%   %% \item \emph{Сертифицируемость шагов обещающей \; семантики в контексте доказательства корректности компиляции
%%   %%   в модель памяти ARMv8 POP.}

%%   %%   В этой статье я собираюсь описать часть доказательства, которая не описана в моей статье на ECOOP'17.
%%   %%   \textcolor{red}{Подготовить черновой вариант за июль.}
%%   %%   \textcolor{green}{Вестник Политеха.}
    
%%   \item \emph{Слабые модели памяти языков программирования. Проблемы и решения.}
%%     Обзорная статья. Можем попробовать успеть опубликовать в первом выпуске НТВ СПбГПУ 2018 года.
    
%%   \item Кирпич нужно подготовить к концу декабря.
%%   %% \item Новый вариант названия ``Слабые модели памяти для языка C/C++''.
%% \end{enumerate}

{\reliability}
%Достоверность и обоснованность результатов исследования
%обеспечивается формальными доказательствами, а также инженерными экспериментами.
%Полученные результаты согласуются с результатами, установленными другими авторами.


%% {\probation}
%Основные результаты работы докладывались~на следующих научных конференциях и семинарах:
%внутренний семинар ННГУ им. Лобачевского (13 декабря 2017, Нижний Новгород, Россия),
%открытая конференция ИСП РАН им. В.П. Иванникова (30 ноября--1 декабря  2017, РАН, Москва, Россия),
%семинар ``Технологии разработки и анализа программ'' (16 ноября 2017, ИСП РАН, Москва, Россия),
%внутренние семинары School of Computing of the University of Kent (август 2017, Кентербери, Великобритания),
%внутренние семинары Department of Computer Science of UCL (август 2017, Лондон, Великобритания),
%внутренние семинары MPI-SWS (май 2017, Кайзерслаутерн, Германия),
%The European Conference on Object-Oriented Programming (ECOOP, 18--23 июня 2017, Барселона, Испания),
%конференция ``Языки программирования и компиляторы'' (PLC, 3--5 апреля 2017, Ростов-на-Дону, Россия),
%Verified Trustworthy Software Systems workshop (VTSS, 4-7 апреля 2016, Лондон, Великобритания),
%POPL 2016 Student Research Competition (21 января 2016, Санкт-Петербург, Флорида, США).

%% {\contribution} Автор принимал активное участие \ldots

%% \publications\ Основные результаты по теме диссертации изложены в ХХ печатных изданиях~\cite{Sokolov,Gaidaenko,Lermontov,Management},
%% Х из которых изданы в журналах, рекомендованных ВАК~\cite{Sokolov,Gaidaenko}, 
%% ХХ --- в тезисах докладов~\cite{Lermontov,Management}.

\ifnumequal{\value{bibliosel}}{0}{% Встроенная реализация с загрузкой файла через движок bibtex8
    {\publications}
%        Основные результаты по теме диссертации изложены в пяти %\arabic{citeauthor}
%        печатных работах, зарегистрированных в РИНЦ.
%        Из них две статьи изданы в журналах из \vakJournals.
%        Одна статья опубликована в издании, входящем в базы цитирования SCOPUS и Web of Science.
%        
%        Личный вклад автора в публикациях, выполненных с соавторами, распределён следующим образом.
%        В статьях \cite{Podkopaev-al:NTV17,Podkopaev-al:ISPRAS17}  автор предложил  схему
%        доказательства корректности компиляции для аксиоматических семантик и выполнил само доказательство для модели ARMv8.3;
%        соавторы участвовали в обсуждении основных идей доказательства.
%        В работах \cite{Podkopaev-al:ECOOP17, Podkopaev-al:PLC17}
%        автор выполнил формализацию семантики ARMv8 POP и доказал корректность компиляции методом симуляции;
%        соавторы участвовали в обсуждении идей доказательства и редактировали тексты статей.
%        В работе \cite{Podkopaev-al:CoRR16} личный вклад автора заключается в предложении идеи меток времени и фронтов как способа
%        операционного задания модели памяти, а также в создании компонентного метода задания семантики и реализации интерпретатора;
%        соавторы предложили синтаксический способ обработки отложенных операций.
        
}{% Реализация пакетом biblatex через движок biber
%Сделана отдельная секция, чтобы не отображались в списке цитированных материалов
    \begin{refsection}[vak,papers,conf]% Подсчет и нумерация авторских работ. Засчитываются только те, которые были прописаны внутри \nocite{}.
        %Чтобы сменить порядок разделов в сгрупированном списке литературы необходимо перетасовать следующие три строчки, а также команды в разделе \newcommand*{\insertbiblioauthorgrouped} в файле biblio/biblatex.tex
        \printbibliography[heading=countauthorvak, env=countauthorvak, keyword=biblioauthorvak, section=1]%
        \printbibliography[heading=countauthorconf, env=countauthorconf, keyword=biblioauthorconf, section=1]%
        \printbibliography[heading=countauthornotvak, env=countauthornotvak, keyword=biblioauthornotvak, section=1]%
        \printbibliography[heading=countauthor, env=countauthor, keyword=biblioauthor, section=1]%
        \nocite{%Порядок перечисления в этом блоке определяет порядок вывода в списке публикаций автора
                Podkopaev-al:NTV17,
                Podkopaev-al:ISPRAS17,
                %% vakbib1,vakbib2,%
                %% confbib1,confbib2,%
                Podkopaev-al:ECOOP17,
                Podkopaev-al:PLC17, Podkopaev-al:CoRR16,
                %% bib1,bib2,%
        }%
        {\publications}
%        Основные результаты по теме диссертации изложены в пяти 
%        печатных работах, зарегистрированных в РИНЦ.
%        Из них две статьи изданы в журналах из \vakJournals.
%        Одна статья опубликована в издании, входящем в базы цитирования Scopus и Web of Science.

%        Личный вклад автора в публикациях, выполненных с соавторами, распределён следующим образом.
%        В статьях \cite{Podkopaev-al:NTV17,Podkopaev-al:ISPRAS17}  автор предложил  схему
%        доказательства корректности компиляции для аксиоматических семантик и выполнил само доказательство для модели ARMv8.3;
%        соавторы участвовали в обсуждении основных идей доказательства.
%        В работах \cite{Podkopaev-al:ECOOP17, Podkopaev-al:PLC17}
%        автор выполнил формализацию семантики ARMv8 POP и доказал корректность компиляции методом симуляции;
%        соавторы участвовали в обсуждении идей доказательства и редактировали текст статей.
%        В работе \cite{Podkopaev-al:CoRR16} личный вклад автора заключается в предложении идеи меток времени и фронтов как способа
%        операционного задания модели памяти, а также в создании компонентного метода задания семантики и реализации интерпретатора;
%        соавторы предложили синтаксический способ обработки отложенных операций.
    \end{refsection}
    \begin{refsection}[vak,papers,conf]%Блок, позволяющий отобрать из всех работ автора наиболее значимые, и только их вывести в автореферате, но считать в блоке выше общее число работ
        \printbibliography[heading=countauthorvak, env=countauthorvak, keyword=biblioauthorvak, section=2]%
        \printbibliography[heading=countauthornotvak, env=countauthornotvak, keyword=biblioauthornotvak, section=2]%
        \printbibliography[heading=countauthorconf, env=countauthorconf, keyword=biblioauthorconf, section=2]%
        \printbibliography[heading=countauthor, env=countauthor, keyword=biblioauthor, section=2]%
        \nocite{Podkopaev-al:NTV17}%vak
        \nocite{Podkopaev-al:ISPRAS17}%vak
        \nocite{Podkopaev-al:ECOOP17}%conf
        \nocite{Podkopaev-al:PLC17,Podkopaev-al:CoRR16}%notvak
    \end{refsection}
}
%% При использовании пакета \verb!biblatex! для автоматического подсчёта
%% количества публикаций автора по теме диссертации, необходимо
%% их здесь перечислить с использованием команды \verb!\nocite!.
