
{\actuality}
%% Параллельные вычисления являются неотъемлимой частью современных
%% информационных систем. В настоящее время абсолютное большинство процессоров, используемых
%% в настольных компьютерах, серверах и смартфонах, являются многоядерными,
%% а большинство критичных к производительности программ --- многопоточными.
%% Многопоточность предоставляет программисту широкие возможности для ускорения вычислений,
%% потенциально позволяя уменьшить время исполнения или увеличить производительность программы
%% во столько же раз, сколько процессоров (ядер) находится в вычислительной системе.
%% Недостатком многопоточных программ является то, что они сложны для разработки и поддержки --- их поведение
%% зависит не только от входных данных, но и от планировщика задач в процессоре, который
%% управляет исполнением потоков программы на процессорных ядрах.
%% Как следствие,
Многопоточные программы являются источниками специфических,
трудно обнаружимых ошибок,
таких как состояние гонки, взаимная блокировка и др.
Эти ошибки могут воспроизводиться очень редко, например, в одном из 10 тысяч запусков
программы, однако даже это может быть критично.
%% ---
%% подобная ``редкая'' \, ошибка в ядре операционной системы Linux, которая
%% используется как минимум в 20 миллионах серверов по всему миру, будет приводить
%% к 200 тысячам неправильных срабатываний каждый день.
%% Таким образом,
В связи с этим необходимо иметь специализированные методы для анализа многопоточных программ.
Ключевым аспектом любого анализа программ является наличие хорошо определенной семантики языка программирования.
Семантики языков программирования и систем (процессоров) с многопоточностью называют \emph{моделями памяти} (memory model, MM).

Наиболее простой и естественной моделью памяти является 
\emph{последовательная консистентность} (sequential consistency, SC)\cscite{Lamport:TC79};
она подразумевает, что каждый сценарий поведения многопоточной программы может быть
получен некоторым поочередным исполнением команд её потоков на одном ядре (процессоре).
Однако эта модель не способна описать все сценарии поведения, встречаемые на практике.
Сценарии поведения, которые не могут быть описаны моделью SC, называются \emph{слабыми}.

Слабыми сценариями поведения обладают некоторые многопоточные программы с неблокирующей синхронизацией потоков.
Это является следствием обработки программ оптимизирующими компиляторами и их исполнением
на суперскалярных процессорах.
Поскольку алгоритмы на базе неблокирующей синхронизации всё чаще используются
при разработке важных и высокопроизводительных систем, таких как ядро Linux и системы управления базами данных,
то слабые сценарии поведения требуют тщательного изучения. 

Модели памяти, допускающие слабые сценарии поведения программ, называются \emph{слабыми}
(weak memory models)\cscite{Adve-Gharachorloo:IEEE96}.
На данный момент научное сообщество в тесном сотрудничестве с индустрией
разработало и продолжает совершенствовать множество таких моделей для
языков программирования и процессорных архитектур.
При этом процессорные и языковые модели существенно влияют на друг друга.
Так, модель процессора должна отражать сценарии поведения, наблюдаемые при запуске программ
на существующих процессорах, и оставлять возможности для развития
обратно совместимых архитектур. В то же время, языковая модель должна
предоставлять разумные и удобные абстракции для программиста, а также допускать основные
компиляторные оптимизации и быть совместимой с моделям целевых архитектур,
т.е. поддерживать эффективную трансляцию в низкоуровневый код без изменения
семантики программы.

%% Стандарты некоторых промышленных языков программирования содержат формальные модели памяти.
%% Языки C и C++ обладают наиболее продвинутой и разработанной моделью памяти, которая
%% появилась в редакции стандартов от 2011 года. Далее мы будем писать ``модель C/C++11''
%% для обозначения этой модели памяти.

%% Несмотря на свою продвинутость, модель C/C++11 обладает рядом недостатков.
%% Так, модель поддерживает не все компиляторные оптимизации, которые должны быть поддержаны;
%% некоторые аспекты модели противоречат существующим эффективным схемам компиляции
%% в распространенные архитектуры (в частности, в архитектуру Power);
%% модель разрешает т.н. \emph{значения из воздуха} (Out-Of-Thin-Air values, OOTA).
%% В работах M.Batty, H.-J.Boehm, O.Lahav, P.Sewell, V. Vafeiadis и других
%% были предложены локальные изменения модели для решения упомянутых проблем.
%% Более принципиальной проблемой модели C/C++11 является то, что для некоторых программ
%% модель разрешает сценарии поведения с т.н.

%% Одним из них является то, что модель разрешает т.н.
%% \emph{значения из воздуха} (Out-Of-Thin-Air values, OOTA), которые делают некорректными
%% даже базовые рассуждения о поведнии программ.
%% Например, согласно модели C/C++11 программа слева может завершиться с результатом $a = b = 42$,
%% даже несмотря на отсутствие и данного значения, и арифметики в программе:
%% \[
%% %% \begin{array}{c c}
%% \begin{array}{c}
%% {} [x] := 0; [y] := 0; \\
%% \begin{array}{l || l}
%%    a := [x]; & b := [y]; \\
%% {} [y] := a; & [x] := b; \\
%% \end{array}
%% \end{array}
%% %% &
%% %% \begin{array}{c}
%% %% {} [x] := 0; [y] := 0; \\
%% %% \begin{array}{l || l}
%% %%    a := [x]; & b := [y]; \\
%% %% {} [y] := 42; & [x] := 42; \\
%% %% \end{array}
%% %% \end{array}
%% %% \end{array}
%% \]
%% При этом, естественно, значения из воздуха разрешаются только в рамках формальной модели C/С++11
%% и не наблюдаются при реальных запусках аналогичных программ.

%% Наличие данной проблемы связано с тем, что модель C/C++11 является аксиоматической, а не
%% операционной, и при этом поддерживает множество оптимизаций

%% План:
%% \begin{enumerate}
%% \item Наличие этой проблемы связано с тем, что модель C++11 является аксиоматической
%%       и пытается поддерживать множество оптимизаций.
%% \item Одним из способов решить эту проблему является разработка операционного варианта
%%       модели памяти C++.
%% \item Операционная модель также обладает рядом достоинств. Так, в частности, операционная
%%       модель подразумевает наличие интерпретатора, а значит -- отладчика.
%% \item Как следствие, актуальной является задача разработка операционной модели памяти
%%       для языка программирования. При этом за основу стоит взять синтаксис модели памяти C++11.
%% \end{enumerate}

Существующие модели памяти для наиболее популярных языков программирования обладают рядом недостатков.
Так, известно, что модель памяти Java\cscite{Manson-al:POPL05} некорректна по отношению
к базовым оптимизациям, а модель памяти C/С++11\cscite{Batty-al:POPL11} разрешает
сценарии поведения программ, в которых появляются ``значения из воздуха'' (out-of-thin-air values)\cscite{Boehm-Demsky:MSPC14}.
Модель памяти имеет проблему ``значений из воздуха'', если для программы без арифметики,
в которой явным образом не встречается некоторая константа, (например, 42) допустим сценарий поведения,
в котором эта константа появляется (например, записывается в память или читается из памяти).
Такие сценарии не проявляются на практике, но тот факт,
что модель C/C++11 их допускает, не позволяет формально доказывать многие полезные свойства программ в рамках этой модели.
Наличие проблемы ``значений из воздуха'' связано с тем, что модель C/C++11 задана декларативно (аксиоматически), при этом сценарий поведения программы
в рамках модели определяется как некоторая монолитная структура (граф), а не как последовательность действий некоторой
абстрактной машины.
Это оставляет открытым вопрос об интеграции модели с остальными компонентами языка, которые в стандарте C/C++11 определены
операционно.

Таким образом, для развития инструментов анализа многопоточных программ необходимо
разработать операционные подходы к заданию слабых моделей памяти.

%% \textbf{Comment.} Много описания контекста. Почему x86, Power и ARM важны (с цифрами)?
%% Следить, если Promise станет стандартом для C++ и/или Java.

%% Обзор, введение в тему, обозначение места данной работы в
%% мировых исследованиях и~т.\:п., можно использовать ссылки на другие
%% работы~\cite{Gosele1999161} (если их нет, то в автореферате
%% автоматически пропадёт раздел <<Список литературы>>). Внимание! Ссылки
%% на другие работы в разделе общей характеристики работы можно
%% использовать только при использовании \verb!biblatex! (из-за технических
%% ограничений \verb!bibtex8!. Это связано с тем, что одна и та же
%% характеристика используются и в тексте диссертации, и в
%% автореферате. В последнем, согласно ГОСТ, должен присутствовать список
%% работ автора по теме диссертации, а \verb!bibtex8! не умеет выводить в одном
%% файле два списка литературы).

%% Для генерации содержимого титульного листа автореферата, диссертации и
%% презентации используются данные из файла \verb!common/data.tex!. Если,
%% например, вы меняете название диссертации, то оно автоматически
%% появится в итоговых файлах после очередного запуска \LaTeX. Согласно
%% ГОСТ 7.0.11-2011 <<5.1.1 Титульный лист является первой страницей
%% диссертации, служит источником информации, необходимой для обработки и
%% поиска документа.>> Наличие логотипа организации на титульном листе
%% упрощает обработку и поиск, для этого разметите логотип вашей
%% организации в папке images в формате PDF (лучше найти его в векторном
%% варианте, чтобы он хорошо смотрелся при печати) под именем
%% \verb!logo.pdf!. Настроить размер изображения с логотипом можно в
%% соответствующих местах файлов \verb!title.tex!  отдельно для
%% диссертации и автореферата. Если вам логотип не нужен, то просто
%% удалите файл с логотипом.

{\progress}
С 1990-х годов велась работа по
разработке семантики многопоточности с учетом слабых сценариев поведения.
Формальные модели для наиболее распространенных процессорных архитектур (x86, Power, ARM)
были разработаны J. Alglave, S. Ishtiaq, L. Maranget, F. Zappa Nardelli, S. Sarkar, P. Sewell и др.
исследователями\cscite{Alglave-al:TOPLAS14,Sewell-al:CACM10,Owens-al:TPHOL09}.
Новые версии моделей продолжают появляться в связи с развитием процессорных архитектур.
В частности, в 2016 и 2017 годах были представлены модели памяти для архитектур ARMv8.0 и
ARMv8.3\cscite{Flur-al:POPL16,Pulte-al:POPL18}.
%% В настоящее время также ведутся работы по формализации моделей памяти графических процессоров.
В 1995 году была стандартизована слабая модель памяти для языка Java\cscite{Manson-al:POPL05};
в дальнейшем модель существенно менялась вплоть до 2005 года.
В 2011 году появилась аксиоматическая модель памяти для языков C/C++\cscite{Batty-al:POPL11}.
%% Так модель памяти Java некорректна по отношению к базовым оптимизациям, а модель памяти C/С++ разрешает сценарии поведения
%% программ, в которых появляются т.н. \emph{значения из воздуха} (Out-Of-Thin-Air values),
%% что делает некорректными даже базовые рассуждения о программах.

В 2017 году исследователи J. Kang, C.-K. Hur, O. Lahav, V. Vafeiadis и D. Dreyer
представили обещающую модель памяти (promising memory model, $\Promise$)\cscite{Kang-al:POPL17}, которая является перспективным
решением проблемы задания семантики для языка с многопоточностью. Авторы 
доказали, что модель допускает большинство необходимых оптимизаций, а также показали корректность
эффективных схем компиляции в архитектуры x86 и Power. Открытым остался вопрос о корректности компиляции
в архитектуру ARM.

%% Один из основополагающих результатов в области формальной верификации, логика Хоара (Hoare logic), была
%% предложена Hoare в 1969 году. В конце 1990-ых Reynolds, O'Hearn и другие разработали ее расширение,
%% логику разделения (separation logic), которая позволила доказывать свойства однопоточных программ
%% композиционально относительно использованной памяти. Далее O'Hearn и Reynolds предложили логику разделения
%% для многопоточности (concurrent separation logic). Она базируется на денотационной семантике Brookes,
%% которая, в свою очередь, является композициональным представлением модели памяти последовательной
%% консистентности Lamport. С помощью логики разделения для многопоточности десятки многопоточных алгоритмов
%% были верифицированы в модели последовательной консистентности
%% (работы Birkedal, Dreyer, Gardner, Gotsman, Nanevski, Sergey, Vafeiadis и других).

%% Параллельно с развитием логик для последовательной консистентности,

%% \cite{Kang-al:POPL17}

%% Этот раздел должен быть отдельным структурным элементом по
%% ГОСТ, но он, как правило, включается в описание актуальности
%% темы. Нужен он отдельным структурынм элемементом или нет ---
%% смотрите другие диссертации вашего совета, скорее всего не нужен.

{\aim} данной работы является исследование применимости операционных
подходов для описания реалистичных моделей памяти и анализа
многопоточных программ на примере языков C/C++.

Для~достижения поставленной цели были сформулированы следующие {\tasks}.
\begin{enumerate}
  %% \item Провести обзор существующих операционных моделей слабой памяти.
  \item Разработать операционную модель памяти С/С++11, свободную от проблемы ``значений из воздуха''.
  %% \item Формализовать модель памяти ARMv8 и доказать дополнительные свойства о ней, необходимые для
  %%       доказательства корректности компиляции. 
  %% \item Разработать метод для доказательства корректности компиляции из обещающей модели в модели памяти
  %%       процессорных архитектур.
  %% \item Апробировать применимость метода на примере доказательства корректности компиляции из обещающей модели памяти в
  %%       операционныую модель памяти ARMv8 POP и аксиоматическую модели памяти процессора ARMv8.3.
  \item Доказать корректность эффективной схемы компиляции из существенного подмножества обещающей модели в операционную модель памяти ARMv8 POP.
  \item Доказать корректность эффективной схемы компиляции из существенного подмножества обещающей модели в аксиоматическую модель памяти ARMv8.3.
\end{enumerate}

Постановка цели и задач исследования соответствует следующим пунктам паспорта специальности 05.13.11:
модели, методы и алгоритмы проектирования и анализа программ и программных систем, их эквивалентных преобразований, верификации и тестирования (пункт 1);
языки программирования и системы программирования, семантика программ (пункт 2);
модели и методы создания программ и программных систем для параллельной и распределенной обработки данных,
языки и инструментальные средства параллельного программирования (пункт 8).

{\methods}
Методология исследования базируется на подходах информатики
к описанию и анализу формальных семантик языков программирования.
%% Также используется концепция симуляции систем переходов.

В работе используется представление операционной семантики программы с помощью помеченной системы переходов\cscite{Keller:CACM76},
а также метода вычислительных контекстов, предложенного M. Felleisen\cscite{Felleisen-Hieb:TCS92}.
Для доказательств корректности компиляции используется техника прямой симуляции\cscite{Lynch-Vaandrager:IC95,Lynch-Vaandrager:IC96}.
Программная реализация интерпретатора операционной модели памяти C/C++11 выполнена на языке Racket\cscite{Flatt-PLT:TR10,RacketLang}
с использованием предметно-ориентированного расширения PLT/Redex\cscite{Felleisen-al:BOOK09,Klein-al:POPL12}.

%% \filbreak
{{\defpositions}
\begin{enumerate}
  %% \item Проведён обзор существующих операционных моделей слабой памяти.
  %%       \todo{(пока не сделано)}
  \item Предложена операционная модель памяти C/С++11, для этой модели реализован интерпретатор.
  %% \item Создан компонентный метод описания интерпретаторов для модели C/C++11 в системе PLT/Redex.
  %% \item Разработан реляционный интерпретатор для модели C/C++11, позволяющий исправлять ошибки синхронизации
  %%       в программах.
  %%       \todo{(пока не сделано)}
  %% \item Реализован метод автоматического поиска сертификата в обещающей \; модели памяти.
  %%       \todo{(пока не сделано)}
  %% \item Проведена формализация операционной модели памяти ARMv8 POP, доказаны вспомогательные утверждения про
  %%       модель, полезные для проверки корректности компиляции.
  \item Доказана корректность компиляции из существенного подмножества обещающей модели в операционную модель памяти ARMv8 POP.
  %% \item Разработан метод доказательства корректности компиляции из обещающей модели памяти в аксиоматические модели памяти,
  %%       который основан на построении операционной семантики по аксиоматической.
  \item Доказана корректность компиляции из существенного подмножества обещающей модели в аксиоматическую модель памяти ARMv8.3.
  %% с помощью метода, основанного на построении операционной семантики по аксиоматической.
\end{enumerate}
}

{\novelty} результатов, полученных в рамках исследования, заключается в следующем.
\begin{enumerate}
  \item Альтернативная модель памяти для стандарта C/C++11, предложенная в работе, отличается от обещающей модели
  памяти\cscite{Kang-al:POPL17} тем, что является запускаемой,
  т.е. для нее возможно создание интерпретатора (что и было выполнено в рамках данной диссертационной работы).
  Это отличие является следствием того, что для получения эффекта отложенного чтения предложенная модель использует
  синтаксический подход (буферизация инструкций), тогда как обещающая модель --- семантический (обещание потоком сделать
  запись в будущем).
  \item Доказательство корректности компиляции из обещающей модели памяти в аксиоматическую модель
        ARMv8.3\cscite{Pulte-al:POPL18}
        не опирается на специфические свойства целевой модели, такие как представимость модели в виде
        набора оптимизаций поверх более строгой модели.
        Это отличает его от аналогичных доказательств для моделей x86 и Power
        (работы O. Lahav, V.Vafeiadis и других\cscite{Lahav-Vafeiadis:FM16,Kang-al:POPL17}).
  \item Доказательства корректности компиляции из обещающей модели памяти в
  модели ARMv8 POP\cscite{Flur-al:POPL16} и ARMv8.3\cscite{Pulte-al:POPL18}, представленные
  в работе, являются первыми результатами о компиляции для данных моделей.
  %% Кроме того, представленный подход может быть использован и для доказательства
  %% корректности компиляции в модели x86 и Power, а значит обладает большой областью применимости.
\end{enumerate}

{\influence}
Диссертационное исследование предлагает новый
операционный способ представления реалистичной семантики многопоточности с помощью меток времени и фронтов, который
может быть полезен при верификации многопоточных программ с неблокирующей синхронизацией, а также при анализе
реализации примитивов блокирующей синхронизации.

Предложенный в диссертационном исследовании метод доказательства корректности компиляции из обещающей в
аксиоматические модели памяти может быть использован для доказательств корректности компиляции
из обещающей модели в архитектуры других процессоров.
Последнее актуально в свете того, что
в комитетах по стандартизации языков C и C++ активно обсуждается вопрос о смене модели памяти, и обещающая модель 
является одной из возможных альтернатив. 

%% \textcolor{blue}{План публикаций ВАК:}
%% \begin{enumerate}
%%   %% \item \emph{Сертифицируемость шагов обещающей \; семантики в контексте доказательства корректности компиляции
%%   %%   в модель памяти ARMv8 POP.}

%%   %%   В этой статье я собираюсь описать часть доказательства, которая не описана в моей статье на ECOOP'17.
%%   %%   \textcolor{red}{Подготовить черновой вариант за июль.}
%%   %%   \textcolor{green}{Вестник Политеха.}
    
%%   \item \emph{Слабые модели памяти языков программирования. Проблемы и решения.}
%%     Обзорная статья. Можем попробовать успеть опубликовать в первом выпуске НТВ СПбГПУ 2018 года.
    
%%   \item Кирпич нужно подготовить к концу декабря.
%%   %% \item Новый вариант названия ``Слабые модели памяти для языка C/C++''.
%% \end{enumerate}

{\reliability}
%% {\textbf{\underline{Степень достоверности и апробация результатов.}}}
Достоверность и обоснованность результатов исследования
обеспечивается формальными доказательствами, а также инженерными экспериментами.
Полученные результаты согласуются с результатами, установленными другими авторами.
%% {\reliability} полученных результатов 

%% {\probation}
Основные результаты работы докладывались~на следующих научных конференциях и семинарах:
внутренний семинар ННГУ им. Лобачевского (13 декабря 2017, Нижний Новгород, Россия),
открытая конференция ИСП РАН им. В.П. Иванникова (30 ноября--1 декабря  2017, РАН, Москва, Россия),
семинар ``Технологии разработки и анализа программ'' (16 ноября 2017, ИСП РАН, Москва, Россия),
внутренние семинары School of Computing of the University of Kent (август 2017, Кентербери, Великобритания),
внутренние семинары Department of Computer Science of UCL (август 2017, Лондон, Великобритания),
внутренние семинары MPI-SWS (май 2017, Кайзерслаутерн, Германия),
The European Conference on Object-Oriented Programming (ECOOP, 18--23 июня 2017, Барселона, Испания),
конференция ``Языки программирования и компиляторы'' (PLC, 3--5 апреля 2017, Ростов-на-Дону, Россия),
Verified Trustworthy Software Systems workshop (VTSS, 4-7 апреля 2016, Лондон, Великобритания),
POPL 2016 Student Research Competition (21 января 2016, Санкт-Петербург, Флорида, США).

%% {\contribution} Автор принимал активное участие \ldots

%% \publications\ Основные результаты по теме диссертации изложены в ХХ печатных изданиях~\cite{Sokolov,Gaidaenko,Lermontov,Management},
%% Х из которых изданы в журналах, рекомендованных ВАК~\cite{Sokolov,Gaidaenko}, 
%% ХХ --- в тезисах докладов~\cite{Lermontov,Management}.

\ifnumequal{\value{bibliosel}}{0}{% Встроенная реализация с загрузкой файла через движок bibtex8
    {\publications}
        Основные результаты по теме диссертации изложены в пяти %\arabic{citeauthor}
        печатных работах, зарегистрированных в РИНЦ.
        Из них две статьи изданы в журналах из \vakJournals.
        Одна статья опубликована в издании, входящем в базы цитирования SCOPUS и Web of Science.
        
        Личный вклад автора в публикациях, выполненных с соавторами, распределён следующим образом.
        В статьях \cite{Podkopaev-al:NTV17,Podkopaev-al:ISPRAS17}  автор предложил  схему
        доказательства корректности компиляции для аксиоматических семантик и выполнил само доказательство для модели ARMv8.3;
        соавторы участвовали в обсуждении основных идей доказательства.
        В работах \cite{Podkopaev-al:ECOOP17, Podkopaev-al:PLC17}
        автор выполнил формализацию семантики ARMv8 POP и доказал корректность компиляции методом симуляции;
        соавторы участвовали в обсуждении идей доказательства и редактировали тексты статей.
        В работе \cite{Podkopaev-al:CoRR16} личный вклад автора заключается в предложении идеи меток времени и фронтов как способа
        операционного задания модели памяти, а также в создании компонентного метода задания семантики и реализации интерпретатора;
        соавторы предложили синтаксический способ обработки отложенных операций.
}{% Реализация пакетом biblatex через движок biber
%Сделана отдельная секция, чтобы не отображались в списке цитированных материалов
    \begin{refsection}[vak,papers,conf]% Подсчет и нумерация авторских работ. Засчитываются только те, которые были прописаны внутри \nocite{}.
        %Чтобы сменить порядок разделов в сгрупированном списке литературы необходимо перетасовать следующие три строчки, а также команды в разделе \newcommand*{\insertbiblioauthorgrouped} в файле biblio/biblatex.tex
        \printbibliography[heading=countauthorvak, env=countauthorvak, keyword=biblioauthorvak, section=1]%
        \printbibliography[heading=countauthorconf, env=countauthorconf, keyword=biblioauthorconf, section=1]%
        \printbibliography[heading=countauthornotvak, env=countauthornotvak, keyword=biblioauthornotvak, section=1]%
        \printbibliography[heading=countauthor, env=countauthor, keyword=biblioauthor, section=1]%
        \nocite{%Порядок перечисления в этом блоке определяет порядок вывода в списке публикаций автора
                Podkopaev-al:NTV17,
                Podkopaev-al:ISPRAS17,
                %% vakbib1,vakbib2,%
                %% confbib1,confbib2,%
                Podkopaev-al:ECOOP17,
                Podkopaev-al:PLC17, Podkopaev-al:CoRR16,
                %% bib1,bib2,%
        }%
        {\publications}
        Основные результаты по теме диссертации изложены в пяти %\arabic{citeauthor}
        печатных работах, зарегистрированных в РИНЦ.
        Из них две статьи изданы в журналах из \vakJournals.
        Одна статья опубликована в издании, входящем в базы цитирования Scopus и Web of Science.
        
        Личный вклад автора в публикациях, выполненных с соавторами, распределён следующим образом.
        В статьях \cite{Podkopaev-al:NTV17,Podkopaev-al:ISPRAS17}  автор предложил  схему
        доказательства корректности компиляции для аксиоматических семантик и выполнил само доказательство для модели ARMv8.3;
        соавторы участвовали в обсуждении основных идей доказательства.
        В работах \cite{Podkopaev-al:ECOOP17, Podkopaev-al:PLC17}
        автор выполнил формализацию семантики ARMv8 POP и доказал корректность компиляции методом симуляции;
        соавторы участвовали в обсуждении идей доказательства и редактировали текст статей.
        В работе \cite{Podkopaev-al:CoRR16} личный вклад автора заключается в предложении идеи меток времени и фронтов как способа
        операционного задания модели памяти, а также в создании компонентного метода задания семантики и реализации интерпретатора;
        соавторы предложили синтаксический способ обработки отложенных операций.
    \end{refsection}
    \begin{refsection}[vak,papers,conf]%Блок, позволяющий отобрать из всех работ автора наиболее значимые, и только их вывести в автореферате, но считать в блоке выше общее число работ
        \printbibliography[heading=countauthorvak, env=countauthorvak, keyword=biblioauthorvak, section=2]%
        \printbibliography[heading=countauthornotvak, env=countauthornotvak, keyword=biblioauthornotvak, section=2]%
        \printbibliography[heading=countauthorconf, env=countauthorconf, keyword=biblioauthorconf, section=2]%
        \printbibliography[heading=countauthor, env=countauthor, keyword=biblioauthor, section=2]%
        \nocite{Podkopaev-al:NTV17}%vak
        \nocite{Podkopaev-al:ISPRAS17}%vak
        \nocite{Podkopaev-al:ECOOP17}%conf
        \nocite{Podkopaev-al:PLC17,Podkopaev-al:CoRR16}%notvak
    \end{refsection}
}
%% При использовании пакета \verb!biblatex! для автоматического подсчёта
%% количества публикаций автора по теме диссертации, необходимо
%% их здесь перечислить с использованием команды \verb!\nocite!.
