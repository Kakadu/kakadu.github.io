%% \newcommand{\ifext}[2]{\ifdefined\extflag{#1}\else{#2}\fi}
%% \newcommand{\tick}{\checkmark}%
%% \newcommand{\tickP}{\checkmark}%
%% \newcommand{\tickPP}{\checkmark}%
%% \newcommand{\xmark}{\text{\ding{55}}}
%% \newcommand{\fail}{\xmark}%
%% \newcommand\Cf{\mathit{Prog}}%\textsf{Prog}

\section*{Общая характеристика работы}

\newcommand{\actuality}{\underline{\textbf{\actualityTXT}}}
\newcommand{\progress}{\underline{\textbf{\progressTXT}}}
\newcommand{\aim}{\underline{{\textbf\aimTXT}}}
\newcommand{\tasks}{\underline{\textbf{\tasksTXT}}}
\newcommand{\novelty}{\underline{\textbf{\noveltyTXT}}}
\newcommand{\influence}{\underline{\textbf{\influenceTXT}}}
\newcommand{\methods}{\underline{\textbf{\methodsTXT}}}
\newcommand{\defpositions}{\underline{\textbf{\defpositionsTXT}}}
\newcommand{\reliability}{\underline{\textbf{\reliabilityTXT}}}
\newcommand{\probation}{\underline{\textbf{\probationTXT}}}
\newcommand{\contribution}{\underline{\textbf{\contributionTXT}}}
\newcommand{\publications}{\underline{\textbf{\publicationsTXT}}}

\newcommand{\ccite}[1]{}
\newcommand{\cscite}[1]{}
\input{common/characteristic} % Характеристика работы по структуре во введении и в автореферате не отличается (ГОСТ Р 7.0.11, пункты 5.3.1 и 9.2.1), потому её загружаем из одного и того же внешнего файла, предварительно задав форму выделения некоторым параметрам

%Диссертационная работа была выполнена при поддержке грантов ...

% TODO
\underline{\textbf{Объем и структура работы.}}
% Диссертация состоит из~введения, четырех глав, заключения и~приложения. Полный объем диссертации \textbf{190}~страниц текста с~\textbf{29}~рисунками и~\textbf{4}~таблицами. Список литературы содержит \textbf{109}~наименований.

%\newpage
\section*{Содержание работы}
\begin{comment}
Во \underline{\textbf{введении}} обосновывается актуальность
исследований, выполненных в рамках данной диссертационной работы,
приводится краткий обзор научной литературы по изучаемой проблеме,
формулируется цель, ставятся задачи работы, излагается научная новизна
и практическая значимость представленного исследования.

\underline{\textbf{Первая глава}} посвящена обзору области исследования.
Рассматриваются требования к реалистичным моделями памяти
языков программирования, предъявляемые через призму наблюдаемых сценариев поведения многопоточных программ,
применяемых компиляторами оптимизаций, а также моделей памяти процессорных архитектур.
Описывается модель памяти C/C++11. Рассматриваются проблемы модели C/C++11, в том числе
проблема ``значений из воздуха''. Приводится описание существующих слабых моделей памяти без ``значений из воздуха'', в частности, обещающей модели.
На основе выполненного обзора делаются следующие выводы.
\begin{itemize}
  \item Модель памяти промышленного языка программирования должна удовлетворять, как минимум, трём критериям.
    Во-первых, должна существовать корректная схема компиляции в модель целевой процессорной
    архитектуры.
    Во-вторых, основные компиляторные оптимизации должны быть корректны в рамках модели.
    В-третьих, у модели должна отсутствовать проблема ``значений из воздуха''.
  \item При разработке новой модели памяти языка программирования нужно доказывать корректность эффективной компиляции
     в модели памяти целевых процессорных архитектур.
  \item Существующие модели памяти промышленных языков программирования не удовлетворяют всем приведённым выше
    критериям.
  \item Требуется разработать операционную модель памяти с синтаксисом модели C/C++11, которая
    не имеет проблемы ``значений из воздуха''.
  %% \item Обещающая модель памяти является перспективной альтернативой существующей модели памяти C/C++.
\end{itemize}

\underline{\textbf{Вторая глава}} посвящена описанию предложенной в диссертации операционной  модели памяти $\OpCpp$ для C/С++. Модель представлена в виде операционной семантики малого шага с помощью редукционных
контекстов. 
Основное отличие слабых моделей памяти от модели последовательной консистентности заключается в том, что
первые не гарантируют для локации в памяти единственность значения, которое может быть прочитано
в каждый конкретный момент времени.
Так, например, следующая программа может завершиться с
результатом $[a = 1, b = 0]$, хотя, казалось бы, $a = 1$ гарантирует, что
в локацию $d$ уже записано новое значение $239$:
\[
\begin{array}{c}
[f] := 0; [d] := 0; \\
\begin{array}{l||l}
  {} [d] := 239; & a := [f]; \\
  {} [f] := 1   & b := [d] \\
\end{array}
\end{array}
\]
Как следствие, оперативная память (далее просто ``память'') в рамках слабых моделей памяти не может быть представлена как функция из локации в значения.

Память в модели $\OpCpp$ представляется как множество \emph{сообщений}. Каждое сообщение содержит целевую локацию, записываемое значение и
\emph{метку времени} --- натуральное число, которое определяет полный порядок на сообщениях, относящихся к одной локации.
Последнее нужно для того, чтобы гарантировать последовательную консистентность для программ, оперирующих только над одной локацией --- эту гарантию
предоставляют большинство слабых моделей памяти, в том числе модель C/C++11.
При выполнении инструкции чтения из некоторой локации поток может недетерминировано выбрать сообщение, относящееся к этой локации, и выполнить из него чтение.
чтение из него.

%% Представление памяти как множества сообщений позволяет симулировать исполнение приведенной выше программы, которое заканчивается результатом
%% $a = 1, b = 0$, следующим образом. После выполнения Сначала левый поток выполняет 

Недетерминированность чтения из локации ограничена гарантией, которую также предоставляет модель C/C++11:
после того, как поток прочитал или записал сообщение в локацию $x$ с меткой времени $t$, он (поток) больше не может читать из сообщений
с меткой времени, которая меньше $t$. Для реализации данного ограничения в модели $\OpCpp$ у каждого потока есть т.н. \emph{базовый фронт}
(current view, current viewfront) --- функция из локаций в метки времени, определяющая осведомленность потока о сообщениях в памяти.

Некоторые программы имеют слабые сценарии поведения, разрешенные моделью C/C++11, которые не могут быть смоделированы только недетерминированной
памятью, а также требуют исполнения инструкций не по порядку. Например, следующая программа может завершиться с
результатом $[a = 1, b = 1]$ в модели C/C++11:
\[
\begin{array}{c}
[x] := 0; [y] := 0; \\
\begin{array}{l||l}
  {} a := [x]; & b := [y]; \\
  {} [y] := 1 & [x] := 1 \\
\end{array}
\end{array}
\]
Для представления таких сценариев поведения в модели $\OpCpp$ у каждого потока есть \emph{буфер отложенных операций}. Так, модель
позволяет потоку в каждый момент отложить текущую операцию вместо её выполнения.
С помощью этого механизма модель $\OpCpp$ может исполнить приведенную выше программу и получить результат $a = 1, b = 1$ следующим образом.
Сначала левый поток откладывает чтение из локации $x$ и выполняет запись в $y$. После этого правый поток читает из вновь добавленного
сообщения и записывает $1$ в $x$. Далее левый поток исполняет отложенное чтение из сообщения, добавленного правым потоком, и получает
результат $[a = 1, b = 1]$.

Для поддержки высвобождающих (release) барьеров и записей, а также приобретающих (acquire) барьеров и чтений
модель $\OpCpp$ использует дополнительные фронты --- высвобождающий и приобретающий для каждого потока,
а также фронт сообщений для каждого сообщения в памяти. Для поддержки чтений с модификатором доступа
consume модель использует динамическую пометку инструкций, зависимых от consume-чтения.

%% Рассмотрим следующую программу, в которой левый поток передает сообщение через локацию $d$ в правый поток:
%% \[
%% \begin{array}{c}
%% [f] := 0; [d] := 0; \\
%% \begin{array}{l||l}
%%   {} [d] := 239; & a := [f]; \\
%%   {} [f] := 1;   & b := [d]; \\
%% \end{array}
%% \end{array}
%% \]
%% Здесь локация $f$ используется как индекс того, что левый поток уже записал нужные данные в локацию $d$.
%% В рамках модели последовательной консистентности гарантируется, что если $a = 1$, т.е. правый поток
%% ``увидел'' запись в $f$, то дальше он прочитает из записи в $d$, сделанной левым потоком, и в результате $b$ будет
%% равняться $239$. Это гарантируется тем, что 

Для предложенной модели был реализован интерпретатор на языке Racket с помощью библиотеки описания редукционных
семантик PLT/Redex. Код проекта доступен по адресу \url{github.com/anlun/OperationalSemanticsC11}.

Апробация предложенной семантики была выполнена на наборе, состоящем более чем из 40 тестов (litmus tests), взятых из  тематической литературы, а также 
на алгоритме RCU (Read-Copy-Update). Поведение модели $\OpCpp$ совпадает с поведением модели C/C++11 на большинстве этих тестов.
Отличие наблюдается на двух следующих категориях тестов. Первая категория --- это программы, которые имеют исполнения со
``значениями из воздуха'' в рамках модели C/C++11. Для таких тестов модель $\OpCpp$ не выдает исполнения со ``значениями из воздуха'',
что является её положительным свойством. Вторая категория --- это программы, в которых существуют антизависимости по управлению,
адресу или значению, ведущие к инструкциям записи. На таких программах $\OpCpp$ не способна получить все возможные в рамках C/C++11
исполнения, поскольку выполнение инструкций не по порядку в $\OpCpp$ реализовано синтаксическим способом. Этот недостаток модели не позволяет ей поддержать все необходимые компиляторные оптимизации.

Одновременно с моделью памяти $\OpCpp$ исследователями J. Kang, C.-K. Hur, O. Lahav, V. Vafeiadis и D. Dreyer была представлена обещающая модель
памяти, которая очень близка $\OpCpp$, но использует другой механизм для выполнения инструкций не по порядку.
Этот механизм позволяет поддержать больше компиляторных оптимизаций, чем модель $\OpCpp$.
Из-за данного преимущества диссертант принял решение продолжить свою исследовательскую работу в рамках обещающей модели.

В \underline{\textbf{третьей главе}} приводится описание обещающая модель памяти и операционной модели ARMv8 POP,
а также представлено доказательство
корректности компиляции из существенного подмножества обещающей модели памяти в модель ARMv8 POP.
%% В конце главы приводятся рассуждения о том, как нужно доработать доказательство, чтобы покрыть всю обещающую модель.

Обещающая модель памяти является операционной моделью для синтаксиса модели C/C++11.
Она использует те же базовые понятия, что и предложенная диссертантом модель $\OpCpp$,
метки времени и фронты, однако вместо механизма откладывания выполнения инструкций она,
в соответствии со своим названием, использует механизм \emph{обещаний}. Так, в каждый момент исполнения поток
обещающей модели памяти может совершить одно из двух действий: либо выполнить следующую инструкцию,
либо пообещать сделать запись в локацию. Последнее может быть выполнено вне зависимости от того, какая
инструкция является следующей.
Если поток выбирает пообещать сделать запись в локацию, то он добавляет соответствующее сообщение в память,
делая это сообщение видимым для других потоков. Далее в ходе исполнения поток должен будет выполнить соответствующую инструкцию записи, таким образом выполняя сделанное ранее обещание.

Для того, чтобы запретить ``значения из воздуха'', после каждого исполненного шага каждый поток должен выполнить
т.н. \emph{сертификацию} --- предъявить, что он может быть локально исполнен таким образом, что
выполнит все оставшиеся обещания. Известно, что задача сертификации является алгоритмически неразрешимой для языков,
 полных по Тьюрингу. Следовательно, для
обещающей модели невозможно разработать интерпретатор, что является её недостатком по сравнению с представленной в
диссертации моделью $\OpCpp$.

Несмотря на этот недостаток, обещающая модель обладает рядом существенных достоинств.
В частности, обещающая модель не имеет проблемы ``значений из воздуха'', что делает возможным для неё разработать
выразительную программную логику. Также для модели была доказана корректность существенного класса компиляторных
оптимизаций и корректность эффективной компиляции в модели памяти процессоров x86 и Power.

Открытой проблемой является доказательство корректности компиляции из обещающей модели памяти в модели памяти архитектуры
ARM, которая, наравне с x86 и Power, является одной из наиболее распространённых процессорных архитектур на данный момент.

Здесь и далее под корректностью компиляции понимается следующее утверждение.\\
\textbf{Определение.} Для языков $L$ и $L'$ с моделями памяти $M$ и $M'$ соответственно схема компиляции $\textsf{compile} : L \rightarrow L'$
называется \emph{корректной}, если выполняется следующее условие:
\[ \forall Prog \in L. \; \sembr{\textsf{compile}(Prog)}_{M'} \subseteq \sembr{Prog}_{M}, \]
где $\sembr{Prog}_{M}$ --- множество результатов сценариев поведения программы $Prog$ в модели памяти $M$.
В доказательствах корректности компиляции в ARMv8 POP и ARMv8.3 результатом сценария поведения считается
финальное состояние памяти.

Рассмотренное подмножество обещающей модели памяти ($\Promise$) состоит из расслабленных (relaxed, rlx) записей и чтений,
а также высвобождающих (release, rel) и приобретающих (acquire, acq) барьеров памяти. При этом подразумевается следующая
схема компиляции:
\[
  \begin{array}{c@{~~}@{~~}l@{~~}|@{~~}l@{~~}|@{~~}l@{~~}|@{~~}l}
    \textbf{Promise:}   & [x]_{\textsf{rlx}} := \; a & a := [x]_{\textsf{rlx}}  &  \acqFence & \relFence \\[2pt]
    \textbf{ARMv8 POP:} & \writeInst{x}{a}    & \readInst{a}{x}  &  \dmbLD & \dmbSY \\
  \end{array}
\]
Первый и второй столбцы подразумевают, что расслабленные операции записи и чтения из языка, на котором определена обещающая модель,
переходят в обычные операции записи и чтения в терминах ARMv8-ассемблера, а приобретающий и высвобождающий барьеры --- в барьер
по чтению и в полный барьер. Такая схема компиляции считается эффективной и применяется в компиляторах GCC и LLVM.
Поскольку схема компиляции в данном случае является биекцией, то далее в этой главе предполагается, что язык задания обещающей и ARMv8 POP
моделей совпадает.

Основной результат главы %про корректность компиляции из обещающей семантики в ARMv8 POP
сформулирован следующим образом. \\
\textbf{Теорема.} Для любой программы $\Cf$ на языке задания модели и её сценария поведения в модели ARMv8 POP существует
такой сценарий поведения $\Cf$ в обещающей модели, что финальное состояние памяти в сценариях поведения совпадает.

В рамках доказательства теоремы по сценарию поведения программы в модели ARMv8 POP строится сценарий поведения в обещающей модели.
Поскольку обе модели заданы операционным способом, то существуют две абстрактные машины, которые представляют данные модели.
Обычно для решения задачи построения сценария поведения одной машины по сценарию другой используют технику симуляции,
которая является специальной формой индукции. В рамках данной техники вводится отношение симуляции,
которое связывает состояния машин, и доказываются две следующие леммы:
отношение симуляции связывает начальные состояния машин (база индукции);
для любого шага симулируемой машины существует ноль или более шагов симулирующей машины, после выполнения которых 
новые состояния машин опять связаны отношением симуляции (индукционный переход).

%% Модель памяти ARMv8 POP --- операционная модель памяти для архитектуры ARMv8.0, предложенная в 2016 г.
%% Данная модель определена в терминах, достаточно близких к физической реализации архитектуры ARM.
%% Абстрактная машина, которая реализует модель ARMv8 POP, состоит из двух компонент: подсистем памяти и управления.

%% Подсистема памяти является иерархической структурой \emph{буферов}, каждый из которых является списком запросов к подсистеме.
%% Запросом, при этом, может быть чтение из локации, запись в локацию или барьер памяти.
%% Идейно подсистема памяти похожа на иерархическую систему кэшей, используемую в современных процессорах.
%% Так, подсистема управления может послать запрос в подсистему хранения. В таком случае запрос сначала попадает в буфер, который локален
%% для соответствующего потока, потом он может быть передан следующему в иерархии буферу, который является общий для некоторого
%% набора потоков, и так далее, пока запрос не попадёт в основную память или, если это запрос на чтение, не будет
%% удовлетворён из сообщения.

%% Подсистема управления выполняет программу каждого потока. Шагом исполнения программы потока является полное или частичное исполнение
%% некоторой инструкции из потока. Например, исполнение инструкции чтения выполняется в три шага --- отправка запроса в подсистему памяти,
%% получение ответа от подсистемы памяти и завершение исполнения инструкции чтения. При этом между упомянутыми шагами исполнения могут
%% исполняться другие инструкции, поскольку подсистема управления может исполнять инструкции не по порядку и спекулятивно.

В доказательстве индукционного перехода сложным является то, что между моделями имеется два существенных различия.
Во-первых, обещающая модель может исполнять не по порядку только инструкции записи, 
в то время как модель ARMv8 POP может исполнять инструкции в несколько шагов, не по порядку и спекулятивно.
Во-вторых, в обещающей модели в тот момент, когда сообщение попадает в память, этому сообщению присваивается некоторая
метка времени, которая служит его порядковым номером в множестве сообщений, относящихся к той же локации. В модели ARMv8 POP
меток времени нет и порядок сообщений одной локации определяется не сразу после того, как
сообщения попадут в её подсистему памяти и станут видимыми для других потоков.

Для того, чтобы обойти первое различие, автор использовал технику ``запаздывающей'' симуляции. В рамках данной техники отношение
симуляции представляется как объединение двух взаимоисключающих отношений, например, $A$ и $B$. Далее индукционный
переход формулируется следующим образом. Если состояние симулируемой машины $x$ связано с состояние симулирующей машины $y$ отношением $A$,
т.е. выполняется $(x,y) \in A$, то для любого состояния $x'$, в которое может перейти симулируемая машина, выполняется $(x', y) \in A \cup B$.
С другой стороны, если $(x, y) \in B$, то существует состояние $y'$, в которое может перейти симулирующая машина, что $(x, y') \in A \cup B$.
Тогда при условии, что не существует такой бесконечной цепочки $\{y'_i\}_{i \in \mathbb{N}}$, что $y'_i$ переходит $y'_{i+1}$ и $(x, y'_i) \in B$ для всех $i$,
из нового варианта индукционного перехода следует изначальное утверждение симуляции.

В доказательстве теоремы отношение $A$ символизирует, что обещающая машина ждёт, пока ARM-машина выполнит действие, которое обещающая
машина может повторить, а отношение $B$ означает, что обещающая машина может симулировать несколько действий, уже выполненных ARM-машиной.

Для того, чтобы снять второе различие между обещающей и ARMv8 POP моделями, в доказательстве определяется ограниченная версия ARM-машины,
которая добавляет метки времени к сообщениям записи в подсистеме памяти, тем самым определяя порядок на сообщениях к одной локации
раньше, чем это делает обычная ARMv8 POP модель. Это изменение также добавляет дополнительные ограничения на сценарии поведения ARM-машины.
Тем не менее, автор приводит доказательство того, что новая модель эквивалентна исходной, что позволяет свести доказательство теоремы 
к доказательству корректности компиляции из обещающей модели в модифицированную ARMv8 POP модель.

В \underline{\textbf{четвертой главе}} обсуждается аксиоматическая модель памяти ARMv8.3.
Приводятся рассуждения о том, почему метод доказательства корректности компиляции из
обещающей модели памяти, использованный её авторами для аксиоматических моделей архитектур x86 и Power,
не подходит для модели ARMv8.3. Далее приводится доказательство корректности компиляции из обещающей модели
памяти в подмножество модели ARMv8.3. Доказательство основано на построении операционной семантики обхода аксиоматических сценариев
поведения программ в модели ARMv8.3.
%% В конце главы приводятся рассуждения о применимости использованного подхода для других аксиоматических моделей.

В рамках аксиоматической (или декларативной) модели памяти сценарий поведения программы представляется в виде графа, в котором вершинами
являются \emph{события} (операции над памятью), а ребрами --- различные отношения на событиях, такие как программный
порядок, отношение ``читает из'' и др. При этом граф считается согласованным с моделью, если выполняются \emph{аксиомы} модели,
которые обычно формулируются как наличие некоторого полного порядка на подмножестве событий или отсутствие  в графе путей определённого
типа.

При доказательстве корректности компиляции из обещающей модели в аксиоматическую техника симуляции напрямую
неприменима, поскольку сценарий поведения в аксиоматической модели не является последовательностью шагов исполнения некоторой абстрактной машины.
Поэтому в доказательстве корректности компиляции в 
модели x86 и Power авторы использовали другой метод. Этот метод состоит из двух частей.
Во-первых, доказывается, что модели x86 и Power могут быть представлены как набор программных оптимизаций поверх
более простых моделей. Эти оптимизации являются доказано корректными в рамках обещающей модели, из чего следует,
что доказательство корректности компиляции может быть сведено к аналогичному доказательству для более простых моделей.
Далее показывается, что эти более простые модели могут быть симулированы моделью, которая является аксиоматическим аналогом
обещающей модели без механизма обещаний.

Автору работы не удалось применить такой подход для модели ARMv8.3, поскольку эта модель не представима как набор тех же
оптимизаций над упрощенной моделью. Поэтому был разработан альтернативный подход,
который заключается в построении операционной семантики обхода аксиоматических сценариев поведения, которая может быть
непосредственно симулирована обещающей моделью.

\emph{Обходом} в диссертационном исследовании называется последовательность переходов между \emph{конфигурациями исполнения} ---
упорядоченными парами подмножеств вершин сценария поведения $\tup{C, \IssuedSet}$.
Подмножество $C$ называется \emph{множеством покрытых событий}, а подмножество $\IssuedSet$ --- \emph{множеством выпущенных событий};
элементы этих подмножеств называются \emph{покрытыми} и \emph{выпущенными} соответственно.

Конфигурация обхода называется \emph{корректной}, если выполняются следующие условия.
\begin{itemize}
  \item Множество покрытых событий префикс-замкнуто по отношению программного порядка.
  \item Множество выпущенных событий содержит только события записи.
  \item Если событие записи покрыто, то оно также является выпущенным.
\end{itemize}
При доказательстве симуляции обещающей моделью обхода покрытые события будут соответствовать инструкциям, выполненным
обещающей машиной, а выпущенные события --- сообщениям в памяти обещающей машины.

Шаги обхода задаются следующим образом:
\begin{mathpar}
\inferrule*{
    a \in \nextset(G, C) \cap \coverable(G, C, \IssuedSet) 
}{
    G \vdash 
    \tup{C, \IssuedSet} \travConfigStep \tup{C \cup \{a\}, \IssuedSet}
} \and
\inferrule*{
    w \in \issuable(G, C, \IssuedSet) \setminus \IssuedSet 
    }{
    G \vdash
    \tup{C, \IssuedSet} \travConfigStep \tup{C, \IssuedSet \cup \{w\}}
}
\end{mathpar}
Здесь первое правило соответствует покрытию события $a$, а второе --- выпуску события $w$; $\nextset(G, C)$ --- обозначает множество событий,
непосредственно следующих в отношении программного порядка за покрытыми; $\coverable(G, C, I)$ и $\issuable(G, C, I)$ --- это
события, покрываемые и выпускаемые в текущей конфигурации, которые определены в соответствии с требованиями обещающей модели
к исполнению инструкции и обещанию сообщения соответственно.

Далее автор работы приводит доказательство следующей теоремы о полноте обхода. \\
\textbf{Теорема.} Для любого корректного сценария поведения $G$ в модели ARMv8.3 существует обход
$\tup{W^{\textrm{init}}, W^{\textrm{init}}} \travConfigStep^{*} \tup{E, W}$,
где $W^{\textrm{init}}$ --- множество инициализирующих записей сценария $G$, $E$ --- все события сценария $G$,
$W$ --- все события записи сценария $G$.

Используя данную теорему для построения операционного исполнения программы в модели ARMv8.3,
автор работы доказывает, что обещающая модель может симулировать сценарии поведения модели ARMv8.3.

%% Модель ARMv8.3 является аксиоматической, что не позволяет напрямую использовать технику симуляции для доказательства
%% корректности компиляции из обещающей модели. 

%% В \underline{\textbf{главе}}
%% Обсуждается структура доказательства корректности компиляции. Доказательство основано на симуляции обещающей моделью
%% памяти операционной семантики обхода исполнения программ в модели ARMv8.3.

В \underline{\textbf{заключении}} приведены основные результаты работы.
\input{common/concl}

%%  картинку можно добавить так:
%% \begin{figure}[ht] 
%%   \center
%%   \includegraphics [scale=0.27] {latex}
%%   \caption{Подпись к картинке.} 
%%   \label{img:latex}
%% \end{figure}

%% Формулы в строку без номера добавляются так:
%% \[ 
%%   \lambda_{T_s} = K_x\frac{d{x}}{d{T_s}}, \qquad
%%   \lambda_{q_s} = K_x\frac{d{x}}{d{q_s}},
%% \]



%\newpage
%% При использовании пакета \verb!biblatex! список публикаций автора по теме
%% диссертации формируется в разделе <<\publications>>\ файла
%% \verb!../common/characteristic.tex!  при помощи команды \verb!\nocite! 

%% \ifdefmacro{\microtypesetup}{\microtypesetup{protrusion=false}}{} % не рекомендуется применять пакет микротипографики к автоматически генерируемому списку литературы
%% \ifnumequal{\value{bibliosel}}{0}{% Встроенная реализация с загрузкой файла через движок bibtex8
%%   \renewcommand{\bibname}{\large \authorbibtitle}
%%   \nocite{*}
%%   \insertbiblioauthor           % Подключаем Bib-базы
%%   %\insertbiblioother   % !!! bibtex не умеет работать с несколькими библиографиями !!!
%% }{% Реализация пакетом biblatex через движок biber
%%   %% \insertbiblioauthor           % Вывод всех работ автора
%%  \insertbiblioauthorgrouped    % Вывод всех работ автора, сгруппированных по источникам
%% %  \insertbiblioauthorimportant  % Вывод наиболее значимых работ автора (определяется в файле characteristic во второй section)
%%   \insertbiblioother            % Вывод списка литературы, на которую ссылались в тексте автореферата
%% }
%% \ifdefmacro{\microtypesetup}{\microtypesetup{protrusion=true}}{}

\end{comment}

\begin{comment}

\newcounter{firstbib}

\section*{\LARGE Публикации автора по теме диссертации}

Ниже приведён перечень публикаций, где были представлены основные результаты данной  диссертационной работы. \\

\renewcommand{\bibsection}{\noindent \textbf{\refname}}

\renewcommand{\refname}{Статьи из \vakJournals}
\begin{thebibliography}{99}
\bibitem{Podkopaev-al:NTV17} Подкопаев, А. В. О корректности компиляции подмножества обещающей модели памяти в аксиоматическую модель ARMv8.3 / А.В. Подкопаев, О. Лахав, В. Вафеядис // Научно-технические ведомости СПбГПУ. Информатика, Телекоммуникации. Управление. ---~2017. ---~Т.~10, \textnumero~4. ---~C.~51--69.
\bibitem{Podkopaev-al:ISPRAS17} Подкопаев, А. В. Обещающая компиляция в ARMv8.3 / А.В. Подкопаев, О. Лахав, В. Вафеядис // Труды ИСП РАН. ---~2017. ---~Т.~29, \textnumero~5. ---~C.~149--164.
\setcounter{firstbib}{\value{enumiv}}
\end{thebibliography}

\renewcommand{\refname}{Статьи в изданиях, входящих в базы цитирования Web of Science и Scopus}
\begin{thebibliography}{99}
\setcounter{enumiv}{\value{firstbib}}
\bibitem{Podkopaev-al:ECOOP17} Podkopaev, A. Promising compilation to ARMv8 POP / A. Podkopaev, O. Lahav, V. Vafeiadis // 31st European Conference on Object-Oriented Programming (ECOOP 17), Leibniz International Proceedings in Informatics (LIPIcs).  ---~2017. ---~P.~22:1--22:28.
\setcounter{firstbib}{\value{enumiv}}
\end{thebibliography}

\renewcommand{\refname}{Статьи в других изданиях}
\begin{thebibliography}{99}
\setcounter{enumiv}{\value{firstbib}}
\bibitem{Podkopaev-al:PLC17} Подкопаев, А. В. Обещающая компиляция в ARMv8 / А.В. Подкопаев, О. Лахав, В. Вафеядис // Языки программирования и компиляторы. Труды конференции. Ростов-на-Дону, Россия. ---~2017. ---~C.~223--226.
\bibitem{Podkopaev-al:CoRR16} Podkopaev, A. Operational Aspects of {C/C++} Concurrency / A. Podkopaev, I. Sergey, A. Nanevski
  [Электронный ресурс]. --- URL: \url{http://arxiv.org/abs/1606.01400} (дата обращения: 14.11.2017).
\end{thebibliography}
\end{comment}