\newcommand\exscore[3]{#1/#2/#3}


\begin{frame}{Общие замечания по упражнениям}
Если явно не оговорено иное, то...
\vspace{3em}

Предлагается реализовать устойчивую структуру данных на вашем любимом языке обывательском (C\#, C, etc), и на каком-нибудь функциональном языке (OCaml,Haskell,F\#, Scala 3), а затем сравнить размер/сложность двух реализаций.

Ожидаются реализации в виде чистых функций (ну может понадобится присваивание для эмуляции мемоизации, в остальном -- едва ли)
\vspace{2em}

Обозначение \exscore{A}{B}{C} говорит, что за решение на обывательском языке будет начислено A баллов, на классическом функциональном B; С баллов начисляется дополнительно, если обучающийся может сравнить реализации, указать на преимущества и недостатки одной и второй, и т.д.
\end{frame}



\begin{frame}[allowframebreaks]{Упражнения на ленивость}
\begin{exercise}[\exscore{?}{?}{?}]
По аналогии с вычислением последовательности фибоначчи, сделайте вычисление простых чисел решетом Эратосфена
\end{exercise}
\begin{exercise}[\exscore{?}{?}{?}]
Дан поток потоков чисел $xss$. Функция \mlinline{merge} должно объединить это всё в один поток чисел. \\
Ограничение: $\forall (i<\infty) \forall (j<\infty)\quad \big((xss[i][j]\equiv n)\quad \Longrightarrow \quad\exists (k<\infty)\quad (merge(xss)[k]\equiv n)\big)$
\end{exercise}

\begin{exercise}[\exscore{?}{?}{?}]
Дано дерево с числами только в листьях. Построить новое дерево, где все числа предыдущего дерева заменены на минимум от этих чисел. Ограничение: за один проход.
\begin{remark}
Крайне рекомендуется использовать язык, где все вычисления ленивы по умолчанию (например, Haskell)
\end{remark}
\end{exercise}
\end{frame}



\begin{frame}[allowframebreaks]{Упражнения на очереди}
\begin{exercise}[\exscore{?}{?}{?}]
Реализуйте чисто функциональную очередь
\end{exercise}

\begin{exercise}[\exscore{?}{?}{?}]
Реализуйте очередь банкира
\end{exercise}

\begin{exercise}[\exscore{?}{?}{?}]
Реализуйте очередь реального времени
\end{exercise}
\end{frame}



\begin{frame}[allowframebreaks]{Упражнения на очереди}
\begin{exercise}[\exscore{?}{?}{?}]
Реализуйте чисто функциональную очередь
\end{exercise}

\begin{exercise}[\exscore{?}{?}{?}]
Реализуйте очередь банкира
\end{exercise}

\begin{exercise}[\exscore{?}{?}{?}]
Реализуйте очередь реального времени
\end{exercise}
\end{frame}



\begin{frame}[allowframebreaks]{Упражнения на кучи}
\begin{exercise}[\exscore{?}{?}{?}]
Реализуйте левоориентированную кучу
\end{exercise}

\begin{exercise}[\exscore{?}{?}{?}]
Реализуйте weight-biased левоориентированную кучу (упражнение в книге 3.4)
\end{exercise}


\begin{exercise}[\exscore{?}{?}{?}]
Реализуйте биномиальную кучу, храня аннотации ранга реже (упражнение в книге 3.6)
\end{exercise}

\begin{exercise}[\exscore{?}{?}{?}]
Реализуйте биномиальную кучу с явным минимумом (упражнение в книге 3.7)
\end{exercise}

\end{frame}


\begin{frame}[allowframebreaks]{Упражнения на деревья}
\begin{exercise}[\exscore{?}{?}{?}]
Реализуйте красно-черное дерево, где балансировка делает меньше проверок (упражнение в книге 3.10)
\end{exercise}


\begin{exercise}[\exscore{?}{?}{?}]
Реализуйте префиксное дерево
\end{exercise}

\begin{exercise}[\exscore{?}{?}{?}]
Реализуйте HAMT
\end{exercise}

\end{frame}
