\documentclass[10pt, mathserif]{beamer}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\usepackage{listings}
\usepackage{color}
\usepackage{amssymb, amsmath}
\usepackage[all]{xy}
\usepackage{alltt}
\usepackage{pslatex}
\usepackage{epigraph}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{latexsym}
\usepackage{array}
\usepackage{changepage} % for adjustwidth
\usepackage{pstricks}
\usepackage{tikz}
\usepackage{pdfpages}
\usepackage{fontawesome}
\usepackage[scaled]{DejaVuSansMono}
\usepackage[T1]{fontenc}


\makeatletter
\newcolumntype{e}[1]{%--- Enumerated cells ---
   >{\minipage[t]{\linewidth}%
     \NoHyper%                Hyperref adds a vertical space
     \let\\\tabularnewline
     \enumerate
        \addtolength{\rightskip}{0pt plus 50pt}% for raggedright
        \setlength{\itemsep}{-\parsep}}%
   p{#1}%
   <{\@finalstrut\@arstrutbox\endenumerate
     \endNoHyper
     \endminipage}}

\newcolumntype{i}[1]{%--- Itemized cells ---
   >{\minipage[t]{\linewidth}%
        \let\\\tabularnewline
        \itemize
           \addtolength{\rightskip}{0pt plus 50pt}%
           \setlength{\itemsep}{-\parsep}}%
   p{#1}%
   <{\@finalstrut\@arstrutbox\enditemize\endminipage}}

\AtBeginDocument{%
    \@ifpackageloaded{hyperref}{}%
        {\let\NoHyper\relax\let\endNoHyper\relax}}
\makeatother

\definecolor{shadecolor}{gray}{1.00}
\definecolor{darkgray}{gray}{0.30}

\newcommand{\set}[1]{\{#1\}}
\newcommand{\angled}[1]{\langle {#1} \rangle}
\newcommand{\fib}{\rightarrow_{\mathit{fib}}}
\newcommand{\fibm}{\Rightarrow_{\mathit{fib}}}
\newcommand{\oo}[1]{{#1}^o}
\newcommand{\inml}[1]{\mbox{\lstinline{#1}}}

\setlength{\epigraphwidth}{.55\textwidth}

\definecolor{light-gray}{gray}{0.90}
\newcommand{\graybox}[1]{\colorbox{light-gray}{#1}}

\newcommand{\nredrule}[3]{
  \begin{array}{cl}
    \textsf{[{#1}]}&
    \begin{array}{c}
      #2 \\
      \hline
      \raisebox{-1pt}{\ensuremath{#3}}
    \end{array}
  \end{array}}

\newcommand{\naxiom}[2]{
  \begin{array}{cl}
    \textsf{[{#1}]} & \raisebox{-1pt}{\ensuremath{#2}}
  \end{array}}


\newcommand\Wider[2][3em]{%
\makebox[\linewidth][c]{%
  \begin{minipage}{\dimexpr\textwidth+#1\relax}
  \raggedright#2
  \end{minipage}
  }%
}
\newcommand*\bigcdot{\mathpalette\bigcdot@{.5}}

\lstdefinelanguage{ocaml}{
keywords={let, begin, end, in, match, type, and, fun, module,
function, try, with, class, object, method, of, rec, repeat, until,
corec, cofunction, lazy,
while, not, do, done, as, val, inherit, module, sig, @ type, struct,
if, then, else, open, virtual, new, fresh},
sensitive=true,
basicstyle=\small\ttfamily,
commentstyle=\scriptsize\rmfamily,
keywordstyle=\ttfamily\bfseries,
%identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
moredelim=**[is][\only<+>{\color{black}\lstset{style=highlight}}]{@}{@},
fontadjust=true,
literate={->}{{$\to$}}1
	 {<-}{{\leftarrow}}1
         {===}{{$\equiv$}}1
         {=/=}{{$\not\equiv$}}1
}

\lstdefinelanguage{scheme}{
keywords={define, conde, fresh},
sensitive=true,
basicstyle=\small,
commentstyle=\scriptsize\rmfamily,
keywordstyle=\ttfamily\bfseries,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,
literate={==}{{$\equiv$}}1
}

\lstset{
% basicstyle=\small,
basicstyle=\footnotesize, 
%identifierstyle=\ttfamily,
keywordstyle=\bfseries,
commentstyle=\scriptsize\rmfamily,
basewidth={0.5em,0.5em},
% fontadjust=true,
escapechar=!,
% escapeinside={(*@}{@*),
language=ocaml
}

\setbeamertemplate{footline}[frame number]
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{blocks}[rounded][shadow=true]
\beamertemplateballitem

\mode<presentation>{
  \usetheme{default}
}

\AtBeginSection[]
{
\begin{frame}{Table of Contents}
\tableofcontents[currentsection]
\end{frame}
}
\theoremstyle{definition}

\title{Copattern matching and first-class observations in OCaml, with a macro}
\author{Дмитрий Косарев}

\date{
  \vskip 2cm
  \small{
    \textbf{19 февраля, 2018}
  }
}


% some slides https://www.cl.cam.ac.uk/events/metaprog2016/codata-types-and-copattern-matching.pdf
% original paper https://hal.inria.fr/hal-01653261/document
\begin{document}
\begin{frame}
  \titlepage
\end{frame}


\section{Мотивация}

\begin{frame}{Спойлер?}
\begin{itemize}
 \item Расширим OCaml копаттернами, кофункциями и т.д.
\end{itemize}

\end{frame}

\begin{frame}{Мотивация}
 
\begin{itemize}
  \item Конечные
  \begin{itemize}
    \item Например: список, дерево, ...
    \item Индуктивные типы и pattern matching
  \end{itemize}
  \item Бесконечные
  \begin{itemize}
    \item Например: stream, бесконечное дерево, ...
    \item Коиндуктивные типы и copattern matching
  \end{itemize}
  \vspace{1in}
  \pause
  Copatterns: Programming Infinite Structures by Observations
  Abel, Pientka, Thibodeau and Setzer (POPL – 2013)
\end{itemize}

\end{frame}

% \begin{frame}[fragile]{Data types and Pattern matching}
% A data type is defined by its Constructors :
% 
% \begin{lstlisting}[language=ocaml,mathescape=true]
% type 'a list = Nil | Cons of 'a * 'a list
% 
% let ns: int list = Cons(1, Cons(2,Nil))
% \end{lstlisting}
% Deconstruct with pattern matching:
% \begin{lstlisting}[language=ocaml,mathescape=true]
% let rec map f xs =
%   match xs with
%   | Nil -> Nil
%   | Cons (x,xs) -> Cons(f x, map f xs)
% 
% map succ ns;;
% 
% $-$ : int list = Cons(2, Cons(3, Nil))
% \end{lstlisting}
% \end{frame}

\begin{frame}[fragile]{Объявление бесконечных значений}

\begin{lstlisting}[language=ocaml,mathescape=true]
let rec fib () = 0 :: 1 :: map2 (+) (fib ()) (tl (fib ()))
\end{lstlisting}
В call-be-value языках присутствуют проблемы.
\begin{lstlisting}[language=ocaml,mathescape=true]
type 'a lazy_list = C of 'a * 'a lazy_list Lazy.t

let rec fib = C (0, lazy (C (1, lazy (map2' (+) fib (tl' fib)))))

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Мотивация}
Будем использовать copattern matching, который уже часто используется в proof assistants

Обычный pattern matching деконструирует конечное значение определенное конструктором

Copattern matching создает бесконечное вычисление, составленное из результатов 
``наблюдений'' (observations) за значениями в некотором контексте

Паттерн матчинг обладает контролем какое значение построить.

Copattern matching предлагает потенциальные варианты, и позволяет контексту выбирать между ними.

А observation -- что-то типа \lstinline{Lazy.force}
\end{frame}

\begin{frame}[fragile]{Copattern-matching. Пример. Фибоначчи}
Это не настоящий синтаксис OCaml
\begin{lstlisting}
let corec fib : int stream with
| .. #Head -> 0
| .. #Tail : int stream with
| .. #Tail#Head -> 1
| .. #Tail#Tail -> map2 (+) fib (fib#Tail)
\end{lstlisting}

% Значение fib в 1й строчке задаетпоток чисел, который строится по трём правилам
% Если наблюдается голова, то возвращаем 0
% второе правило про наблюдения, осуществляемые по цепочке
% Если наблюдается голова хвоста, то возвращаем 1
% Третий случай говорит. что надо сделать поточечное сложение двух потоков чисел.

\end{frame}
\begin{frame}[fragile]{Copattern-matching. Пример. Фибоначчи}
Это не настоящий синтаксис OCaml
\begin{lstlisting}
 let corec fib : int stream with
| .. #Head -> 0
| .. #Tail : int stream with
| .. #Tail#Head -> 1
| .. #Tail#Tail -> map2 (+) fib (fib#Tail)
\end{lstlisting}
При обычном паттерн-матчинге все ветки возвращают одинаковый тип, но тут это не так.
Тип веточки зависит от ипа наблюдения: если смотрим в голову, то надо возвращать значение
типа int, а если хвост, то int stream. Опишем явно котип данных для стрима

Это не настоящий синтаксис OCaml
\begin{lstlisting}
type 'a stream = {
  Head: 'a        !$\leftarrow$! 'a stream
  Tail: 'a stream !$\leftarrow$! 'a stream
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Что хочется получить}
\begin{itemize}
 \item Копаттерны для OCaml
 \item Используя дуальность, реинтерпретировать это в терминах pattern matching
 \item Типобезопасно
 \item Эффективно
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Что получилось}
\begin{itemize}
 \item \href{https://github.com/yurug/ocaml4.04.0-copatterns}{OCaml-4.04+copatterns \faGithub}.
 \item non-indexed codatatypes
 \item Типобезопасно, но с GADT и 2nd-order polymorphic types
 \item Эффективно (\lstinline=lazy cofunction=)
\end{itemize}
\end{frame}


% \begin{frame}[fragile]{Мотивация}
% \begin{itemize}
%  \item Call-by-value is an evaluation strategy in which the arguments are evaluated before being passed to the functions.
% \begin{lstlisting}
% let rec zeros = Cons (0, zeros )
% \end{lstlisting}
% Вычисление расходится
% \item Решение - ?
% \end{itemize}
% \end{frame}

% \begin{frame}[fragile]{Мотивация}
% Call-by-value $\Rightarrow$ раходимость.
% 
% Решение : сэмулировать call-by-name (à la Haskell). 
% 
% 
% \begin{lstlisting}[language=ocaml,mathescape=true]
% type 'a list = Nil | Cons of 'a * (unit -> 'a list)
% 
% let rec zeros = Cons (0, fun () -> zeros)
% \end{lstlisting}
% 
% \begin{lstlisting}[language=ocaml,mathescape=true]
% let rec map f xs =
%   match xs with
%   | Nil -> Nil
%   | Cons (x,th) -> Cons(f x, map f (th ()))
% 
% map ((+)1) zeros;;
% 
% $-$ : int list = Cons(1, <fun>)
% \end{lstlisting}
% \end{frame}


\section{GADT}

\begin{frame}[fragile]{GADT}
Они же
\begin{itemize}
\item Generalized Algebraic Data Type
\item first-class phantom type (James \& Hinze, 2003)
\item guarded recursive datatype (Xi\&Chen,2003)
\item equality-qualified type (Sheard \& Pasalic, \textit{tile here}, 2004)
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Синтаксис GADT}
\begin{lstlisting}[language=ocaml,mathescape=true]
type ($\alpha$,$\beta$, ... ) typ =
  | $C_1$ of $\tau_{11}$ * ... * $\tau_{1m_1}$
  | ...
  | $C_n$ of $\tau_{n1}$ * ... * $\tau_{nm_n}$

!\pause!

type ($\alpha$,$\beta$, ... ) typ =
  | $C_1$ !\colorbox{yellow}{:}! $\tau_{11}$ * ... * $\tau_{1m_1}$ !\colorbox{yellow}{$\rightarrow$ ($t_{11}$, $t_{12}$, ...) typ}!
  | ...
  | $C_n$ !\colorbox{yellow}{:}! $\tau_{n1}$ * ... * $\tau_{nm_n}$ !\colorbox{yellow}{$\rightarrow$ ($t_{n1}$, $t_{n2}$, ...) typ}!
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Каноничный пример}
\begin{lstlisting}[language=ocaml,mathescape=true]
type 'a expr =
| EInt   : int                 -> int expr
| EBool  : bool                -> bool expr
| EEqual : int expr * int expr -> bool expr

EEqual (EInt 5, EInt 6)

- : bool expr = EEqual (EInt 5, EInt 6)

!\pause!

EEqual (!\colorbox{red}{EBool true}, EInt 6)
\end{lstlisting}

\begin{verbatim}
Error: This expression has type bool expr
       but an expression was expected of type int expr
       Type bool is not compatible with type int
\end{verbatim}
\end{frame}

\begin{frame}{Лейбниц?}
 
\end{frame}

\section{GADT и ленивые списки}

\begin{frame}[fragile]{GADT и наблюдение за ленивыми списками}
\begin{lstlisting}[language=ocaml,mathescape=true]
type ('o,'a) stream_query =
| Head : ('a,       'a) stream_query
| Tail : ('a stream,'a) stream_query
\end{lstlisting}
% TODO: починить шрифт
% Второй параметр -- что генерирует стрим
% первый -- что получает при наблюдении
\end{frame}

\begin{frame}[fragile]{Результат преобразования объявления типа коданных}
\begin{lstlisting}[language=ocaml]
and 'a stream = Stream of {
  dispatch : 'o . ('o, 'a) stream query -> 'o
}
\end{lstlisting}
As our inversion of control turns a codata into a
function defined by pattern matching over observation requests

\vspace{1cm}

Тип в System F 
\begin{lstlisting}[language=ocaml,mathescape=true]
$\forall$'a .($\forall$'o . ('o,'a) stream_query ->   'o) ->   'a stream
\end{lstlisting}
\vspace{1cm}
\href{https://caml.inria.fr/pub/papers/garrigue_remy-poly-ic99.ps.gz}{Jacques Garrigue and Didier Rémy. 1999. }
\end{frame}

\begin{frame}[fragile]{?}
\begin{lstlisting}[language=ocaml]
let rec fib : int stream =
  let dispatch : type o. (o, int) stream query -> o = function
  | Head -> 0
  | Tail -> !\pause!
    let dispatch : type o.(o, int) stream query -> o = function
    | Head -> 1
    | Tail -> map2 (+) fib (tail fib)
    in Stream { dispatch }
  in Stream { dispatch }
\end{lstlisting}
\begin{lstlisting}[language=ocaml]
let tail (Stream { dispatch }) = dispatch Tail
\end{lstlisting}
% no sharing between fiv and `tail fib`. Need lazy coputation

% Типы тут хорошие не смотря на то, что 3я строчка возвращает число, а 4я
% стрим. Просто answer type `o` в разных ветках имеет разные типы из-за GADT stream_query,
% в 1й бранче 1 имеет тип о, а во втрой `Stream{dispatch}` тоже имеет тип о.

% Замечание, преобразование не очень эффективное, так как fib и tail fib не имеют общей части.

\end{frame}

\begin{frame}[fragile]{?}
\begin{lstlisting}[language=ocaml]
let corec fib : int stream with
| ..#Head -> 0
| ..#Tail : int stream with
| ..#Tail#Head -> 1
| ..#Tail#Tail -> map2 (+) fib (fib#Tail)
\end{lstlisting}

При преобразовании произошел unnesting
% Anton Setzer, Brigitte Pientka, and David Thibodeau у них тоже был алгоритм, но другой
\end{frame}


\section{Formalization}

\begin{frame}[c]{Преобразование}
\centering
{\LARGE $\lambda^C \to \lambda^G$}
\end{frame}

\begin{frame}[c]{Термы}
\begin{tabular}{ l l r }
  $t,u $&$::=$ & \\
  &|  $x$ & Переменная \\
  &|  $D$ & Observation request  \\
  &|  $K t$ & \graybox{Конструктор с аргументами} \\
  &|  $t t$ & Применение  \\
  &|  $t \cdot t$  & \graybox{Observation}  \\
  &|  $\mu^+ f: \sigma := \lambda \bar{x}\{\bar{b}\}$ & \graybox{Функция } \\
  &|  $\mu^- f: \sigma := \lambda \bar{x}\{\bar{b}\}$ & \graybox{Коданные} \\
\end{tabular}
% Здесь про выделенные надо что-то сказать
% Observation request раньше (у Thuibodeau&Pientka) писался как t\cdot D, 
% но у нас справа произвольные терм, который может быть простым Request или сложным.
% Таким образом у нас first-class observations

% Конструктор тут всегда один, но в ML бывает 0 или много. Это всё не умаляет общность,
% так как пары и unit можно записать как котипы данных (пример 3.1 в статье)

% мюшки для рекурсии. Плюс и минус отвечает за то, как конструируются данные
% рекурсивно или корекурсивно.
\end{frame}

\begin{frame}[c]{Ветки мэтчинга и значения}
\begin{tabular}{ l l r }
  $b $ & $::=$ & \\
  &|  $\bullet \Rightarrow t$ & Suspension \\
  &|  $\cdot D \Rightarrow t$  & Observation case \\
  &|  $K x$ & Деконструирование \\
\end{tabular}
% Рекурсивные и корекурсивные функции используют один и другой вид бранчей соответственно
% лямбда-абстракция это ни то, ни другое, у неё первый случай, а жирная точка, это отсутсвие 
% копаттерна

\vspace{1cm}

\begin{tabular}{ l l r }
  $v $ & $::=$ & \\
  &|  $\lambda^{-} \bar{x}\{\bar{b}\} \Rightarrow t$ & Коданные\\
  &|  $\lambda^{+} \bar{x}\{\bar{b}\} \Rightarrow t$ & Функция \\
  &|  $K v$ & Данные\\
  &|  $D$   & Request\\
\end{tabular}
% вектор аргументов может быть пустой, это позволяет описывать рекурсивные данные и коданные.
%  Пьетка (ICFP,2013) вводили понятие Generalized lambda-abstraction, то различать эти вещи проще.
% Синтаксис бранчей выглядит чересчур атомарным, чтобы выражить вложенные копаттерны,
% но тут поможет unnesting. Но об этом позже
\end{frame}

\begin{frame}[c]{Семантика малого шага}
\begin{tabular}{ r c l }
  E[t] & $\xrightarrow{\text{SCxt}}$ & $E[t'] \quad если \quad t\to t'$ \\
  
  $\mu^{\diamond} f:\sigma := \lambda \bar{x}\{\bar{b}\}$ & $\xrightarrow{\text{SUnr}}$ & 
     $\lambda^\diamond \bar{x}\{(\bar{b}[f \mapsto \mu^\diamond f:\sigma := \lambda \bar{x}\{\bar{b}\}])\}$ где $\diamond \in \{+,-\}$ \\
     
  $(\lambda^\diamond x \bar{x}\{\bar{b}\})v$ & $\xrightarrow{\text{SPush}}$ & $\lambda^\diamond \bar{x}\{\bar{b}[x\mapsto v]\}$ если SEval не применим \\
  
  $(\lambda^\diamond x \{\bullet \Rightarrow t | \bar{b}\})v$ & $\xrightarrow{\text{SEval}}$ &  $t[x \mapsto v]$ где $\diamond \in \{+,-\}$\\
    
  $(\lambda^+ \bullet \{K x \Rightarrow t \mid \bar{b}\})(K v)$ & $\xrightarrow{\text{SDes}}$ &  $t[x \mapsto v]$ \\
  
  $(\lambda^+ \bullet \{K x \Rightarrow t \mid \bar{b}\})(K' v)$ & $\xrightarrow{\text{SDesF}}$ & 
    $(\lambda^+ \bullet \{\bar{b}\})(K' v)$ если $K \neq K'$ \\
  
  $(\lambda^- \bullet \{\cdot D \Rightarrow t \mid \bar{b}\})D$ & $\xrightarrow{\text{SObs}}$ &  
    $t$ \\
  
  $(\lambda^- \bullet \{\cdot D \Rightarrow t \mid \bar{b}\})D'$ & $\xrightarrow{\text{SObsF}}$ &
    $(\lambda^- \bullet \{\bar{b}\})D'$ если $D \neq D'$
\end{tabular}
% SCxt вставляет терм в контексте
% SUnr (unroll) вставляет тело (ко)рекусривной функции в место вызова, делая 1 шаг
% Spush делает бета-редукцию пока больше 1го аргумента у лямбды

% SEval если только один формальный аргумент и первая бранча это suspended computation, то можно заменить вхождения икса

% Если лямбда-абстракция это рекурсивная функция с буллетом (нет формальных входных аргументов),
% то нам передали сконструированное значение и его надо мэтчить
% всё просто для SDes и SDesF

% C правилами для копаттернов всё примерно также, только  observation copattern не связывает никаких переменных,так что 
% нет никаких подстановок

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Тут D  не несет в себе никаких аргументов, поэтому если они нужны, то тут выразительность не теряется (ХЗ почему)\
% у них были аргументы в предыдущей версии, там был короче язык, но сложнее трансформация, и её было сложнее
% перенести в OCaml. Потому оставили так.

\end{frame}

\begin{frame}[c]{Типы}
\begin{tabular}{l l r}
  $\tau,\rho,\omega$ & $::=$ & \\
  &| $\alpha$ & Типовая переменная \\
  &| $\varepsilon^+(\bar{\tau})$  & Данные \\
  &| $\varepsilon^-(\bar{\tau})$  & Коданные \\
  &| $\tau \to \tau$ & Стрелка \\
  &| $\tau \leftarrow \varepsilon^-(\bar{\tau})$ & Observation request \\
\end{tabular}

% С плюсиком GADT (они у нас везде), с минусиком котипы данных, стрелки и кострелки
% Потом должно быть понятно. почему кострелки справа налево
\end{frame}

\begin{frame}[c]{?}
% Всё это выглядит не очень выразительно по сравнению с предыдущими работами по котипам
% потому что там были констрейнты на равенство типов, а тут нет. Но всё хорошо
% 1) эпсилоны применяются не к типовым переменным, а к ground типам
% 2) И ещё можно с помощью GADT выразить равенства

% TODO: надо таки сделать как по Лейбницу.
\end{frame}

\begin{frame}[c]{Окружения с именами типов и констрейнты}
% Тут ничего интересного
\begin{tabular}{l l r}
  $\Gamma$ & $::=$ & \\
  &| $\bullet$ & пусто \\
  &| $\Gamma \alpha$  & Связанная переменная типа \\
  &| $\Gamma (x: \alpha)$ & Связанная переменная \\
\end{tabular}

\vspace{1cm}

\begin{tabular}{l l r}
  $C$ & $::=$ & \\
  &| true  & Тривиальный \\
  &| false & Пустой \\
  &| $\tau=\tau$ & Равенство типов\\
  &| $C \bigwedge C $ & Конъюнкция\\
\end{tabular}
% Тут ничего интересного
\end{frame}

\begin{frame}[fragile]{Правила для типов}
Тут показывать скриншот :)

% Тут и гамма, и констрейнты, рассказать как читать

% Sconv это дополнительное правило, типа если констрейнты говорят, что типы равны, то...
% Svar и Sapply стандартные

% Srequest просто приписывает тип реквесту, ХЗ, непонятно что тут вообще, но вроде что-то очень простое
% SConstruct банален

% SObserve & SApply дуальны: просто проверяет что левая часть подходит под правую
% стрелочка справа налево подразумевает что reqest logically driving вычисления

% SLam это банальная лямбда абстракция
% SFun проверяет что (ко)рекурсивные функции хорошие. Стрёмно, но вторая строчка проверяет что тут идет 
% типовая аннотация функции хорошая
\end{frame}

% Я тут теоремы пропустил

\begin{frame}[fragile]{Язык $\lambda^G$}
1
\end{frame}

\begin{frame}[fragile]{Поиск в глубину (dfs)}
1
\end{frame}

\end{document}
