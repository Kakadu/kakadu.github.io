% !TeX root = lambda2023.tex


\begin{frame}{Введение: $\lambda$-исчисление}
  \begin{figure}
    \centering
    \begin{subfigure}[t]{0.45\textwidth}
      \begin{minipage}{0.7\textwidth}
      \includegraphics[width=1\textwidth]{220px-Alonzo_Church.jpg}\\
            Alonzo Church (1903--1995)
      \end{minipage}
    \end{subfigure}
    \begin{subfigure}[t]{0.45\textwidth}
      \vspace{-5em}   % TODO: dirty hack!
  Алонзо Чёрч 1935   открыл $\lambda$-исчисление
\vspace{1em}

Аналогичный подход от А.~Тьюринга с его машинами Тьюринга
\vspace{1em}

Это разные подходы для формализации понятия ``алгоритм''
\vspace{1em}

В принципе, могло быть изобретено уже в 1910-х г.г.
\footnotetext{Изображение из \href{https://en.wikipedia.org/wiki/Alonzo\_Church}{Википедии}}

    \end{subfigure}
  \end{figure}

\end{frame}
\section{Введение и историческая справка}



\begin{frame}{Состояние математики в 1910-х}

    Матан, алгебра, геометрия...\\
    Информатики (computer science) явным образом пока нет, как часть математики\\

    Математическая логика
    \begin{enumerate}
      \item Пытается формализовать интуитивно понятные утверждения
      \item Языки (т.е. синтаксис), чтобы на них можно было правильно сформулировать теоремы
      \item Различные ``семантики'' как интерпретации синтаксиса , потому что формулы могут быть верны и не верны в зависимости от семантики
      \item ``Исчисления'' -- правильные способы доказательств
      \item Теоремы, которые невозможно ни доказать, ни опровергнуть.
    \end{enumerate}
  Начинают задумываться, что такое ``алгоритм'', ``вычисление'' и ``вычислимая функция''

\end{frame}

\begin{frame}{Зачем формализовывать то, что и так понятно?}
\framesubtitle{''Наивная'' теория множеств}
\begin{figure}[t]
  \begin{subfigure}[t]{0.55\textwidth}
    \vspace{-7em}
  Множества можно делить на два типа
  \begin{enumerate}
    \item   набор не является элементом самого себя
    \item Расселовские: набор является элементом самого себя.
  \end{enumerate}
  Рассмотрим $P=\{y: y\notin P\}$ и задумаемся про $P\in P$?
  \begin{itemize}
    \item Если формула верна, то нарушается определение
    \item Если ложна, то не принадлежит, но по определению должна
  \end{itemize}
\footnotetext{Изображение из \href{https://en.wikipedia.org/wiki/Bertrand\_Russell}{Википедии}}

  \end{subfigure}
\hspace{0.05\textwidth}
  \begin{subfigure}[t]{0.35\textwidth}
      \begin{minipage}{0.7\textwidth}
  \includegraphics[width=1\textwidth]{800px-Bertrand_Russell_transparent_bg.png}\\
    \centering
  Bertrand~Russell \\(1872--1970)
\end{minipage}
  \end{subfigure}
\end{figure}
\end{frame}

\begin{frame}{Некоторые известные языки и исчисления из математической логики}
\begin{itemize}
  \item Нулевого порядка (высказываний)
  \item Первого порядка (предикатов)
  \item Высших порядков
  \item Исчисление конструкций (calculus of constructions)
\end{itemize}
\begin{block}{Важное замечание}
  То, что нельзя записать в языке, нельзя использовать в исчислениях/доказательствах
\end{block}
\end{frame}

\begin{frame}{Пример: яызк 0го порядка (высказываний) }
\frametitle{Знакомая вам булева (бинарная) логика}
\begin{figure}[t]
  \begin{subfigure}[t]{0.45\textwidth}
\begin{enumerate}
  \item Логические константы True и False
  \item Логические переменные $x,y,z,\dots$
  \item Бинарные связки $\vee, \wedge, \Rightarrow$ и т.д.
\end{enumerate}
\vspace{2em}
Правила вывода в исчислении, например:
\begin{mathpar}
  \inferrule* [Right=modus ponens]
  { P\Rightarrow Q \\    P  }{Q}
\end{mathpar}
  \end{subfigure}
\hspace{0.05\textwidth}
  \begin{subfigure}[t]{0.46\textwidth}
\begin{theorem}[Язык и исчисление \textbf{``хорошие''}]
  Верную формулу можно доказать за конечное число шагов. Ложную можно опровергнуть.\\

  Т.е. существует алгоритм, который всегда завершается и говорит да/нет.
\end{theorem}
\vspace{2em}
Язык и исчисление \textbf{``плохие''}, потому что не всё можно записать (где кванторы?)
  \end{subfigure}
\end{figure}


\end{frame}


\begin{frame}{Разрешимые и неразрешимые задачи}
  \begin{definition}[Алгоритмически неразрешимая задача]
    Задача, которая имеет ответ ``да'' или ``нет'', но для которое невозможно реализовать алгоритм, который \emph{всегда завершается, и выдает правильный ответ}.
  \end{definition}
  \begin{definition}[Полуразрешимая задача]
    Неразрешимая задача, для которой можно предъявить алгоритм, который либо дает правильный ответ  ``да'', либо не завершается. Полуразрешимые$^{+}$ умеют говорить ``да'', полуразрешимые$^{-}$ --- ``нет''.
  \end{definition}
Как доказывать неразрешимость
\begin{itemize}
  \item Разбирать случаи и искать противоречие в каждом
  \item Сводить каноничную неразрешимую задачу к нашей
\end{itemize}
\end{frame}

\begin{frame}{Язык и исчисление 1-го порядка (предикатов)}
%\framesubtitle{Вы это видели на матане}
\begin{figure}[t]
  \begin{subfigure}[t]{0.5\textwidth}
    Термы:
    \begin{itemize}
      \item Предметные константы: 1.0, 42, $\pi$
      \item Функциональные символы арности  $1\leqslant n$ от термов. Например, $+, \times, f, mod$ и т.д.
	  \item Предметные переменные $x,y,z,\dots$
    \end{itemize}
    Формулы:
    \begin{itemize}
  \item Логические константы True и False
  \item Бинарные связки $\vee, \wedge, \Rightarrow$ (и т.д.) %(от двух формул)
  \item Предикатные символы (от термов) арности $1\leqslant n$
  \item Кванторы $\forall, \exists$ от имени предметной переменной и формулы
    \end{itemize}
  \end{subfigure}
\hspace{0.05\textwidth}
  \begin{subfigure}[t]{0.4\textwidth}
    \begin{block}{Важно}
      $+, \times, f, mod$ это названия функциональных символов, никто не гарантирует, что  $+$ это сложение чисел
    \end{block}
\vspace{1em}
Пример: \\
$\forall x z\ \exists y (x < y) \wedge (y < z)$\\
верно, если $x,y,z \in \mathbb{R}$, \\
неверно, если $x,y,z \in \mathbb{N}$
  \end{subfigure}
\end{figure}
\end{frame}

\begin{frame}{Преимущества и недостатки языка 1го порядка}

  \begin{itemize}
    \item Для некоторых формул из синтаксиса можно понять, что они верны (общезначимы). Для них есть алгоритм, который их докажет за конечное число шагов (см. ``метод британского музея'')
    \item Огромное количество формул верны только в некоторой семантике, для них нельзя предъявить, алгоритм, который завершается и выдает вердикт.\\
    В общем виде проверка формулы на истинность/ложность -- неразрешимая задача
    \item Язык недостаточно богат. Кванторы пробегают только предметные переменные, нельзя выразить ``для любой формулы P, верно...'', например, принцип индукции
    \[
    \forall P.\quad P(0) \Rightarrow (\forall n . P(n) \Rightarrow P(n+1))  \Rightarrow (\forall n . P(n))
    \]
  \end{itemize}
\end{frame}




\section{Лямбды как апгрейд языка предикатов}

\begin{frame}{Но можно попробовать вывернуться}
\framesubtitle{Введем специальный синтаксис}

\[
\lambda P.\quad phormula(P)
\]
Опишем принцип индукции, и применим его для $P(n)\equiv 0+\dots+n=\frac{n\cdot(n+1)}{2}$
\[
\lambda P.\quad P(0) \Rightarrow \big{(}\forall n . P(n) \Rightarrow P(n+1)\big{)}  \Rightarrow \big{(}\forall n . P(n)\big{)}
\]\pause
\[
\text{применение/подстановка} \mathlarger{\mathlarger{\mathlarger{\mathlarger{\Downarrow  \quad\!\!\!\!\!\!\Uparrow}}}} \text{абстракция}
\]

\begin{equation} \label{eq1}
  \begin{split}
    (0\equiv0) & \Rightarrow (\forall n . (0+\dots+n=\frac{n\cdot(n+1)}{2}) \Rightarrow \Big{(}0+\dots+(n+1)=\frac{(n+1)\cdot(n+2)}{2}\Big{)})  \\
    & \Rightarrow (\forall n . 0+\dots+n=\frac{n\cdot(n+1)}{2})
  \end{split}
\end{equation}
\end{frame}



\begin{frame}{Правила работы с новым языком $\lambda$}
\begin{block}{$\alpha$-эквивалентность}
При выборе новых имен, они не должны случайно перекрыть старые.\\
Предложения языка, отличающиеся только переименованием переменных, считаются ($\alpha$)эквивалентными
\end{block}
Например:  если ни $P$, ни $Q$ не встречаются в $phormula$, то $\lambda P. phormula(P)  \alphaequiv{} \lambda Q. phormula(Q) $

\begin{block}{$\beta$-эквивалентность}
Если у нас встречается $(\lambda P. phormula(P))X$, то мы можем продолжить с этим работать совершив подстановку $X$ вместо $P$ в $phormula$ (записывается как $phormula[P\mapsto X]$), т.е. заменив все свободные вхождения $P$ на $X$ внутри $phormula$.
\end{block}
\end{frame}


\begin{frame}{$\lambda$-исчисление}
\begin{figure}[t]
  \begin{subfigure}[t]{0.35\textwidth}
    \only<2>{
      \vspace{-5em}
    }
    \vspace{-1em}
Синтаксис:
\begin{itemize}
  \item Переменные: $x,y,z,\dots$
  \item Абстракция $(\lambda \nu. A)$, где \\
  $A$ -- $\lambda$-выражение, \\
  а $\nu$ --- произвольное имя переменной
  \item Применение $(AB)$, где $A$ и $B$ --- $\lambda$-выражения
\end{itemize}
\begin{definition}{Редекс}
  --- это $\lambda$-выражение вида $(\lambda \nu. A)B$
\end{definition}
  \end{subfigure}
\hspace{0.4cm}
  \begin{subfigure}[t]{0.55\textwidth}
\only<1>{
В терминах программирования:
\begin{itemize}
  \item Переменные
  \item Объявления 1-аргументных функций
  \item Вызов функции от одного аргумента
\end{itemize}
    \vspace{1em}
Процесс вычисления --- это процеcc устранения редексов (возможно, не всех) путём подстановок $\lambda$-выражений вместо переменных.
}
\only<2>{
\begin{minipage}{2cm}
  \cast
\end{minipage}
}
  \end{subfigure}
\end{figure}
\end{frame}

%\begin{frame}{Дэмка на С++ (1/5): представление выражений}
%  \cast
%\end{frame}

\begin{frame}{Каррирование}
\begin{figure}[t]
  \begin{subfigure}[t]{0.6\textwidth}
        \vspace{-10em}
\begin{definition}{Каррирование}
  --- это представление n-арных функций через 1-арные функции
\end{definition}

\vspace{1em}

В $\lambda$-исчислении функция $n$ аргументов представляются как функция одного аргумента, которые возвращает функцию от $n-1$ аргумента.\\

В мире названо в честь Хаскеля Карри. Впервые появилось в 1924 в работе М.~И.~Шейнфинкеля.\\

\footnotetext{Изображение взято с \href{https://en.wikipedia.org/wiki/Moses\_Sch\%C3\%B6nfinkel}{Википедии}}

  \end{subfigure}
\hspace{1cm}
  \begin{subfigure}[t]{0.3\textwidth}
      \begin{minipage}{1\textwidth}
    \vspace{-3mm}  \includegraphics[width=1\textwidth]{440px-Moses_Schonfinkel_1922_(cropped).jpg}\\
      \centering
  Моисей Исаевич Шейнфинкель \\
  (1888 -- 1942)
\end{minipage}
  \end{subfigure}
\end{figure}
\end{frame}


\begin{frame}[fragile]{Символ $\lambda$ работает как квантор}
  \tikzstyle{every picture}+=[remember picture]
  \tikzstyle{na} = [shape=rectangle,inner sep=0pt,text depth=0pt]
  {\Large
  \[
  \lambda \tikz\node[na](dbI1){x}; . (\lambda \tikz\node[na](dbI2){z};.  \tikz\node[na](dbI3){x}; \tikz\node[na](dbI4){z};)  \tikz\node[na](dbI5){x};

  \]
  \begin{tikzpicture}[overlay]
    \path[->,red,thick](dbI1) edge [out=90, in=90] (dbI3);
    \path[->,red,thick](dbI1) edge [out=-90, in=-90] (dbI5);
    \path[draw,->,blue,thick] (dbI2.south) -- ++(0,-0.2cm) -- ++(0.6cm,0) -- (dbI4.south);
  \end{tikzpicture}
}
\begin{itemize}
  \item свободные вхождения
  \item связанных вхождения и т.д.
\end{itemize}

\footnotetext{TODO: сказать про скобочки}
\end{frame}


\begin{frame}[fragile]{Подстановка}
Редекс $\lam{x}{\lam{x}{x} x}y$ вида $(\lambda \nu. A)B$, где
\begin{itemize}
  \item  $A \equiv \lam{x}{x} x$
  \item  $B \equiv  y$
  \item $\nu \equiv x$
\end{itemize}

  \tikzstyle{every picture}+=[remember picture]
  \tikzstyle{na} = [shape=rectangle,inner sep=0pt,text depth=0pt]
  {\Large
    \[
    (\lambda \tikz\node[na](dbI1){x}; .
      (\lambda \tikz\node[na](dbI2){x};.  \tikz\node[na](dbI3){x}; )
      \tikz\node[na](dbI5){x};)
    y    \arr \lam{x}{x}y
    \]
    \begin{tikzpicture}[overlay]
%      \path[->,red,thick](dbI1) edge [out=90, in=90] (dbI3);
      \path[->,red,thick](dbI1) edge [out=-90, in=-90] (dbI5);%      \path[draw,->,blue,thick] (dbI2) edge [out=-90, in=-90] (dbI3);
      \path[draw,->,blue,thick] (dbI2.south) -- ++(0,-0.2cm) -- ++(0.4cm,0) -- (dbI3.south);
    \end{tikzpicture}
  }

\vspace{2em}
Подстановка ``$x$ вместо $A$ в $B$'' в лит-ре обозначается по-разному:
  \begin{itemize}
    \item \subst{x}{A}{B}
    \item \substt{x}{A}{B}
  \end{itemize}
\end{frame}

\begin{frame}{Определения алгоритма}
 \begin{theorem}[Тезис Чёрча]
  Используя $\lambda$-исчисление можно реализовать произвольный алгоритм
  \emph{(с точностью до представления данных)}.
\end{theorem}
\begin{theorem}[Тезис Тьюринга]
Используя машину Тьюринга можно реализовать произвольный алгоритм
\emph{(с точностью до представления данных)}.
\end{theorem}
\vspace{1em}
Т.е. теперь под алгоритмом понимается только то, что можно записать в формализ\-ме~(-ах).
\end{frame}

\begin{frame}{Как происходят вычисления (редукция) $\lambda$-исчислении?}
  \begin{definition}[Процесс вычислений регламентирует стратегия]
    Ищем редексы $(\lambda x. P)Q$
    \begin{itemize}
      \item Если редексов нет, то вычисление закончилось
      \item Если редексы есть, стратегия регламентирует какой на данном шаге редекс стоит $\beta$-редуцировать
      \item Или же, стратегия может сказать, что все редексы нужно оставить как есть, и выдать ответ.
    \end{itemize}
  \end{definition}
  %Стратегий бывает много разных
  %\begin{enumerate}
  %  \item Строгая стратегия call-by-value .    Для $(\lambda x. P)Q$ вычисляет $Q\cbv Q'$ и потом подставляет $Q'$ вместо $x$ в $P$.
  %  \item Ленивая стратегия call-by-name.   Для $(\lambda x. P)Q$ сразу подставляет $Q$ вместо $x$ в $P$.
  %  \item Обе стратегии оставляют абстракции и переменные как есть
  %\end{enumerate}
\end{frame}

\begin{frame}{Дэмка на С++ (2/5): объявление стратегии}
  \strat
\end{frame}

\begin{frame}{Две стратегии: Call-by-value и аппликативная}
  \begin{figure}[t]
    \begin{subfigure}[t]{0.45\textwidth}
            \centering Call-by-value
      \begin{mathpar}
  \inferrule*  [Right=Abs] {\\}
{\lam{x}{e} \cbv \lam{x}{e}}
\end{mathpar}
    \end{subfigure}
    \begin{subfigure}[t]{0.45\textwidth}
      \centering
      Applicative order
      \begin{mathpar}
      \inferrule* [Right=Abs] {e \ao e'}
      {\lam{x}{e} \ao \lam{x}{e'}}
      \end{mathpar}
    \end{subfigure}
  \end{figure}
\hrulefill
\only<1>{
\begin{mathpar}
\inferrule*  [Right=App-abs]
{ f_1 \arr \lam{x}{e} \\
  a_1 \arr a_2 \\
  \subst{x}{a_2}{e} \arr r
}
{ (f_1 a_1) \arr r}
\end{mathpar}
\begin{mathpar}
  \inferrule* [Right=Var] {\\}
  {x \arr x}
  \and
  \inferrule*  [Right=App-non-abs]
{ f_1 \arr f_2 \neq \lam{x}{e} \\
  a_1 \arr a_2}
{ (f_1 a_1) \arr (f_2 a_2) }
\end{mathpar}
}
\only<2>{
\begin{figure}[t]
  \begin{subfigure}[t]{0.45\textwidth}
\begin{itemize}
\item[\faGood]    Подходит для написания произвольных алгоритмов
\vspace{4em}

\item[\faBad] Не считает под абстракцией, поэтому ответ иногда длиннее, чем хотелось бы
\end{itemize}
  \end{subfigure}
  \begin{subfigure}[t]{0.45\textwidth}
\begin{itemize}
  \item[\faBad] Нет возможности отложить вычисления на потом,т.е. в if-then-else вычисляется и then, и else. Нельзя дождаться ответа от рекурсивных функций
  \item[\faGood] Cчитает под абстракцией, поэтому ответ короче
\end{itemize}
  \end{subfigure}
\end{figure}
}
\end{frame}


\begin{frame}
\vspace{-1em}
\begin{mathpar}
\inferrule*  [Right=App-abs]
{ f_1 \arr \lam{x}{e} \\
  a_1 \arr a_2 \\
  \subst{x}{a_2}{e} \arr r
}
{ (f_1 a_1) \arr r}
\end{mathpar}
\begin{mathpar}
  \inferrule*  [Right=App-non-abs]
  { f_1 \arr f_2 \neq \lam{x}{e} \\
    a_1 \arr a_2}
  { (f_1 a_1) \arr (f_2 a_2) }
\end{mathpar}
\vspace{1em}

\cbvstrat
\end{frame}

\section{Написание алгоритмов с помощью $\lambda$-исчисления}

\begin{frame}{Что нужно для представления алгоритмов?}
  \begin{itemize}
    \item Принимать входные данные
    \item Делать ветвления  в зависимости от входных данных
    \item Совершать некоторое количество однотипных действий в зависимости от входных данных (т.е. должны быть циклы или их аналог -- рекурсия)
    \begin{itemize}
\item       Чтобы понимать, сколько действий уже сделали нужны натуральные числа
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Ветвления}
\[
T\equiv\lam{x}{\lam{y}{x}} \equiv fst \qquad \qquad \qquad \qquad
F\equiv \lam{x}{\lam{y}{y}}\equiv snd
\]

\begin{align*}
  ite \quad\equiv &\quad \lambda c. \lambda th. \lambda el. (c\ th\ el)\\
  (ite\ T) \quad\equiv &\quad  \lambda th. \lambda el. (T\ th\ el) \arrmany th\\
  (ite\ F) \quad\equiv &\quad  \lambda th. \lambda el. (F\ th\ el) \arrmany el
\end{align*}

\footnotetext{Здесь $\arrmany$ означает редукцию за несколько шагов}
\end{frame}

%\section{Представление данных в $\lambda$ исчислении}
\begin{frame}{Историческое напоминание: числа Пеано}
\begin{figure}[ht]
  \begin{subfigure}[t]{.55\textwidth}
  \vspace{-8em}
  Первым ввел аксиоматику арифметики в 1889 году. Натуральные числа определяются через ``базу'' и ``следующий''\\

  \begin{enumerate}
  \item[1.] 0 --- натуральное число
  \item[6.] Для любого натурального $n$, $S(n)$ тоже натуральное. т.е. натуральные числа замкнуты относительно операции $S(\cdot)$
  \item [9.] Аксиома индукции.
  \end{enumerate}
  \footnotetext{
  \href{https://www.researchgate.net/publication/240358753\_Peano's\_axioms\_in\_their\_historical\_context}{Peano's axioms in their historical context}
  }

  \footnotetext{Изображение взято с \href{https://en.wikipedia.org/wiki/Moses\_Sch\%C3\%B6nfinkel}{Википедии}}
  \end{subfigure}
\hspace{1cm}
\begin{subfigure}[t]{.35\textwidth}
  \begin{minipage}{1\textwidth}
    \includegraphics[width=1\textwidth]{Giuseppe_Peano.jpg}\\
    Giuseppe Peano (1858 -- 1932)
  \end{minipage}
\end{subfigure}
\end{figure}
\end{frame}


\begin{frame}{Представление чисел (нумералы Чёрча)}

$ 0 \sim \lam{s}{\lam{x}{x}}$

$ 1 \sim \lam{s}{\lam{x}{s\ x}}$

$ 2 \sim \lam{s}{\lam{x}{s\ (s\ x)}}$

  и т.д.
  \vspace{1cm}

  Сложение (один из вариантов): взять два нумерала $m$ и $n$, взять $f$ и $x$, а затем к $x$ применить $n$ раз $f$, а затем к результату применить $m$ раз $f$.

  \[
  add \equiv \lambda m. \lambda n. \lambda f. \lambda x. \app{m\ f\ }{\app{n\ f\ }{x}}
  \]
\end{frame}
\newcommand{\tb}[1]{\textcolor{blue}{#1}}
\newcommand{\tr}[1]{\textcolor{red}{#1}}
\begin{frame}{2+2}
  \begin{align*}
    (\lambda m. \lambda n. \lambda f. \lambda x. \app{m\ f\ }{\app{n\ f\ }{x}}){} 2 2 &\cbv \\
    \textcolor{blue}{(\lambda m. \lambda n. \lambda f. \lambda x. \app{m\ f\ }{\app{n\ f\ }{x}}) {}} \textcolor{red}{2} 2 &\cbv \\
    \textcolor{blue}{( \lambda n. \lambda f. \lambda x. \app{2\ f\ }{\app{n\ f\ }{x}}){}} \textcolor{red}{2} & \cbv \\
    \lambda f. \lambda x. \app{2\ f\ }{\app{2\ f\ }{x}}   &\xarr{\ \ } \\
    \lambda f. \lambda x. \app{\tb{\lam{f}{\lam{x}{f (f x)}}} \ \tr{f}\ }{\app{2\ f\ }{x}} &\ao \\
    \lambda f. \lambda x. \app{\lam{x}{f (f x)} \ \ }{\app{2\ f\ }{x}} &\xarr{\ \ } \\
    \lambda f. \lambda x. \app{\lam{x}{f (f x)} \ \ } {\app{\app{\tb{\lam{f}{\lam{x}{f (f x)}}}\ \tr{f}\ }{x}}} &\ao \\
    \lambda f. \lambda x. \app{\lam{x}{f (f x)}  } {\app{\tb{\lam{x}{f (f x)} } }{\tr{x}}} &\ao \\
    \lambda f. \lambda x. \app{\tb{\lam{x}{f (f x)} } } {\tr{(f (f x))}} &\ao \\
    \lambda f. \lambda x. f (f (f (f x))) &
  \end{align*}
\end{frame}

\begin{comment}

\begin{frame}{2+2}
  \begin{figure}[t]
    \begin{subfigure}[t]{0.50\textwidth}
      \begin{align*}
        (\lambda m. \lambda n. \lambda f. \lambda x. \app{m\ f\ }{\app{n\ f\ }{x}}){} 2 2 &\cbv \\
        \textcolor{blue}{(\lambda m. \lambda n. \lambda f. \lambda x. \app{m\ f\ }{\app{n\ f\ }{x}}) {}} \textcolor{red}{2} 2 &\cbv \\
        \textcolor{blue}{( \lambda n. \lambda f. \lambda x. \app{2\ f\ }{\app{n\ f\ }{x}}){}} \textcolor{red}{2} & \cbv \\
        \lambda f. \lambda x. \app{2\ f\ }{\app{2\ f\ }{x}}   &
      \end{align*}
      Это ответ для $\cbv$.\\

      Давайте посмотрим, что будет, если мы \\
      ответ применим к $g$ и $y$
    \end{subfigure}
    \begin{subfigure}[t]{0.45\textwidth}
      \begin{align*}
        (\lambda f. \lambda x. \app{2\ f\ }{\app{2\ f\ }{x}}) g y  &\arr \\
        (\lambda x. \app{2\ g\ }{\app{2\ g\ }{x}}) y  &\arr \\
        \app{2\ g\ }{\app{2\ g\ }{y}}   &\arr \\
        \app{\tb{\lam{f}{\lam{x}{f (f x)}}} \ \tr{g}\ }{\app{2\ g\ }{y}} &\arr \\
        \app{\lam{x}{g (g x)} \ \ }{\app{2\ g\ }{y}} &\arr \\
        \app{\lam{x}{g (g x)} \ \ } {\app{\app{\tb{\lam{f}{\lam{x}{f (f x)}}}\ \tr{g}\ }{x}}} &\arr \\
        \app{\lam{x}{g (g x)}  } {\app{\tb{\lam{x}{g (g x)} } }{\tr{y}}} &\arr \\
        \app{\tb{\lam{x}{g (g x)} } } {\tr{(g (g y))}} &\arr \\
        g (g (g (g y))) &
      \end{align*}
    \end{subfigure}
  \end{figure}
\end{frame}
\end{comment}


\begin{frame}{Рекурсия через комбинатор неподвижной точки}
\framesubtitle{англ. FIXed point combinator}
Не понятно как вызвать самого себя, так как имен нет.\\

Идея:
\begin{itemize}
  \item записываем функцию $f$, чтобы она принимала первый аргумент, который будет вызываться вместо рекурсивного вызова
  \item Везде, где надо вызвать эту ``рекурсивную'' функцию, будем писать $Yf$  или $Zf$

      \begin{align*}
  \text{FIX для $\ao$ и $\cbv$:}\quad\quad \quad  & Z\equiv \lam{f}{\lam{x}{f\lam{v}{\ x\ x\ v}}\lam{x}{f\lam{v}{\ x\ x\ v}}} \\
  \text{FIX для ``ленивых`` стратегий:}\quad\quad \quad  & Y\equiv \lam{f}{\lam{x}{f(x\ x)}\lam{x}{f(x\ x)}}
\end{align*}
\end{itemize}
\vspace{1em}
Откуда такое название?
\[
YR = \lam{x}{R(x\ x)} \lam{x}{R(x\ x)} \arr
R\big( \lam{x}{R(x\ x)}\lam{x}{R(x\ x)} \big) =
R(YR)
\]
\end{frame}


\newcommand{\ite}[3]{\ensuremath{(\text{if } #1\text{ then }#2\text{ else }#3})}}
\begin{frame}{Рекурсия в call-by-value (упрощенно)}
  \framesubtitle{Настолько упрощенно, что даже не совсем правильно}

%Основное свойство
\[
FIX\ R = R\ (FIX\ R)
\]

\vspace{1em}

Факториал: $fac \equiv (\lambda self.\lambda n . \ite{n<2}{1}{n \cdot self(n-1)})$\\

\begin{align*}
  FIX(\lambda self.\lambda n . \ite{n<2}{1}{n \cdot self(n-1)}) 2 &\arr \\
  (\lambda n . \ite{n<2}{1}{n \cdot FIX\ fac(n-1)}) 2 &\arr \\
  2 \cdot FIX\ fac\ (2-1) &\arr \\
  2 \cdot (FIX(\lambda self.\lambda n . \ite{n<2}{1}{n \cdot self(n-1)})\ 1) &\arr \\
  2 \cdot \ite{1<2}{1}{n \cdot (FIX\ fac\ (1-1))} &\arr \\
  2 \cdot 1 & \arr 2
\end{align*}
\end{frame}

\section{Как писать интерпретатор на Си?}
\begin{frame}{Дэмка на С++ (1/5): представление выражений}
\cast
\end{frame}

\begin{frame}{Дэмка на С++ (2/5): объявление стратегии}
\strat
\end{frame}

\begin{frame}{Дэмка на С++ (3/5): тривиальная константная стратегия}
\nostrat
\end{frame}

\begin{frame}{Дэмка на С++ (4/5): Call-by-value}
\cbvstrat
\end{frame}
\begin{frame}{Дэмка на С++ (5/5): понятие наследования}
\inheritance
\end{frame}

%\begin{frame}{Несколько слайдов про определение Функционального Программирования}
%\begin{figure}[t]
%  \begin{subfigure}[t]{0.45\textwidth}
%    Нетипизированное a la Scheme
%    \begin{itemize}
%      \item
%      \item
%      \item
%    \end{itemize}
%  \end{subfigure}
%  \begin{subfigure}[t]{0.45\textwidth}
%    Типизированное a la ML
%  \end{subfigure}
%\end{figure}
%\end{frame}

\section{Вопросы к экзамену}
\begin{frame}{Вопросы к экзамену}
\begin{itemize}
  \item Разрешимые и неразрешимые задачи
  \item $\lambda$-исчисление. $\alpha$ и $\beta$ правила
  \item Нумералы Чёрча. Сложение
  \item Рекурсия и факториал на ``пальцах''
  \item Наследование, но оно будет ещё в других билетах
\end{itemize}
\end{frame}
