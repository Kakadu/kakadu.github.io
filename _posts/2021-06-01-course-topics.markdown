---
layout: post
title:  "Курсовые работы"
date:   2021-09-05
categories: teaching
permalink: /:year/topis
---

Тут должны быть перечислены темы и идеи курсовых (и т.п.) работ. Для отдельных направлений может иметься отдельная страница.

Вопрос и просьбы описать тему более подробно засылать в [Telegram](https://t.me/Kakadu18).

По некоторым темам консультантом буду выступать не только я. Формального руководителья как-нибудь найдем. Темы могут быть завершены, сделаны частично или не начаты.

## Дооформленные

### [Метрики кода для OCaml](#ocaml-metrics)

В мейнстримном промышленном программировнии принято использовать так называемые метрики кода, чтобы автоматически и численно отличать хороший код от плохого. В мире функционального программирования такое распространено существенно реже, причины чего не вполне очевидны: адепты ФП скажут, что метрики нужны только для плохих языков, адепты ООП скажут, что ФП не годится для промышленного программирования; ещё кто-то -- что на ФП ничего невозможно написать, а если возможно, то не возможно прочитать; четвертые -- что метрики для ФП нужны сильно другие, а мейнстримные не применимы и т.д.

В мире OCaml метрик кода нет. Совсем. (Есть [очень старая поделка](https://students.mimuw.edu.pl/~ms248283/ocaml-metrics/sample.html), которую никто не использует). Предлагается

* взглянуть на метрики которые есть в мире (по статье "A Taxonomy of Metrics for Software Fault Prediction (2020)", [картинка слева](https://www.dropbox.com/s/w946jn79odu6e32/taxonomy_280619.pdf?dl=0));
* понять какие можно притянуть в мир ФП как есть, а какие требуют модификации;
* посмотреть как считают метрики в других функциональных языках (например, Haskell);
* сделать тулзень, которая их считает;
* выбрать opensource проекты на OCaml, и посчитать метрики.

Если в конце получится с помощью метрик показать, что ФП круче чем всё остальное -- будет очень круто.

Предсказываю, что придется поразбираться в уже имеющихся метриках, программирование подсчета метрик если и будет, то не сложное. Вообще, тема идеально подходит под категорию "software engineering".

P.S.

* Вот [какая-то умная книга про метрики для Haskell](https://www.cs.kent.ac.uk/pubs/2004/2236/content.pdf)
* У ПИ пары про метрики будут в 7м семестре.

<!--
  * Камлисты в дискорде 08.08.2021 вечером это обсуждали, если что пинать их: @olle, @companion_cube, etc.
-->


### [miniKanren + Расписание](#miniKanren-timetable)

На матмехе беда с расписанием. Оно состовляется вручную, поэтому оно появляется с запозданием и не отличается качеством, так как очень тяжело учесть все пожелания студентов и преподователей. Также присутствует большое количество ограчений. Вот, например, некоторые из них:

* число обучающихся не должно превышать вместимость аудитории
* преподаватель не может одновременно вести занятия в двух разных аудиториях
* "окна" в расписании не желательны
* в день не может быть более 4х пар

В Лаборатории языковых инструментов JetBrains Research занимаются реляционным программированием на miniKanren, которое включается в себя область под названием **программирование в ограничениях**. По сути, это предметно-ориентированный язык, который позволяет удобно (хотя кто-то счиатет, что неудобно) писать переборные задачи с ограничениями. Предлагается либо взять оригинальный miniKanren для языков семейства Scheme, или лабораторный OCanren, встроенный в язык OCaml, и заняться сбором ограничений к расписанию на матмехе, а затем и автоматическим построением расписаний.

На первых порах miniKanren должно хватать. На данный момент он строго проверяет ограничения (если они нарушены, то он прерывает поиск в текущей ветке и ищет решение в другой) и отсутсвует возможность посчитать констрейнты "не очень важными".  Например 1: номинальная вместимость аудитории 20 человек; посадить 25 можно, но будет душновато; 30 уже никак нельзя, потому что будем сидеть на коленках друг друга или задохнемся. Пример 2: за каждой группой должна быть закреплена аудитория на день, но в здании недостаточно аудиторий для всех групп, поэтому 100% корректного расписания не может существовать. Надо как-то позволить программисту указывать, что для этих групп надо строго выполнять, на какие группы можно подзабить и т.п.

В общем и целом, сделать генератор расписания -- очень полезная учебная практика, относящаяся к классу "продуктовых". Не смотря на очевидную полезность, если в процессе работы существующая реализация miniKanren не будет как-то доделана/расширена/обогащена, то генератор расписания может выглядеть несколько слабой ВКР, и рисковать не стоит. В случае расширения выразительной мощи miniKanren рекомендуется написать и заслать англоязычную статью на miniKanren workshop (дедлайн в мае-июне), что формально засчитыается как выступление на конференции. Для полноценных публикаций стоит обратить внимание на отечественные площадки: SEIM, журнал "Вестник ИТМО" и т.п.


### [Доработка IDE для OCaml](#ocaml-embox)

Tема [с прошлого года](https://kakadu.github.io/fp2020/projects.html#ocaml-ide).

* Семантическая подсветка (и/или) идентация
* Поддержка синтаксических расширений на основе Camlp5
* Что-нибудь ещё (если сможете сформулировать, что Вас больше всего раздражало на 2м курсе)


## Недооформленные

### [OCaml + Embox](#ocaml-embox)

Товарищи из [Mirage](https://mirage.io/), которые занимаются unikernelами (образы серверов, объединенные с ОС, для развертывания в облаках), как-то решили переписать TLS на OCaml, чтобы не было в реализации ни строчки кода на Си. А следовательно, никаких undefined behaviour, неправильного доступа к памяти, heartbleed и прочих ужасов. [Измерения показывают](https://usenix15.nqsb.io/), что всё стало процентов на 20 медленнее, но более безопасно. Предоагается проверить, какие будут результаты, если попробовать запихнуть язык с сборкой мусора в слабое встраиваемое железо, а именно научиться линковать в опрационную систему Embox код на OCaml, сликовать реализацию TLS и провести тестирование производительности. Если интеграция OCaml и Embox пройдет удачно, то это откроет путь к большому количеству будущих курсовых/ВКР в стиле "мы переписали код приложения с Си на OCaml, добились безопасности, мы молодцы".

По-видимому, содержательная работа будет больше похожа на попытку скомпилировать всё в кучу, чем на написание какого-то кода. Из-за этого выбирать эту тему как ВКР рискованно, как учебную практику -- нормально. Также мне будет тяжело помогать сражаться с косяками Embox, но с косяками OCaml -- вполне.

На данный момент OCaml не компилируется с помощью arm-none-eabi-gcc,
а только c armv6-unknown-linux-musleabihf-gcc, а Embox компилируется первым, а скомпилировать его вторым, навреное, никто не пробовал. С этого и стоит начать.

Так как это по сути подготовительная база для будущих работ, то публикабельность сомнительна.


### [OCaml + Qt/QML](#ocaml-qml)

В мире OCaml всё странно с проектированием GUI. Много фреймворков реализуют gui с помощью реактивного программирования, но они специфичные для OCaml. Из общеприменимого можно называть ReasonML, который включает в себя поддержку программирования для Web с помощью ReactJS. Но HTML-движок имеет свои недостатки, в частности размер образа и производительность, в частности по этому появились проекты React Native и Revery (свой нативный фреймворк для десктопа, где входной синтаксис повторяет проектирование на ReasonML для React).

QtQML остался без внимания. Это фреймворк для проектирования кроссплатформенных приложений для десктопа и смартфонов. По сути в нём три части: язык разметки, скрипты на Javascript для написания простых преобразований GUI, и большое количество библиотек на С++.

Предлагается скрестить QtQML и OCaml. В частности:
  * В QML попробовать заменить Javascript на OCaml, который компилится в Javascript в стиле ReasonML.
  * Заменить QML на код непосредственно на OCaml, а уже из него транслировать в QML, или сразу же в то, во что компилируется QML.
  * Разобраться с типизацией компонент, так как, как вы догадываетесь, сейчас QtQML динамически типизирован.

### Совсем неформально описанное

* Порт игрушечек с Javascript на ReasonML/OCaml.
    * Сейчас на 2м курсе выдается куча домашек про реализации языков. Хочется это как-то разбавить, и выдавать домашки на тему реализации игрушечек на OCaml/ReasonML с компиляцией в Javascript. (Идея в том, что студентам будет более интересно их делать.) Необходимо
      * посмотреть имеющиеся учебные примеры в мире Javascript (например, [RPGJS](https://rpgjs.dev/), поделки на основе Phaser движка и т.п.),
      * реализовать прототип,
      * спланировать как такого рода вещи можно раскопировать в десяток неповторяющихся домашек,
      * какие аспекты реализации особенно хорошо продемонстрируют превосходство (в данном конкретном случае) OCaml над Javascript.
* Remake Turbo Vision
    * для 2го курса
    * Тема нужна для обучения проектированию GUI рективным способом.
    * предлагается взять OCaml+ncurses+[notty](https://github.com/pqwy/notty) и сделать поделку в стиле [Borland Turbo Vision](https://github.com/magiblot/tvision)
* про вывод типов с уровнями
    * тема для второго курса
    * надо реализовать навороченный почти линейный алгоритм вывода типов на основе работы Д.Реми и описания Олега
    * в текст работы должно попасть подробное понятняное описание алгоритма для новичков
    * оценивать текст надо на основе отзывов студентов разных курсов


#### Завершенные и полузавершенные (не выдаются)

* Транслятор OCaml в Lua

#### Уже выданные

* Active patterns for OCaml

<!--
<script>
    var headings = document.querySelectorAll("h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]");

    for (var i = 0; i < headings.length; i++) {
        headings[i].innerHTML =
            '<a href="#' + headings[i].id + '">' +
                headings[i].innerText +
            '</a>';
    }
</script>
-->
