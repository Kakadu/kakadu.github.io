---
layout: post
title:  "Курсовые работы"
date:   2021-09-05
categories: teaching
permalink: /:year/topis
---

Тут должны быть перечислены темы и идеи курсовых (и т.п.) работ. Для отдельных направлений может иметься отдельная страница.

Вопрос и просьбы описать тему более подробно засылать в [Telegram](https://t.me/Kakadu18).

По некоторым темам консультантом буду выступать не только я. Формального руководителья как-нибудь найдем. Темы могут быть завершены, сделаны частично или не начаты.

## Дооформленные

### [Метрики кода для OCaml](#ocaml-metrics)

В мейнстримном промышленном программировнии принято использовать так называемые метрики кода, чтобы автоматически и численно отличать хороший код от плохого. В мире функционального программирования такое распространено существенно реже, причины чего не вполне очевидны: адепты ФП скажут, что метрики нужны только для плохих языков, адепты ООП скажут, что ФП не годится для промышленного программирования; ещё кто-то -- что на ФП ничего невозможно написать, а если возможно, то не возможно прочитать; четвертые -- что метрики для ФП нужны сильно другие, а мейнстримные не применимы и т.д.

В мире OCaml метрик кода нет. Совсем. (Есть [очень старая поделка](https://students.mimuw.edu.pl/~ms248283/ocaml-metrics/sample.html), которую никто не использует). Предлагается

* взглянуть на метрики которые есть в мире (по статье "A Taxonomy of Metrics for Software Fault Prediction (2020)", [картинка слева](https://www.dropbox.com/s/w946jn79odu6e32/taxonomy_280619.pdf?dl=0));
* понять какие можно притянуть в мир ФП как есть, а какие требуют модификации;
* посмотреть как считают метрики в других функциональных языках (например, Haskell);
* сделать тулзень, которая их считает;
* выбрать opensource проекты на OCaml, и посчитать метрики.

Если в конце получится с помощью метрик показать, что ФП круче чем всё остальное -- будет очень круто.

Предсказываю, что придется поразбираться в уже имеющихся метриках, программирование подсчета метрик если и будет, то не сложное. Вообще, тема идеально подходит под категорию "software engineering".

P.S.

* Вот [какая-то умная книга про метрики для Haskell](https://www.cs.kent.ac.uk/pubs/2004/2236/content.pdf)
* У ПИ пары про метрики будут в 7м семестре.

<!--
  * Камлисты в дискорде 08.08.2021 вечером это обсуждали, если что пинать их: @olle, @companion_cube, etc.
-->


### [miniKanren + Расписание](#miniKanren-timetable)

На матмехе беда с расписанием. Оно состовляется вручную, поэтому оно появляется с запозданием и не отличается качеством, так как очень тяжело учесть все пожелания студентов и преподователей. Также присутствует большое количество ограчений. Вот, например, некоторые из них:

* число обучающихся не должно превышать вместимость аудитории
* преподаватель не может одновременно вести занятия в двух разных аудиториях
* "окна" в расписании не желательны
* в день не может быть более 4х пар

В Лаборатории языковых инструментов JetBrains Research занимаются реляционным программированием на miniKanren, которое включается в себя область под названием **программирование в ограничениях**. По сути, это предметно-ориентированный язык, который позволяет удобно (хотя кто-то счиатет, что неудобно) писать переборные задачи с ограничениями. Предлагается либо взять оригинальный miniKanren для языков семейства Scheme, или лабораторный OCanren, встроенный в язык OCaml, и заняться сбором ограничений к расписанию на матмехе, а затем и автоматическим построением расписаний.

На первых порах miniKanren должно хватать. На данный момент он строго проверяет ограничения (если они нарушены, то он прерывает поиск в текущей ветке и ищет решение в другой) и отсутсвует возможность посчитать констрейнты "не очень важными".  Например 1: номинальная вместимость аудитории 20 человек; посадить 25 можно, но будет душновато; 30 уже никак нельзя, потому что будем сидеть на коленках друг друга или задохнемся. Пример 2: за каждой группой должна быть закреплена аудитория на день, но в здании недостаточно аудиторий для всех групп, поэтому 100% корректного расписания не может существовать. Надо как-то позволить программисту указывать, что для этих групп надо строго выполнять, на какие группы можно подзабить и т.п.

В общем и целом, сделать генератор расписания -- очень полезная учебная практика, относящаяся к классу "продуктовых". Не смотря на очевидную полезность, если в процессе работы существующая реализация miniKanren не будет как-то доделана/расширена/обогащена, то генератор расписания может выглядеть несколько слабой ВКР, и рисковать не стоит. В случае расширения выразительной мощи miniKanren рекомендуется написать и заслать англоязычную статью на miniKanren workshop (дедлайн в мае-июне), что формально засчитыается как выступление на конференции. Для полноценных публикаций стоит обратить внимание на отечественные площадки: SEIM, журнал "Вестник ИТМО" и т.п.


### [Доработка IDE для OCaml](#ocaml-ide)

Tема [с прошлого года](https://kakadu.github.io/fp2020/projects.html#ocaml-ide).

* Семантическая подсветка (и/или) идентация
* Поддержка синтаксических расширений на основе Camlp5
* Что-нибудь ещё (если сможете сформулировать, что Вас больше всего раздражало на 2м курсе)


### [OCaml + Embox](#ocaml-embox)

Товарищи из [Mirage](https://mirage.io/), которые занимаются unikernelами (образы серверов, объединенные с ОС, для развертывания в облаках), как-то решили переписать [TLS](https://en.wikipedia.org/wiki/Transport_Layer_Security) на OCaml, чтобы не было в реализации ни строчки кода на Си. А следовательно, никаких undefined behaviour, неправильного доступа к памяти, heartbleed и прочих ужасов. [Измерения показывают](https://usenix15.nqsb.io/), что всё стало процентов на 20 медленнее, но более безопасно. Предоагается проверить, какие будут результаты, если попробовать запихнуть язык с сборкой мусора в слабое встраиваемое железо, а именно научиться линковать в опрационную систему Embox код на OCaml, сликовать реализацию TLS и провести тестирование производительности. Если интеграция OCaml и Embox пройдет удачно, то это откроет путь к большому количеству будущих курсовых/ВКР в стиле "мы переписали код приложения с Си на OCaml, добились безопасности, мы молодцы".

По-видимому, содержательная работа будет больше похожа на попытку скомпилировать всё в кучу, чем на написание какого-то кода. Из-за этого выбирать эту тему как ВКР рискованно, как учебную практику -- нормально. При этом я планирую помогать разбираться с косяками OCaml. С косяками Embox помогут ембоксёры (Антон Козлов).

Начинать стоит и осознования как именно [кросс-компилируется OCaml](https://github.com/EduardoRFS/reason-mobile).
На данный момент Embox компилируется с помощью arm-none-eabi-gcc, а скомпилировать его с помощью  armv6-unknown-linux-musleabihf-gcc наверное, никто не пробовал. Этим и стоит продолжить.

Думаю, что тут есть что поделать **на год**. Так как это по сути подготовительная база для будущих работ, то **публикабельность сомнительна**.

### OCaml и полиморфные варианты

В языке OCaml присутствует фича под названием "полиморфные вариантные типы", которая позволяет типизировать значения алгебраического типа данных не номинально (т.е. указание к какому типу они принадлежат), а структурно (т.е. указание того, с каких конструкторов данное значение начинается). Эта фича появилась в языке в начале нулевых, но снискала только умеренную популярность из-за чересчур длинных сообщений об ошибках, а также из-за несколько неинтуитивного автоматического вывода типов для полиморфных вариантов.

В [работе](https://arxiv.org/abs/1606.01106) "Set-Theoretic Types for Polymorphic Variants" 2016 года авторы показывают примеры программ, где типизацию полиморфных вариантов можно было бы улучшить, а также формальное описание как это сделать и возможные последствия для языка OCaml. Важным является третий пример, из которого следует, что для качественной поддержки новых set-theretic полиморфных вариантов необходимо, чтобы среда выполнения языка имела поддержку RTTI (runtime type information). Так как OCaml оной не имеет, то статья в том виде, в каком она есть, едва ли будет реализована для "ванильного" OCaml.

В качестве учебной практики предлагается:

* разобраться в статье
* реализовать минимальный язык, оснащенный set-theoretic полиморфными вариантными типами
    * функции, сопоставление с образцом, пару базовых типов
* реализовать компилятор/транслятор из этого миниязыка в среду выполнения, где RTTI поддержана
    * а именно, .NET
    * или JVM

Работа **годовая**. От обучающегося ожидается наличие некоторого знания о функциональных языках и некоторого интереса к разработке языков/трансляторов (иначе ему будет больно). Так как работа планируется быть по сути "реализацией алгоритма из статьи", **едва ли это удастся опубликовать** в нормальном месте без смещения фокуса работы в сторону большей сложности. По формальным критериям тема практики относится к группе "**эксперимент**: обучающемуся поручили изучить возможности, достоинства и недостатки новой технологии, платформы, языка и т. д. на примере какой-то задачи".

Мета-цель работы: запустить на матмехе тусовку, которая занимается компиляторами в широком смысле этого слова.


## Недооформленные

### [OCaml + Qt/QML](#ocaml-qml)

В мире OCaml всё странно с проектированием GUI. Много фреймворков реализуют gui с помощью реактивного программирования, но они специфичные для OCaml. Из общеприменимого можно называть ReasonML, который включает в себя поддержку программирования для Web с помощью ReactJS. Но HTML-движок имеет свои недостатки, в частности размер образа и производительность, в частности по этому появились проекты React Native и Revery (свой нативный фреймворк для десктопа, где входной синтаксис повторяет проектирование на ReasonML для React).

QtQML остался без внимания. Это фреймворк для проектирования кроссплатформенных приложений для десктопа и смартфонов. По сути в нём три части: язык разметки, скрипты на Javascript для написания простых преобразований GUI, и большое количество библиотек на С++.

Предлагается скрестить QtQML и OCaml. В частности:
  * В QML попробовать заменить Javascript на OCaml, который компилится в Javascript в стиле ReasonML.
  * Заменить QML на код непосредственно на OCaml, а уже из него транслировать в QML, или сразу же в то, во что компилируется QML.
  * Разобраться с типизацией компонент, так как, как вы догадываетесь, сейчас QtQML динамически типизирован.

### [OCaml games](#ocaml-games)

Сейчас на 2м курсе выдается куча домашек про реализации языков программирования. Хочется это как-то разбавить, и выдавать домашние задания на тему реализации игрушек на OCaml/ReasonML/Rescript с компиляцией в Javascript. Надежда в том, что студентам будет более интересно их разрабатывать, чем писать компиляторы.

За год планируется:

* обозреть имеющиеся учебные примеры в мире Javascript (например, [RPGJS](https://rpgjs.dev/), поделки на основе Phaser движка и т.п.), а также уже сделанные игры на ReasonML;
* спланировать как такого рода задачу можно поварьировать в 10 (желательно в большее количество) *неповторяющихся* (вернее одинаковых только частично) домашних заданий;
* реализовать прототип (на сколько я знаю, игр на ReasonML довольно мало, потому что технология новая, и найти достаточно изменчивую реализацию может быть непросто);
* найти аспекты реализации, которые особенно хорошо продемонстрируют превосходство (в данном конкретном случае) OCaml над Javascript, подготовить примеры на эту тему для использования в лекциях; например:
    * удобство применения полиморфных вариантных типов для типизации клиент-сервеных сообщений
    * использования паттерна проектирования entity component system

* также найти аспекты реализации, специфичные для геймдева, и примеры того как их можно продемонстрировать на OCaml/ReasonML/Rescript. Например:
    * использование Structure-of-Arrays вместо Array-of-Structures, для получение лучшей производительности

В качестве не очень сложной учебной практики на год, может быть, можно давать только пункт про реализацию прототипа. Но для ВКР это совершенно точно будет не достаточно, последний пункт необходимо будет сделать. Думаю, что обучающемуся, который раньше не видел классического функционального программирования (классического -- это не то, что добавили в C# и называют функциональным программированием), будет сложно понять в каком стиле реализацию надо писать и какие приёмы надо будет применять. Скорее всего это придется изучить по ходу дела, что может быть трудоёмко.

### Совсем неформально описанное

* Remake Turbo Vision
    * для 2го курса
    * Тема нужна для обучения проектированию GUI рективным способом.
    * предлагается взять OCaml+ncurses+[notty](https://github.com/pqwy/notty) и сделать поделку в стиле [Borland Turbo Vision](https://github.com/magiblot/tvision)
* про вывод типов с уровнями
    * тема для второго курса
    * надо реализовать навороченный почти линейный алгоритм вывода типов на основе работы Д.Реми и описания Олега
    * в текст работы должно попасть подробное понятняное описание алгоритма для новичков
    * оценивать текст надо на основе отзывов студентов разных курсов


#### Завершенные и полузавершенные (не выдаются)

* Транслятор OCaml в Lua

#### Уже выданные

* Active patterns for OCaml

<script>
  var headings = document.querySelectorAll("h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]");

  for (var i = 0; i < headings.length; i++) {
      console.log( headings[i].id );
      console.log(headings[i])
      headings[i].innerHTML =
          '<a href="#' + headings[i].id + '">' +
              headings[i].innerText +
          '</a>';
  }
</script>
<!--

-->
