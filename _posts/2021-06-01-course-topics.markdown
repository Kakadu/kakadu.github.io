---
layout: post
title: "Курсовые работы"
date: 2022-08-26
categories: teaching
permalink: /:year/topics
redirect_from:
  - /2021/topics
  - /2022/topics
  - /2023/topics
---

**В 2022 тем больше не даю, так как уже много падаванов набрали тем.**

Тут должны быть перечислены темы и идеи курсовых (и т.п.) работ. Для отдельных направлений может иметься отдельная страница.

Вопрос и просьбы описать тему более подробно засылать в [Telegram](https://t.me/Kakadu18).

По некоторым темам консультантом буду выступать не только я. Формального руководителья как-нибудь найдем. Темы могут быть завершены, сделаны частично или не начаты.

## Дооформленные

{: #miniKanren-timetable }

### miniKanren + Расписание (занято)

На матмехе беда с расписанием. Оно состовляется вручную, поэтому оно появляется с запозданием и не отличается качеством, так как очень тяжело учесть все пожелания студентов и преподователей. Также присутствует большое количество ограничений. Вот, например, некоторые из них:

- число обучающихся не должно превышать вместимость аудитории;
- преподаватель не может одновременно вести занятия в двух разных аудиториях;
- "окна" в расписании не желательны;
- в день не может быть более 4х пар.

В бывшей Лаборатории языковых инструментов JetBrains Research занимаются реляционным программированием на miniKanren, которое включает в себя область под названием **программирование в ограничениях**. По сути, это предметно-ориентированный язык, который позволяет удобно (хотя кто-то счиатет, что неудобно) писать переборные задачи с ограничениями. Предлагается либо взять оригинальный miniKanren для языков семейства Scheme, или лабораторный OCanren, встроенный в язык OCaml, и заняться сбором ограничений к расписанию на матмехе, а затем и автоматическим построением расписаний.

На первых порах miniKanren должно хватать. На данный момент он строго проверяет ограничения (если они нарушены, то он прерывает поиск в текущей ветке и ищет решение в другой) и отсутсвует возможность посчитать констрейнты "не очень важными". Например 1: номинальная вместимость аудитории 20 человек; посадить 25 можно, но будет душновато; 30 уже никак нельзя, потому что будем сидеть на коленках друг друга или задохнемся. Пример 2: за каждой группой должна быть закреплена аудитория на день, но в здании недостаточно аудиторий для всех групп, поэтому 100% корректного расписания не может существовать. Надо как-то позволить программисту указывать, что для этих групп надо строго выполнять, на какие группы можно подзабить и т.п.

В общем и целом, сделать генератор расписания -- очень полезная учебная практика, относящаяся к классу "продуктовых". Не смотря на очевидную полезность, если в процессе работы существующая реализация miniKanren не будет как-то доделана/расширена/обогащена, то генератор расписания может выглядеть несколько слабой ВКР, и рисковать не стоит. В случае расширения выразительной мощи miniKanren рекомендуется написать и заслать англоязычный доклад на [miniKanren workshop](https://icfp22.sigplan.org/home/minikanren-2022#event-overview) (дедлайн в мае-июне), что формально засчитывается как выступление на конференции. Для полноценных публикаций стоит обратить внимание на отечественные площадки: SEIM, журнал "Вестник ИТМО" и т.п.

План:

- Первый семестр. Собираем требования, делаем прототип на Scheme, который ищет расписание, подходящее под все условия.
- Второй семестр. По результатам первого допиливаем прототип и miniKanren, чтобы он умел некоторые ограничения игнорить, если соблюсти все нельзя.

Околопродуктовый, на ВКР не тянет.

{: #ocaml-ide }

### Доработка IDE для OCaml

Tема [с прошлого года](https://kakadu.github.io/fp2020/projects.html#ocaml-ide).

- Семантическая подсветка (и/или) идентация
- ~~Поддержка синтаксических расширений на основе Camlp5~~
- [Inlay hints](https://github.com/ocaml/ocaml-lsp/issues/685)
- Что-нибудь ещё (можно спросить 2курсников ПИ, что их больше всего раздражало в IDE)


{: #semantich-highlighting }
#### Семантическая подсветка (и/или) идентация

В функциональном программиовании часто используется паттерн проектирования, заключающийся в создании встраиваемых предметно-ориентированных языков (Embedded Domain Specific languages, EDSLs) для некоторых видов API, например:

- eDSL для создания запросов к реляционной базе данных
- для описания XML

Такие встраиваемые языки часто требуют особых правил подстветки и отступов по сравнению с host-языком, куда они встроены.
Сейчас в LSP уже [ведется работа](https://github.com/microsoft/language-server-protocol/issues/18) по добавлению в спецификацию возможностей semantic highlighting. (P.S. Похоже её таки уже добавили в спецификацию: вот
[про цвета](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_colorPresentation) и вот
[про форматирование](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_formatting))

Что надо сделать:

- в реализации [OCaml Language Server](https://github.com/ocaml/ocaml-lsp) сделать/доделать поддержку раскрашивания синтаксиса и форматирования с отступами.
- сделать возможность описывать правила подстветки кода библиотекам на OCaml
- доделать редактор кода, который умеет общаться с LSP сервером (например, [VS Code](https://marketplace.visualstudio.com/items?itemName=ocamllabs.ocaml-platform) предпочтителен), чтобы он научился показывать то, что прислал сервер.


Текущее состояние дел:

- ocaml-lsp-server вызывает стороннее приложение для форматирования кода (ссылки [раз](https://github.com/ocaml/ocaml-lsp/blob/master/ocaml-lsp-server/src/fmt.ml) и [два](https://github.com/ocaml/ocaml-lsp/blob/master/ocaml-lsp-server/src/ocaml_lsp_server.ml#L631), надеюсь номера строк не уедут со времененем)
- для подсветки синтаксиса в ocaml-lsp-server реализованы только [заглушки](https://github.com/ocaml/ocaml-lsp/blob/master/ocaml-lsp-server/src/ocaml_lsp_server.ml#L540.)

Замечание: настраиваемое форматирование можно выделить в одну тему, а подсветку -- в другую похожую тему.

*Уровень*: курсовая; возможен последующий апгрейд до бакалаврской.

Пожелания к обучающемуся:

- знакомство с OCaml;
- знакомство с eDSL;
- знакомство с технологией разработки/расширения соответствующего редактора (для VS Code это язык TypeScript);
- отсутствие страха окунуться в большие проекты.

{: #ocaml-embox }

### OCaml + Embox

Товарищи из [Mirage](https://mirage.io/), которые занимаются unikernelами (образы серверов, объединенные с ОС, для развертывания в облаках), как-то решили переписать [TLS](https://en.wikipedia.org/wiki/Transport_Layer_Security) на OCaml, чтобы не было в реализации ни строчки кода на Си. А следовательно, никаких undefined behaviour, неправильного доступа к памяти, heartbleed и прочих ужасов. [Измерения показывают](https://usenix15.nqsb.io/), что всё стало процентов на 20 медленнее, но более безопасно. Предоагается проверить, какие будут результаты, если попробовать запихнуть язык с сборкой мусора в слабое встраиваемое железо, а именно научиться линковать в опрационную систему Embox код на OCaml, сликовать реализацию TLS и провести тестирование производительности. Если интеграция OCaml и Embox пройдет удачно, то это откроет путь к большому количеству будущих курсовых/ВКР в стиле "мы переписали код приложения с Си на OCaml, добились безопасности, мы молодцы".

По-видимому, содержательная работа будет больше похожа на попытку скомпилировать всё в кучу, чем на написание какого-то кода. Из-за этого выбирать эту тему как ВКР рискованно, как учебную практику -- нормально. При этом я планирую помогать разбираться с косяками OCaml. С косяками Embox помогут ембоксёры (Антон Козлов).

Начинать стоит и осознования как именно [кросс-компилируется OCaml](https://github.com/EduardoRFS/reason-mobile).
На данный момент Embox компилируется с помощью arm-none-eabi-gcc, а скомпилировать его с помощью armv6-unknown-linux-musleabihf-gcc наверное, никто не пробовал. Этим и стоит продолжить.

Думаю, что тут есть что поделать **на год**. Так как это по сути подготовительная база для будущих работ, то **публикабельность сомнительна**.

{: #ocaml-telegram }

### OCaml API для Telegram (боец занимал, но слился)

Библотека [TDlib]() является реализацией API Telegram на С++ и позволяет создавать альтернативные клиенты для Telegram. Сама библиотека написана на С++, а также содержит [описание](https://github.com/tdlib/td/blob/master/td/generate/scheme/td_api.tl) API Telegram, по которому можно автоматически генерировать "обвязку" для языков, отличных от С++.

Цель работы: реализовать интерфейс между имеющимся кодом на С++ и OCaml, чтобы получить возможности написания альтернативных клиентов или каких-либо автоматических аггрегаторов на языке OCaml. Конкретнее:

- Надо разбораться с [описанием](https://github.com/tdlib/td/blob/master/td/generate/scheme/td_api.tl) API: что это за формат (ad hoc или общеизвестный), как из него генерируются обвязки для других языков.
- Необходимо разобраться с [демкой](https://github.com/Kakadu/ocaml_tg_test). Там вручную написана некоторая **неполная** обвязка и сделано приложение (на основе [официального примера](https://github.com/tdlib/td/blob/master/example/cpp/td_example.cpp)), которое может вопрошать у API Telegram кое-чего.
- В MVP из предыдущего пункта всюду использовались обычные алгебраические типы для видов сообщений. Возможно, использование OCaml-овских полиморфных вариантов в некоторых местах будет удобнее. Поэтому, генератор "обвязки" надо делать так, чтобы легко было изменить представление данных на стороне OCaml (сейчас для этого применены макросами С++)
- В конце предлагается сделать новый MVP 2.0, но не такой минимальный. А именно
  - Реализовать слушатель некоторых каналов/чатов телеграм, сообщения должны складировать в базу.
  - MVP 2.0 должен складировать соощения в локальную базу, чтобы отслеживать изменения/исправления и удаления сообщений.

Вполне себе курсовая на полгода. Не публикабельно.

{: #ocaml-qml }

### OCaml + Qt/QML (занята)

В мире OCaml всё странно с проектированием GUI. Много фреймворков реализуют GUI с помощью реактивного программирования, но они специфичные для OCaml. Из общеприменимого можно называть ReasonML, который включает в себя поддержку программирования для Web с помощью ReactJS. Но HTML-движок имеет свои недостатки, в частности размер образа и производительность, по этому появились проекты React Native и [Revery](https://github.com/revery-ui/revery) (свой нативный фреймворк для десктопа, где входной синтаксис повторяет проектирование на ReasonML для React).

Qt/QML остался без внимания. Это фреймворк для проектирования кроссплатформенных приложений для десктопа и смартфонов. Если не вдаваться в детали, то в нём три части: язык разметки, скрипты на JavaScript для написания простых преобразований GUI, и большое количество библиотек на С++.

Цель работы: скрестить Qt/QML и OCaml. Из этого можно выделять задачи и подзадачи на неопределенное количество человек.

- Хочется, чтобы была возможность описывать всё (GUI и бизнес-логику) не уходя сильно от языка OCaml. Сейчас в Qt/QML GUI описывается на языке QML, хотелось бы, чтобы всё переехало внутрь OCaml. Как вдохновение можно посмотреть как совмещается Javascript и HTML тэги (так называемый [JSX](https://reactjs.org/docs/introducing-jsx.html)).
  - Я сделал [эксперимент](https://github.com/Kakadu/playground_JSX/blob/master/camlp5/run.t#L10) на эту тему с Camlp5. Там HTML тэги в коде раскрываются в вызовы функций. Информации о типах там, правда, нет, но может она на превых порах и не нужна. Если таки нужна будет -- придется делать как в ReasonML.
- Когда у нас будет поддержка описания разметки GUI в OCaml, нужно будет перегонять эту разметку в вид, понятный Qt/QML. Для начала предлагаю порождать код на QML напрямую, и вставлять в код на OCaml показ окошка с соответствующим кодом. Сложности:
  - Надо придумать, как именно использовать одни QML компоненты в других QML компонентах
  - В QML можно вставлять код на JavaScript, но это можно оставить на потом
- В Qt/QML можно писать мелкие скрипты на Javascript. Очень не хотелось бы, чтобы код на OCaml перемешивался с нетипизированным кодом на Javasctript. Гораздо лучше, если бы эти GUI-ориентированные скрипты писались на OCaml, и конвертировались в JavaScript вместе с получением QML файлов. ReasonML уже научился порождать по файлу на OCaml модуль на JavaScript, надо попробовать прикрутить это всё к Qt/QML и понять какие подводные камни там будут.
- На данный момент Qt/QML с JavaScript частично интепретируется и частично JITится. Из-за этого могут возникать некоторые проблемы с производительностью кода и скоростью старта программы. На практике это решается несколькими способами

  - компилировать всё [ahead-of-time](https://doc.qt.io/qt-5/qtquick-deployment.html#ahead-of-time-compilation);
  - перегонять QML в С++ и потом запускать, частично или целиком ([раз](https://www.qt.io/blog/qml-type-compilation), [два](https://www.qt.io/blog/the-new-qtquick-compiler-technology)).

  В принципе можно сразу порождать С++ из OCaml, но из соображений

  - отладки и,
  - трудностей и неожиданных подводных камней, связанных с таким подходом
    думаю, что целесообразней начать с порождения QML

В зависимости от задач можно защищать как разное. Публикабельность пока не понятна, если удастся удачно встроиться в систему типов OCaml и навернуть типизацию -- может быть. Для начала предлагается

- Либо из файлов на OCaml порождать QML и вставлять его загрузку. Поддержку скриптов отложить.
- Либо из файлов на OCaml порождать код на С++, который будет эквивалентен QML. Поддержку скриптов отложить.

Первые задачи выглядят как курсовые. Публикабельность не понятна.



### OCaml и полиморфные варианты (занято, но чел слился, так что нет)

В языке OCaml присутствует фича под названием "полиморфные вариантные типы", которая позволяет типизировать значения алгебраического типа данных не номинально (т.е. указание к какому типу они принадлежат), а структурно (т.е. указание того, с каких конструкторов данное значение начинается). Эта фича появилась в языке в начале нулевых, но снискала только умеренную популярность из-за чересчур длинных сообщений об ошибках, а также из-за несколько неинтуитивного автоматического вывода типов для полиморфных вариантов.

В [работе](https://arxiv.org/abs/1606.01106) "Set-Theoretic Types for Polymorphic Variants" 2016 года авторы показывают примеры программ, где типизацию полиморфных вариантов можно было бы улучшить, а также формальное описание как это сделать и возможные последствия для языка OCaml. Важным является третий пример, из которого следует, что для качественной поддержки новых set-theretic полиморфных вариантов необходимо, чтобы среда выполнения языка имела поддержку RTTI (runtime type information). Так как OCaml оной не имеет, то статья в том виде, в каком она есть, едва ли будет реализована для "ванильного" OCaml.

В качестве учебной практики предлагается:

* разобраться в статье
* реализовать минимальный язык, оснащенный set-theoretic полиморфными вариантными типами
    * функции, сопоставление с образцом, пару базовых типов
* реализовать компилятор/транслятор из этого миниязыка в среду выполнения, где RTTI поддержана
    * а именно, .NET
    * или JVM

Работа **годовая**. От обучающегося ожидается наличие некоторого знания о функциональных языках и некоторого интереса к разработке языков/трансляторов (иначе ему будет больно). Так как работа планируется быть по сути "реализацией алгоритма из статьи", **едва ли это удастся опубликовать** в нормальном месте без смещения фокуса работы в сторону большей сложности. По формальным критериям тема практики относится к группе "**эксперимент**: обучающемуся поручили изучить возможности, достоинства и недостатки новой технологии, платформы, языка и т. д. на примере какой-то задачи".

Мета-цель работы: запустить на матмехе тусовку, которая занимается компиляторами в широком смысле этого слова.



## Недооформленные

{: #parallel-miniKanren }

### Реализация miniKanren с параллелизмом (занята)

Встраиваемый язык miniKanren -- по сути реализация поиска перебором по некоторому дереву, где поиск в одних ветвях не зависит от поиска в других. В теории это должно хорошо распараллеливаться, на практике никто этого сделать не пробовал. Предлагается взять текущий вариант будущего релиза OCaml 5, где планируют добавить поддержку параллелизма в рантайм, и попробовать реализовать поиск в миниканрене, который будет как-то параллелиться.

Планируется за 1й семестр взять [игрушечную](https://github.com/Kakadu/unicanren) OCaml реализацию miniKanren, [разобраться](https://github.com/ocaml-multicore/parallel-programming-in-multicore-ocaml) с параллельным программированием в будущей версии OCaml, и скрестить как-нибудь одно с другим. На первый семестр этого должно хватить. Во втором можно пытаться добавлять параллелизм в настоящую реализацию [miniKanren](https://github.com/JetBrains-Research/OCanren).

От исполнителя требуется знакомство (или же возможность достаточно быстро разобраться):

- c ФП на OCaml
- с параллельным программированием
- c [miniKanren](http://incf19.com/yynotes/lispbooks/The-Reasoned-Schemer.pdf)

{: #visual-miniKanren }

### Визуализатор/отладчик miniKanren (занята)

Встраиваемый язык miniKanren -- по сути реализация поиска перебором по некоторому (потенциально бесконечному) дереву, где поиск в одних ветвях не зависит от поиска в других. Чтобы этот поиск был полный, в miniKanren реализована стратегия поиска interleaving search. Её суть заключается в том, что процесс поиска скачет между текущими узлами дерева и потихоньку углубляет посещенную часть его, производя поиск. Из преимуществ можно назвать, что это поиск полон (в отличие от поиска в глубину) и быстрее работает чем банальный поиск в ширину. Из недостатков: это очень сложно отлаживать с помощью дебажной печати, потому что контекст текущего исполнения постоянно меняется.

Предлагается взять [игрушечный](https://github.com/Kakadu/unicanren) вариант miniKanren и реализовать визуализатор его исполнения. В частности, надо будет запускать программы на miniKanren на определенное число шагов, поддерживать шаг назад/вперед, в перспективе собирать какую-то статистику о программе, которую визуализируют/отлаживают. Разумеется как-то визуализировать дерево поиска и переменные miniKanren, появляющиеся по ходу дела.

{% spoiler Подробнее %}
Конкретный GUI framework не очень принципиален, но как минимум он должен легко запускаться на GNU/Linux. Из личных предпочтений мы будем рекомендовать Qt/QML.

C Qt/QML могут быть два подхода к решению.

1. Взять игрушечный вариант miniKanren, скомпилировать его в Javascript и запихнуть в Qt/QML, в который уже встроен движок Javascript. Просто и прямолинейно, но потом писать визуализатор и перемешивать его код с интерпретатором miniKanren будет неприятно.

2. Взять грядущую версию OCaml версии 5, где поддержана концепция [алгебраических эффектов](https://github.com/ocaml-multicore/effects-examples), которая позволяет прерывать исполнение кода, в более-менее произвольном месте, а потом продолжать исполнение с прерванного места. Это не поддерживается в Javascript (OCaml кусок должен компилироваться в нативный код), что может усложнить интеграцию визуализатора с игрушечным miniKanren. Но это в перспективе должно позволить разделить визуализацию и пошаговое исполнение, что сильно упростит код. Может быть, их этого получится сделать какую-нибудб студенческую статью.

{% endspoiler %}

От исполнителя требуется знакомство (или же возможность достаточно быстро разобраться):

- c ФП на OCaml
- c [miniKanren](http://incf19.com/yynotes/lispbooks/The-Reasoned-Schemer.pdf)

{: #ocaml-orm }

### OCaml ORM (занята вроде)

В промышленном программирование для облегчения работы с реляционными базами данных часто применяется подход
object-relational mapping (ORM). Суть подхода заключается в том, что каждой строке в результате запроса к базе соответсвует объект, который можно изменять и заливать обратно в базу. Это освобождает программиста от написания SQL запросов, которые порою сложно писать, они согут быть уязвимы к атакам и могут быть не переносимы между разными базами данных.

{% spoiler Подробнее %}
Этот подход подвержен определенной критике. Рекомендуется почитать [её](https://habr.com/ru/post/667078/), а также ссылки из этой статьи. Также в будущей записке к учебной практике надо будет коснуться [антипаттернов](https://en.wikipedia.org/wiki/Active_record_pattern).

На данный момент в программировании на OCaml подход ORM не пользуется популярностью, как минимум, потому что нельзя просто так взять найти библиотеку с реализацией данного подхода. Заслуживают упоминания:

- [https://github.com/mirage/orm](https://github.com/mirage/orm) не поддерживается
- [https://github.com/darioteixeira/pgocaml](https://github.com/darioteixeira/pgocaml) генерирует типы-записи для данных во время компиляции.
- [https://github.com/roddyyaga/ppx_rapper](https://github.com/roddyyaga/ppx_rapper) расширение синтаксиса для типобезопасных SQL запросов
- Подходы ([раз](https://okmij.org/ftp/meta-programming/index.html#QUEL) и [два](https://okmij.org/ftp/meta-programming/index.html#SQUR)) от Олега, суть которых в типобезопасном построении запросов и оптимизации оных
  {% endspoiler %}

<br/>

В данной работе предлагается реализовать/воскресить библиотеку для ORM запросов на функциональном языке программирования OCaml. Он выбран отчасти потому, что там есть синтаксическая поддежка объектов, и это может сделать результат данной работы более естественным, чем, например, на Haskell, где синтаксической поддержки объектов нет.

От исполнителя ожидается:

- знакомство с функциональным программированием;
- знакомство с ORM, его недостатками и альтернативами (например, упомянутые по ссылкам выше SQL-speaking objects);
- умение искать библиотеки для баз данных в мире OCaml и прочего ФП (есть вероятность, что после написания данного текста появится реализация ORM, что сделает данную работу бессмысленной);
- готовность сделать библиотеку, которая будет поддерживать хотя бы два backend'a баз данных;
- готовность описать и сделать подход для mock-тестирования баз данных (без него это будет максимум "удовлетворительная" работа).

Эту работу можно нарезать и на полугодовую, и на годовую курсовую 3го курса. Если меня кто-то из преподов убедит, что это бакалаврская ВКР -- пусть будет ВКР.

{: #ocaml-games }

### OCaml games (занята + TODO: дописать)

Сейчас на 2м курсе выдается куча домашек про реализации языков программирования. Хочется это как-то разбавить, и выдавать домашние задания на тему реализации игрушек на OCaml/ReasonML/Rescript с компиляцией в Javascript. Надежда в том, что студентам будет более интересно их разрабатывать, чем писать компиляторы.

За год планируется:

- обозреть имеющиеся учебные примеры в мире Javascript (например, [RPGJS](https://rpgjs.dev/), поделки на основе Phaser движка и т.п.), а также уже сделанные игры на ReasonML;
- спланировать как такого рода задачу можно поварьировать в 10 (желательно в большее количество) _неповторяющихся_ (вернее одинаковых только частично) домашних заданий;
- реализовать прототип (на сколько я знаю, игр на ReasonML довольно мало, потому что технология новая, и найти достаточно изменчивую реализацию может быть непросто);
- найти аспекты реализации, которые особенно хорошо продемонстрируют превосходство (в данном конкретном случае) OCaml над Javascript, подготовить примеры на эту тему для использования в лекциях; например:

  - удобство применения полиморфных вариантных типов для типизации клиент-сервеных сообщений
  - использования паттерна проектирования entity component system

- также найти аспекты реализации, специфичные для геймдева, и примеры того как их можно продемонстрировать на OCaml/ReasonML/Rescript. Например:
  - использование Structure-of-Arrays вместо Array-of-Structures, для получение лучшей производительности

В качестве не очень сложной учебной практики на год, может быть, можно давать только пункт про реализацию прототипа. Но для ВКР это совершенно точно будет не достаточно, последний пункт необходимо будет сделать. Думаю, что обучающемуся, который раньше не видел классического функционального программирования (классического -- это не то, что добавили в C# и называют функциональным программированием), будет сложно понять в каком стиле реализацию надо писать и какие приёмы надо будет применять. Скорее всего это придется изучить по ходу дела, что может быть трудоёмко.

### Совсем неформально описанное

- Remake Turbo Vision
  - для 2го курса
  - Тема нужна для обучения проектированию GUI рективным способом.
  - предлагается взять OCaml+ncurses+[notty](https://github.com/pqwy/notty) и сделать поделку в стиле [Borland Turbo Vision](https://github.com/magiblot/tvision)
- про вывод типов с уровнями
  - тема для второго курса
  - надо реализовать навороченный почти линейный алгоритм вывода типов на основе работы Д.Реми и описания Олега
  - в текст работы должно попасть подробное понятняное описание алгоритма для новичков
  - оценивать текст надо на основе отзывов студентов разных курсов

#### Завершенные и полузавершенные (не выдаются)

- Транслятор OCaml в Lua

## Занятые или не выдаются под другим причинам

{: #active }

### Active patterns for OCaml

{: #ocaml-linter }

### OCaml linter

Код на языках прораммирования можно пытаться проверять разными способами и утилитами. Те проверки, которые не делает компилятор часто реализуют с помощью так называемых "линтеров". Для языка OCaml на языке OCaml мною написан такой линтер, он применяется для проверки домашних заданий обучающихся.

Сейчас он кое-что умеет, но ему есть куда развиваться. Есть небольшое количество инфраструктурных задач (по типу интеграции с CI Github Actions), а также [большое количество](https://github.com/Kakadu/mylinter/issues/3) проверок ("линтов"), которые пока не реализованы. Мне нужно либо найти человека(-ов), который реализует больше линтов, либо реализовывать самому.

По сути задача разбивается на большое количество небольших задач по реализации (иногда исправлению) проверок. Так как из работы сложно выделить цельную большую задачу, то она плохо подходит под ВКР. (Но если Вы найдете формального научника, которых убедит меня, что всё хорошо -- посмотрим.) Лучше всего это делать как набор **полугодовых** учебных практик. Публикация сомнительна (если только после набора большой и интересной статистики; в местах, где обсуждается обучение ФП (например, workshop TFPIE)). Количество линтов/задач, которые нужно реализовать зависит от вредности комиссии, которой вы будете это сдавать.

Если обучающийся уже владеет функциональным программированием (OCaml, Haskell, Scala, F#), то ему будет проще разобраться.

{: #ocaml-metrics }

### Метрики кода для OCaml (занято)

В мейнстримном промышленном программировнии принято использовать так называемые метрики кода, чтобы автоматически и численно отличать хороший код от плохого. В мире функционального программирования такое распространено существенно реже, причины чего не вполне очевидны: адепты ФП скажут, что метрики нужны только для плохих языков, адепты ООП скажут, что ФП не годится для промышленного программирования; ещё кто-то -- что на ФП ничего невозможно написать, а если возможно, то не возможно прочитать; четвертые -- что метрики для ФП нужны сильно другие, а мейнстримные не применимы и т.д.

В мире OCaml метрик кода нет. Совсем. (Есть [очень старая поделка](https://students.mimuw.edu.pl/~ms248283/ocaml-metrics/sample.html), которую никто не использует). Предлагается

- взглянуть на метрики которые есть в мире (по статье "A Taxonomy of Metrics for Software Fault Prediction (2020)", [картинка слева](https://www.dropbox.com/s/w946jn79odu6e32/taxonomy_280619.pdf?dl=0));
- понять какие можно притянуть в мир ФП как есть, а какие требуют модификации;
- посмотреть как считают метрики в других функциональных языках (например, Haskell);
- сделать тулзень, которая их считает;
- выбрать opensource проекты на OCaml, и посчитать метрики.

Если в конце получится с помощью метрик показать, что ФП круче чем всё остальное -- будет очень круто.

Предсказываю, что придется поразбираться в уже имеющихся метриках, программирование подсчета метрик если и будет, то не сложное. Вообще, тема идеально подходит под категорию "software engineering".

P.S.

- Вот [какая-то умная книга про метрики для Haskell](https://www.cs.kent.ac.uk/pubs/2004/2236/content.pdf)
- У ПИ пары про метрики будут в 7м семестре.

<!--
  * Камлисты в дискорде 08.08.2021 вечером это обсуждали, если что пинать их: @olle, @companion_cube, etc.
-->

<<<<<<< Updated upstream
### OCaml и полиморфные варианты (занято)

В языке OCaml присутствует фича под названием "полиморфные вариантные типы", которая позволяет типизировать значения алгебраического типа данных не номинально (т.е. указание к какому типу они принадлежат), а структурно (т.е. указание того, с каких конструкторов данное значение начинается). Эта фича появилась в языке в начале нулевых, но снискала только умеренную популярность из-за чересчур длинных сообщений об ошибках, а также из-за несколько неинтуитивного автоматического вывода типов для полиморфных вариантов.

В [работе](https://arxiv.org/abs/1606.01106) "Set-Theoretic Types for Polymorphic Variants" 2016 года авторы показывают примеры программ, где типизацию полиморфных вариантов можно было бы улучшить, а также формальное описание как это сделать и возможные последствия для языка OCaml. Важным является третий пример, из которого следует, что для качественной поддержки новых set-theretic полиморфных вариантов необходимо, чтобы среда выполнения языка имела поддержку RTTI (runtime type information). Так как OCaml оной не имеет, то статья в том виде, в каком она есть, едва ли будет реализована для "ванильного" OCaml.

В качестве учебной практики предлагается:

- разобраться в статье
- реализовать минимальный язык, оснащенный set-theoretic полиморфными вариантными типами
  - функции, сопоставление с образцом, пару базовых типов
- реализовать компилятор/транслятор из этого миниязыка в среду выполнения, где RTTI поддержана
  - а именно, .NET
  - или JVM

Работа **годовая**. От обучающегося ожидается наличие некоторого знания о функциональных языках и некоторого интереса к разработке языков/трансляторов (иначе ему будет больно). Так как работа планируется быть по сути "реализацией алгоритма из статьи", **едва ли это удастся опубликовать** в нормальном месте без смещения фокуса работы в сторону большей сложности. По формальным критериям тема практики относится к группе "**эксперимент**: обучающемуся поручили изучить возможности, достоинства и недостатки новой технологии, платформы, языка и т. д. на примере какой-то задачи".

Мета-цель работы: запустить на матмехе тусовку, которая занимается компиляторами в широком смысле этого слова.
=======
>>>>>>> Stashed changes

<script>
  /*
  var headings = document.querySelectorAll("h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]");

  for (var i = 0; i < headings.length; i++) {
      console.log( headings[i].id );
      console.log(headings[i])
      headings[i].innerHTML =
          '<a href="#' + headings[i].id + '">' +
              headings[i].innerText +
          '</a>';
  }
  */
  /*
const headings = document.querySelectorAll('h2[id],h3[id]'); // 1
const linkContent = '🔗'; // 2
for (const heading of headings) { // 3
    const linkIcon = document.createElement('a'); // 4
    linkIcon.setAttribute('href', `#${heading.id}`); // 5
    linkIcon.innerHTML = linkContent; // 6
    heading.appendChild(linkIcon); // 7
}
*/
</script>
<script>for(let h of document.querySelectorAll('h2[id],h3[id],h4[id]'))h.innerHTML+=` <a href="#${h.id}" aria-hidden="true">#</a>`</script>
