Заявка на доработку курса "Компиляторы" с испльзованием RISC-V
==============================================================

.. toctree::
   :maxdepth: 1

фывйцуа

OCanren vs. miniKanren
----------------------

фыва


Injecting and Projecting User-Type Data
---------------------------------------

To make it possible to work with OCanren, user-type data have to be *injected* into
logic domain. In the simplest case (non-parametric, non-recursive) the function

.. code-block:: ocaml

   val inj  : ('a, 'b) injected -> ('a, 'b logic) injected
   val lift : 'a ->  ('a, 'a) injected




Using this fully abstract type and a few OCanren builtins we can
construct ``reification`` procedure which translates ``('a, 'b) injected``
into it's right counterpart.

.. code-block:: ocaml

   type gtree = gtree T.t
   type ltree = ltree X.t logic
   type ftree = (rtree, ltree) injected

Using another function ``reify`` provided by the functor application we can
translate ``(_, 'b) injected`` values to ``'b`` type.

.. code-block:: ocaml

   val reify_tree : ftree -> ltree
   let rec reify_tree eta = F.reify LNat.reify reify_tree eta

And using this function we can run query and get lazy stream of reified logic
answers

.. code-block:: ocaml

   let _: Tree.ltree OCanren.Stream.t =
     run q (fun q  -> q === leaf ())
           (fun qs -> qs#reify Tree.reify_tree)



.. list-table::
   :header-rows: 1

   * - Regular lists
     - OCanren
   * - ``[]``
     - ``nil``
   * - ``[x]``
     - ``!< x``
   * - ``[x; y]``
     - ``x %< y``
   * - ``[x; y; z]``
     - ``x % (y %< z)``
   * - ``x::y::z::tl``
     - ``x % (y % (z % tl))``
   * - ``x::xs``
     - ``x % xs``

