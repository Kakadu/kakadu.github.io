*******************************
Хвостовая рекурсия. Продолжения
*******************************




.. contents:: Оглавление
    :depth: 3

Стиль программирования с использованием продолжений (англ. :term:`continuation<Continuation>`) часто ассоциируется именно с функциональным программированием.
Продолжения

* позволяют писать корректные программы для больших входных данных, по сравнению с обычным (:term:`direct<Direct стиль>`) стилем написания функций;
* являются подходом к проектированию программ, которые иногда делает программы более понятными.

:term:`Хвостовая рекурсия`
==========================

Функциональное программирование порицает повсеместное использование циклов, и рекомендует использование рекурсивных функций.
Но их использование чревато появлением неэффективных программ (:term:`пессимизация<Пессимизация>`) из-за того, что вызовы функций обычно сопровождаются выделением кадров (англ. fram) на стеке.
Для больших входных данных это может привести переполнению стека и аварийному завершению программ.

Чтобы этого не случалось, компиляторы функциональных языков используют **оптимизацию хвостовой рекурсии**, компилируя удачно написанные программы так, чтобы стек не тратился.

Рассмотрим канонический пример факториала. В строке 3 происходит рекурсивный вызов, во время которого происходит создание нового фрейма и потребления стека

.. _factorialnaive:

.. code-block:: ocaml
    :emphasize-lines: 3

    let rec fac n =
      if n<2 then 1
      else n * fac (n-1)

.. admonition:: Хвостовой вызов

   Вызов в теле функции f какой-то функции g, является хвостовым, если результатом выполнения f является результат этого вызова g. При этом f и g могут быть одной и той же функцией.

В  :ref:`примере <factorialnaive>` выше рекурсивный вызов функции `fac` не является хвостовым, потому что для получения ответа нужно результат рекурсивного вызова ещё домножить на `n`.
Но эту функцию можно легко переписать, чтобы получались рекурсивные вызовы.

.. _factorialacc:

.. code-block:: ocaml

    let rec fac_helper acc n =
      if n<2 then acc
      else fac_helper (acc*n) (n-1)

    let fac n = fac_helper 1 n

Здесь мы создали дополнительную функцию, которая принимает не только число n, но и накапливает посчитанный ответ.
Рекурсивный  вызов функции `fac_helper` является хвостовым по определению.

.. _oddeven:

.. code-block:: ocaml

    let rec odd n =
      if n=1 then true
      else if n=0 then false
      else even (n-1)
    and even n =
      if n=0 then true
      else if n=1 then false
      else odd (n-1)

Ещё один пример хвостовой рекурсии: проверка на четность натурального числа весьма неэффективным способом.
В нём производятся хвостовые функции не самой функции, а другой, но компилятор всё ещё оптимизирует такие вызовы.

.. code-block:: ocaml
    :emphasize-lines: 3

    (* incompilable code *)
    let rec fac n =
      if n<2 then 1
      else n * (fac[@tailcall]) (n-1)

В процессе работы, если программист не уверен, то он может явно аннотировать вызов функции как хвостовой.
В примере выше был так аннотирован **нехвостовой** вызов, поэтому выдаст предупреждение 51: wrong-tailcall-expectation.

.. code-block:: ocaml

    (* incompilable code *)
    let rec fac n =
      let acc = ref 1 in
      for i=2 to n do
        acc := !acc * i
      done;
      !acc

Читатель может подумать, что для хвостовая рекурсия --- это искусственная сложность, а на самом деле стоит пользоваться циклами. Действительно, можно реализовать факториал с помощью цикла на OCaml.
Но в данном случае компилятор OCaml породит менее эффективный код, чем с хвостовой рекурсией.
Для вызовов функций аргументы передаются через регистры процессора, и на практике хвостовая рекурсия в OCaml будет примерно эквивалентна вычислению факториала циклом на Си.
В случае использования мутабельных ссылок, компилятор OCaml готовится к тому, чтобы передавать эти мутабельные ссылки как значения в другие функции.
Поэтому он выделяет место под ссылки в куче, что пессимизирует программу.

Оптимизация хвостовой рекурсии возможна и в других языках, не обязательно функциональных. (Например Gcc справляется с оптимизацией факториала и функций odd/even начиная с `-O2`.)
Но если в языке присутствует выделение памяти (например, С++) на стеке, то ситуация `осложняется <https://quuxplusone.github.io/blog/2021/01/09/tail-call-optimization>`_,
так как при удалении фрейма нужно ещё вызывать деструторы локальных значений.

К сожалению, трюк с использованием аккумулятора не всегда срабатывает, а именно непонятно что делать, если функция вызывает себя больше одного раза. Каноническим примером является экспоненциальное  вычисление чисел Фибоначчи.

.. code-block:: ocaml

    let rec fib_exp n =
      if n<2 then n
      else fib_exp (n-1) + fib_exp (n-2)

    let rec fib_acc a b n =
      if n=0 then a
      else fib_acc b (a+b) (n-1)

    let fib n = fib_acc 0 1 n

Здесь одним аккумултором не обойтись, так как рекурсивные вызовы нужно сначала вычислить, а потому просуммировать результаты.
Для успешного использования аккумуляторов нужно их вводить в двух экземплярах, что помимо оптимизации хвостовой рекурсии превратит экспоненциальную асимптотику в линейную.
Такое переписывание очевидно, если заранее знать ответ, иначе требует некоторой эврики.
Как систематически придумывать такие оптимизации мы коснемся в главе :term:`схемы рекурсии<Схемы рекурсии>`.

Демонстрация переполнения стека
===============================

Рассмотрим программу с использование деревьев, где слишком большой вход приводит к ошибке времени исполнения.
Будем рассматривать бинарные деревья и писать функцию, которая вычисляет размер деревьев.
Полный код доступен по `ссылке <https://gitlab.com/Kakadu/fp2020course-materials/-/blob/master/code/cps/cps_main.ml>`_

.. code-block:: ocaml

    type tree = Leaf | Node of tree * tree

    let rec make depth =
      if depth <= 0 then Leaf
      else
        let r = make (depth - 1) in
        let l = if depth mod 100000 = 0 then r else Leaf in
        Node (l, r)

    let size root =
      let rec helper = function
        | Leaf -> 0
        | Node (l, r) -> helper l + helper r + 1
      in
      helper root

Мы строим дерево заданной глубины с помощью функции `make`, при этом нам не очень важно наполнение дерева, поэтому левое поддерево мы получается невырожденным довольно редко. (Построение полного дерева может исчерпать всю оперативную память.)
В функции `size` мы вычисляем количество конструкторов `Node` два раза вызываясь рекурсивно.

Тестирование показывает, что код работает корректно для глубины 174716, но для глубины на единицу больше --- аварийно завершается из-за переполнения стека.

.. note::    Откуда берется эта магическая константа?

    Мы проводим испытания с помощью компилятора OCaml 4.14.2 на платформе GNU/Linux.
    Программа компилируется в переносимый байт-код, а не в native code, потому что в последнем случае затруднительно отличить переполнение стека от произвольной ошибки сегментации.
    В OCaml версии 5 были разработаны обработчики алгебраических эффектов, и реализация стеков была переработана. При использовании динамически растущих сегментированных стеков (англ. fibers) воспроизвести переполнение стека несколько сложнее. Пользуйтесь заклинанием
    ``let _ = Gc.set { (Gc.get()) with stack_limit = 100_000 }``

Таким образом, перед нами рекурсивная функция, которая не работает для достаточно большого входа, и которую не очевидно как переписать с использованием хвостовой рекурсии.
Заставить её выдавать правильный ответ чаще нам помогут **продолжения**.


:term:`Продолжения<Continuation>`
=================================

Стиль написания кода с использованием продолжений как правило подразумевает

* в функции передается дополнительный аргумент-продолжение (как правило он называется `k`);
* когда функция досчитала до ответа (сделал свою работу до конца), она **продолжает** исполнение программы, передавая ответ в функцию  `k`.

Рассмотрим это на примере (специально написанного) вычисления чисел Фибоначчи

.. _fibanf:


.. code-block:: ocaml

    let rec fib n =
      if n<2 then n
      else
        let a = fib (n-1) in
        let b = fib (n-2) in
        a+b


.. code-block:: ocaml

    let rec fibk n k =
      if n<2 then k n
      else
        fibk (n-1) (fun a ->
          fibk (n-2) (fun b ->
            k (a+b)))

Только что мы преобразовали функцию `fib` в функцию `fibk`, использующую стиль передачи продолжений (continuation passing style, CPS).
Нам пришлось:

* Добавить дополнительный аргумент `k`.
* в then-ветви добавить вызов функции `k`, имея в виду, что искомое число Фибоначчи --- это `n`, и надо продолжить вычисление с ним;
* в else-ветви нам встретились рекурсивные вызовы fib, которые необходимо заменить на новые вызовы `fibk` и придумать содержимое дополнительного аргумента.
    Заметим, что исходная функция
        * вычисляла (n-1)-e число Фибоначчи и затем **продолжала** исполнение, вычисляя (n-2) число;
        * вычисляла (n-2)-e число Фибоначчи и затем **продолжала** исполнение, вычисляя сумму.

    Поэтому в первом продолжении мы рекурсивно вычисляем (n-2)-e число, а во втором вычисляем сумму и **продолжаем** вычисления с помощью `k`.

.. note::

    Обратите внимание на правило переписывание рекурсивного вызова: выражения вида
    ``let x = f a...b in E`` превращаются в ``fk a...b (fun x -> ... E ...)``

.. hint::
    Такое переписывание программы может показаться чересчур инвазивным.
    В принципе, можно подготовиться к переписыванию с помощью CPS-монады, и затем получить CPS реализации заменой конструкции ``let`` на кострукцию ``let*`` (она же ``bind``).
    Однако такой подход более уместен для языка Haskell, чем OCaml, потому что оптимизатор Haskell лучше справляется с таким монадическим кодом.

Переписывание в CPS изменяет типы функции систематическим образом, а именно функции с типом ``A->B`` превращаются в функции с типом ``A -> (B -> 'c) -> 'c``, где ``A`` и ``B`` --- это какие-то типы, а ``'c`` --- полиморфная типовая переменная.
Наличие полиморфизма в этом случае важно, оно означает, что продолжать исполнение функции можно в любом контексте: полученное число Фибоначчи можно преобразовывать в ``int``, ``string`` или любой другой тип.

Полученная функция ``fibk`` отличается по сигнатуре от оригинальной функции ``fib``: ``int -> (int -> 'a) -> 'a`` vs. ``int -> int``.
Можно получить оригинальную функцию из ``fibk``, подставив тождественное отображение вместо продолжения

.. code:: ocaml

    let fib n = fib n (fun x -> x)

При осуществелнии CPS преобразования встречаются две типичные ошибки

* Можно забыть вызвать продолжение в случае, если в ответе нет вызовов функций (например, в реализации ``fibk`` написать вместо ``k n`` просто ``n``). В этом случае программа скомпилируется, но тип CPS функции сузится до ``int -> (int -> int) -> int`` и никакого полиморфизма не будет.
* Можно передавать вырожденное продолжение в рекурсивном вызове, продолжая писать код в direct стиле. В таком случае программ продолжит давать правильный ответ, при этом потребляя стек.

.. code-block:: ocaml
    :caption: Функция фибоначчи в CPS представлении с двумя ошибками

    let rec fibk n k =
      if n<2 then n (* тут *)
      else
        fibk (n-1) (fun a ->
          let b = fibk (n-2) (fun x -> x) in (* и тут *)
          k (a+b))

.. note:: Continuation vs callback

    В литературе встречается похоже на продолжение понятие callback.
    Это более общее понятие, чем продолжения.
    Продолжения должны вызываться один раз в ветви исполнения программы после получения ответа, а callback'и --- нет.

Общая схема трансляции выражений:

.. math::

   C(k,1)  &=  k\ 1 \\
   C(k,ident)  &=  k\ ident \\
   C(e_1+e_2, k)  &=  C(e_1, (\lambda\ r_1 \rightarrow \\
                  &=  C(e_2, (\lambda\ r_2 \rightarrow k(r_1+r_2)))))\\
   C(k, f\ e_1 \dots e_n)  &=  f_k\ e_1 \dots\ e_n

Общая схема трансляции верхнеуровневых let-связываний (:math:`\kappa` --- свежий идентификатор):

.. math::

   C_{si}(\text{let rec }f\ a_1\ldots a_n\ \textbf{=}\ e_b)  = \text{let rec }f_k\ a_1\ldots a_n =\ \kappa\ \textbf{=}\ CPS(\kappa, e_b)

.. todo::

    контификация

    порядок аргументов



https://ps-tuebingen-courses.github.io/pl1-lecture-notes/15-continuations-1/continuations-1.html