*******************************
Выбор инструкций в компиляторах
*******************************



Данные материалы задумывались как часть переработки и расширения курса по проектированию компиляторов,
где обучающиеся пишут свой компилятор простого языка программирования.
Как показывает опыт автора, студенты вполне способны сделать простое порождение инструкций (англ. instruction selection) не изучая ничего, если они знакомы с основами ассемблера целевой архитектуры.
В данном документе будут кратко изложена история исследования данной части компиляторов, и поведаны основные идеи, которые помогут заинтересованным студентам сделать "навороченный" выбор инструкций.

Никакой явной завязки на язык реализации, компилируемый язык или целевую архитектуру не задумывалось.

Информация подготовлена в основном на основе работ :cite:`Blindell2016,Blindell2018`.
В тех местах, где это уместно, были приведены примеры использования RISC-V инструкций.

Разработка данных учебных материалов поддержана в рамках конкурса грантов Альянса RISC-V.
Материалы допускаются к использованию под лицензией CC BY 4.0.

.. contents:: Оглавление
    :depth: 3

.. toctree::
   :maxdepth: 2



Классификация инструкций
------------------------

Чтобы проще сравнивать различные подходы к выбору инструкций, давайте введем классы инструкций.

**С единичным результатом** (англ. single-output instructions).
Такие инструкции производят только один наблюдаемый результат, который можно прочитать другими инструкциями в ассемблерном коде.
Сюда относятся большинство инструкций в современных процессорах, например, сложение и умножения, загрузка из памяти с учетом индекса выше, в том числе сложные инструкции типа ``cpop`` из RISCV, которая считает количество единиц в битовом представлении числа.

Обычно, из таких простых инструкций состоят ISA RISC процессоров, например, MIPS или RISC-V с базовым набором инструкций.

**С множественными результатами** (англ. multi-output instructions) имеют более одного наблюдаемого результата. Классическим примером будут инструкции, которые сразу вычисляют и остаток, и частное, или арифметические инструкции, выставляющие флаги переполнения.
Большинство архитектур предоставляют такого рода инструкции, в том числе и AMD64, и RISC-V (например,  `расширение atomic <https://msyksphinz-self.github.io/riscv-isadoc/html/rv64a.html>`_).


**С не пересекающимися результатами** (англ. disjoint-output instructions) порождают из набора входных данных набор выходных.
От предыдущего вида они отличаются тем, что тут результат не зависит от всех входных данных, и входы и результаты сгруппированы в виде некоторых шаблонов, которые не пересекаются.
Сюда относятся SIMD-инструкции (англ. single-instruction, multiple-data), которые запускают одновременно несколько однотипных действий над данными.
Для AMD64 такие инструкции есть в расширения SSE и AVX, для ARM --- в NEON, в RISC-V --- векторные инструкции.

**Межблоковые** инструкции получаются из нескольких блоков графа потока управления высокоуровневого языка.
Каночиным примером будет арифметика с насыщением, например ``max`` из `RISC-V с расширением bitmanip <https://github.com/riscv/riscv-bitmanip/blob/main/bitmanip/insns/max.adoc>`_.

**Зависимые между собой** инструкции обычно встречаются в специализированных архитектурах типа DSP. Зависимости заключаются в том, что некоторые инструкции не могут стоять рядом с другими в зависимости от используемого способа адресации.
Современным методам такие инструкции даются тяжело, обычно потому что они нарушают некоторые предположения, которые вшиты в методы выбора инструкций.



Что такое порождение "оптимальных" инструкций?
----------------------------------------------

Говоря про "оптимальный выбор инструкций" часто подразумевают следующее определение. Для некоторого набора I инструкций, где каждая инструкция :math:`i\in I` имеет стоимость :math:`c_i`, алгоритм выбора инструкций дает оптимальный результат, если для любой входной программы P он находит набор (с повторами) S из I такой, что S реализует P, и не существует другого такого набора :math:`S'`, что он тоже реализует программу P, и
при этом :math:`\sum_{s' \in S'} c_{s'} < \sum_{s \in S} c_s`.

У этого определения есть несколько недостатков. Во-первых, алгоритмы выбора инструкций могут иметь различные наборы поддерживаемых инструкций, игнорируя некоторые, которые в перспективе могут дать более эффективный код.
Алгоритмы, использующие похожий набор инструкций, можно сравнивать.
Алгоритмы с непохожими наборами инструкций могут быть каждый по-своему оптимальными, но при это различаться в разы по производительности.
Поддерживать все возможные инструкции ISA тоже затруднительно, так как алгоритмы порождения инструкций становятся полуоптимальны.


Во-вторых, два сравнимых подхода к выбору инструкций могут породить код, который после фаз переупорядочивания инструкций и распределения регистров будет непохожего качества.
Например, нам нужно породить инструкции, которые независимы друг от друга.
ISA предлагает два варианта: использовать две инструкции со стоимостью 2 каждая, либо использовать одну инструкцию со стоимостью 3.
Согласно критерию выше, нужно выбирать второй подход, так как там суммарная стоимость будет меньше.
Но если целевая архитектура умеет исполнять несколько инструкций параллельно, то лучше первый подход.




Модуль 1. Раскрытие макросов
====================================================

Раскрытие макросов (англ. macro expansion) исторически является первым и достаточно простым подходом к порождению инструкций.
Зачастую реализация разделяется на две части: непосредственно макросы-шаблоны и процедура, которая применяет эти макросы к коду (macro expander).
За счет этого разделения первая часть может быть специализирована под различные архитектуры, в то время как вторая может быть написана один раз для всех архитектур.


**Преимущества**: просто и прямолинейно.

.. table:: Пример раскрытия макросов для архитектуры RISC-V. Одной инструкции языка Си слева соответствуют от 1 до 3 инструкций ассемблера.

 +---------------------+----------------------------------------------+
 | .. code-block:: c   |  .. code-block:: none                        |
 |                     |                                              |
 |     int a = 1;      |      li r1, 1                                |
 +---------------------+----------------------------------------------+
 | .. code-block:: c   |  .. code-block:: none                        |
 |                     |                                              |
 |     int b = a+4;    |      addi r2, r1, 4                          |
 +---------------------+----------------------------------------------+
 | .. code-block:: c   |  .. code-block:: none                        |
 |                     |                                              |
 |                     |      lw r3, @p ; адрес начала массива        |
 |     p[4] = b;       |      addi r4, r3, 4*8                        |
 |                     |      sw r4, r5                               |
 +---------------------+----------------------------------------------+

Наивное раскрытие макросов
--------------------------

Одной из первых работ по порождению кода с помощью макросов является SIMCMP (SIMple CoMPiler) :cite:`Orgass1969ABF`.
В этом проекте код программы читался строчка за строчкой, и на ходу порождался машинный код. Сделано это для того, чтобы писать компилятор языка на самом этом языке (англ. bootstraping).

Ниже можно найти пример спецификации в  системе SIMCMP :cite:`Orgass1969ABF`.

.. code-block:: text
    :caption: Объявление макроса в  SIMCMP.

    * = CAR.*.
        I = CDR('21)
        CDR('11) = CAR(I).
    .X

.. code-block:: text
    :caption: Строка программы, которую компилируем.

    A = CAR B.

.. code-block:: text
    :caption: Порожденный код

    I = CDR(38)
    CDR(36) = CAR(I)





Другой пример --- GCL :cite:`Elson1970`, который использовался в компиляторе PL/1 и код порождался из деревьев абстрактного синтаксиса (англ. abstract syntax tree, AST).
По сравнению с чтением программы построчно, AST гарантирует, что программа написана без синтаксических ошибок, что упрощает задачу порождения кода.

.. figure:: images/sel11.png
    :alt: Base Mesh + 128x128 Texture (334 KB)
    :width: 150
    :align: center

    Дерево выражений

.. code-block:: asm
    :caption:
        Пример кода на RISCV для простого выражения и его схема компиляции для RISC-V.
        Значения переменных ``a`` и ``b`` хранятся в регистрах ``r1`` и ``r2`` соответственно.

    add t0, r1, r2
    mulw t0, t0, 2


.. .. comment::
..     Example of a teddy bear model at different resolutions of the
..     progressive format (1 draw call) and its original format (16 draw
..     calls). The size in KB assumes downloading progressively, |eg|
..     :num:`fig-cc-teddy-100`'s size includes lower-resolution textures.


Вопросы для самопроверки
=====================================================

#. В архитектуре x86/amd64 присутствуют инструкции арифметических операций, а также инструкции ветвелния в зависмости от различных флагов переноса/переполнения, а эти флаги изменяются при выполнении арифметических операций. Какой категории инструкций относятся арифметические инструкции в x86/amd64?
    #. С единичным результатом
    #. С множественными результатами
    #. С не пересекающимися результатами
    #. Межблоковые
    #. Зависимые между собой

