******************************
:term:`ANF<ANF>` представление
******************************


.. contents:: Оглавление
    :depth: 3



В :ref:`листинге <fibanf>` мы реализовали вычисление чисел Фибоначчи не вполне естественным образом.
Программа была преобразована в ANF (A Normal Form :cite:`Flanagan1993`) представление, а после этого уже преобразована в CPS.
ANF представление позволяет преобразовывать программы в более удобное представление для последующего CPS преобразования, и само преобразование в ANF удобнее всего реализовывать с помощью продолжений.

Программа находится в ANF форме, если все функции вызываются только от **простых** аргументов: констант и идентификаторов.
Такая форма достигается путём создания дополнительных let-связываний для всех сложных аргументов у вызовов функций.

.. note::

    Такое представление полезно, если мы в компиляторе готовимся к порождению кода на ассемблере.
    В языке процессора (например, в ассемблере RISC-V) не операций над сложными значениями. Например, нельзя умножить на сумм чисел. Необходимо посчитать сумму отдельно, положить в регистр, а затем уже умножить на значение в соответствующем регистре.

`Входной язык <https://www.cs.swarthmore.edu/~jpolitz/cs75/s16/n_anf-tutorial.html>`_ (числа, идентификаторы, арифметика, ``let``):

.. code:: ocaml

    type expr =
    | Num of int
    | Id of string
    | Plus of expr * expr
    | Let of string * expr * expr

Переработанный (ограниченный) язык отдельно выделяет примитивные (англ. immediate) данные (идентификаторы и константы), сложные выражение (сложение) и произвольные ``let``-выражения.

.. code:: ocaml

    type immexpr =
    | ImmNum of int
    | ImmId of string

    type cexpr =
    | CPlus of immexpr * immexpr

    type aexpr =
    | ALet of string * cexpr * aexpr

Нашей задачей является написание фукнции-преобразования с типом ``expr -> aexpr``.

:term:`ANF<ANF>` в примерах
===========================

Давайте рассмотрим пару простых примеров и обсудим во что именно они должны преобразоваться.

.. code:: ocaml

    (5 + 4) + 2
    (* into *)
    let v = 5 + 4 in
    v + 2

В примере выше нам надо выделить слагаемое ``5+4`` с помощью дополнительного let со свежим именем.
Но у нас не получится записать это в типе AST, приведенном выше, так как нет возможности сложное выражение ``v+2`` типа ``cexpr`` превратить в ``aexpr``.

Программы ``42`` и ``let x = 5 in x`` тоже не получится превратить в ``aexpr`` потому, что у нас нет возмости записывать непосредственные значения-константы как ``cexpr``.
Обе проблемы решаются добавлением дополнительных конструкторов, которые преобразуют ``iexpr`` в ``cexpr`` и ``cexpr`` в ``aexpr``.

.. code-block:: ocaml
    :emphasize-lines: 7,11
    :caption: Исправленный тип AST для ANF представления

    type immexpr =
    | ImmNum of int
    | ImmId of string

    type cexpr =
    | CPlus of immexpr * immexpr
    | CImmExpr of immexpr

    type aexpr =
    | ALet of string * cexpr * aexpr
    | ACExpr of cexpr

Вооружившись правильным AST, можно рассмотреть более сложные примеры.
Сделаем два уровня вложенности.

.. code-block:: ocaml

    (5 + (4 + 3)) + 2

Чтобы получить ответ, нам нужно задуматься о **порядке**, в котором мы вычисляем выражения.
В этом примере ``4+3`` вычисляется первым, поэтому первый ``let`` будет для него.

.. code-block:: ocaml

    let v1 = 4 + 3 in
    let v2 = 5 + v1 in
    v2 + 2

Рассмотрим пример, когда вложенность присутствует с обоих сторон бинарной операции.
В этом случае нам придется выбрать, в каком порядке у нас вычисляются аргументы операции, и в зависимости от него правильно расставить ``let``.

.. code-block:: ocaml

    (5 + 4) + (3 + 2)
    (* transforms into *)
    let v1 = 5 + 4 in
    let v2 = 3 + 2 in
    v1 + v2

.. note::

     Фиксацию порядка вычисления аргументов часто приписывать CPS преобразованию.

Теперь попробуем реализовать функцию, которая делает преобразования.
Начнем как обычно с использования match

.. code-block:: ocaml

    let rec anf (e: expr) : aexpr =
      match e with
      | Num n ->
      | Id x ->
      | Plus (left, right) ->
      | Let(x, value, body) ->

С ходу кажется, что первые два случая простые: нам необходимо только навесить нужное количество конструкторов на значения ``n`` и ``x``. Этого будет вполне достаточно, что преобразовывать в ANF простые программы типа ``42``.

.. code-block:: ocaml

    | Num n -> ACExpr (CImmExpr (ImmNum n))
    | Id x -> ACExpr (CImmExpr (ImmId x ))

Теперь давайте займемся бинарными операциями.
В случае конструктора ``Plus`` нужно разобраться с левыми и правыми подвыражениями.
Для начала попробуем запуститься рекурсивно от обоих и что-нибудь сделать с полученными результатами:

.. code-block:: ocaml

    | Plus (left, right) ->
      let aleft = anf left in
      let aright = anf right in
      ...

И как теперь заполнить ... с помощью  ``aleft`` и  ``aright``. Что вообще мы должны получить?
Рассмотрим примеры.

.. code-block:: ocaml

    anf (Plus (Plus (Num 5, Num 4), Num 2))
    (*  становится *)
    ALet ("v", CPlus (ImmNum 5, ImmNum 4),
      CPlus (ImmId "v" , ImmNum 2))

Давайте подумаем, что мы ожидаем получить с помощью рекурсии.
Вызывая ``anf  (Plus (Num 5, Num 4)`` (т.е. вычисляя левый аргумент) мы получим ``ACExpr (CPlus (ImmNum 5, ImmNum 4))``, так как это очевидное преобразование. Аналогично для правой части ``anf (Num 2)`` даст нам ``ACExpr (CImmExpr (ImmNum 2))``. Итого:

.. code-block:: ocaml

    aleft = ACExpr (CPlus (ImmNum 5, ImmNum 4))
    aright = ACExpr (CImmExpr (ImmNum 2))

И мы хотим это как-то скомбинировать, чтобы получить

.. code-block:: ocaml

    ALet("v", CPlus (ImmNum 5, ImmNum 4), CMinus(ImmId "v", ImmNum 2))

И как это сделать? Не очевидно. Можно назвать два главных вопроса:

* Откуда берется идентификатор "v"?
* По-видимому, нам нужно залезть во внутренности значений, чтобы достать оттуда куски, из которых потом построить результат. Стоит ли так делать? Что будет, если у нас появится много конструкторов рядом с ``ALet``?
  Означает ли это, что надо всегда делать сопоставление с образцом по результатам преобразования левой и правой частей?

Давайте вернемся немного назад, и прежде чем принимать решение, посмотрим ещё на несколько примеров.
Давайте рассмотрим случай, когда вложенность с обеих сторон бинарной операции.

.. code-block:: ocaml

    anf (Plus (Plus (Num 5, Num 4), Plus (Num 3, Num 2)))

    (* Должно превратиться в *)

    ALet("v1", CPlus (ImmNum 5, ImmNum 4),
      ALet("v2", CPlus (ImmNum 3, ImmNum 2),
        ACExpr (CPlus (ImmId "v1", ImmId "v2"))))

У этого примера есть интересные особенности.
Самое вложенное выражение складывает результаты преобразований левой и правой частей операции сложения.
Так как оба слагаемых не являются примитивными значениям, то их нужно сначала посчитать, сохранить в идентификаторах, и затем использовать введённые идентификаторы вместо них.
Возможно, нам нужна дополнительная функция, которая делает ANF преобразование, но возвращает значения типа ``cexpr``, а не ``aexpr``?
Представим, что такая функция уже написана и попробуем ею воспользоваться:

.. code-block:: ocaml

    | Plus (left, right) ->
      let aleft = anf_but_as_cexp_not_aexp left in
      let aright = anf_but_as_cexp_not_aexp right in
      ALet ("v1", aleft,
        ALet ("v2", aright,
          ACExpr(CPlus (ImmId("v1"), ImmId("v2")))))

К сожалению, такой подход сломается, если с одной из сторон будет двойная вложенность:

.. code-block:: ocaml

    anf (Plus (Plus (Num 5, Minus (Num 4, Num 3)), Num 2))

    (* должно превратиться в  *)

    ALet("v1", CMinus(ImmNum 4, ImmNum 3),
      ALet("v2", CPlus (ImmNum 5, ImmId("v1")),
        ACExpr(CPlus (ImmId("v2"), ImmNum 2))))

Здесь левой частью выражения выражения является ``Plus (Num 5, Minus (Num 4, Num 3))``, которое не должно превращаться в ``cexpr``, потому что для его преобразования надо ввести ``let``.
Это демонстрирует суть нашей проблемы, которая заключается в том, что мы не может узнать без рекурсивного заглядывания вглубь нашего выражения, сколько уровней вложенности ``let`` связываний необходимо написать, чтобы полностью преобразовать исходное выражение.
Мы знаем только то, что надо оба слагаемых превратить в последовательность вложенных ``let`` связываний, подставляя соответствующие примитивные значения (идентификаторы) в правильные позиции.

Поэтому наши бинарные выражения должны стать выражениями с "дырками", которые мы будет заполнять соответствующими идентификаторами. Получив исходное выражение вида ``Plus (Plus (Num 5, Plus (Num 4, Num 3)), Num 2)`` нам нужно его разбить на ``Plus (●, ●)`` и

.. code-block:: ocaml

    ALet(... много промежуточных шагов для левой части ...,
      ALet("v1", ... финальное значение левой ...,
        ALet(... много промежуточных шагов для правой  ...,
          ALet("v2", ... итоговое значение правой ...,
            ... и здесь мы заполняем дырки с помощью v1 и v2 ...))))

Если мы сможем выразить это разделение, то нам нужно будет сохранить выражение-с-дырками пока не преобразуются левое и правое слагаемое, а потом заполнить дырки.
Ключевая идея ANF преобразования заключается в том, что мы может представить дырки как функции языка OCaml.
А выражения, которые дожидаются своих аргументов мы тоже можем представить как функции, например:

.. code-block:: ocaml

    fun lprim rprim -> CPlus (lprim, rprim)

Имена  ``lprim`` и ``rprim`` выбраны, чтобы обозначать *левое примитивное*  (англ. "left immediate") и *правое примитивное значение* (англ. "right immediate"), поэтому функция, представляющая выражение для суммы ожидает два аргумента с примитивными значениями.
Затем мы можем запланировать, что функция ``anf`` построит выражение для суммы, предъявив нужные примитивные значения, после появления соответствующих ``let`` связываний.

Чтобы этого добиться, нам нужно исправить сигнатуру.
Будем принимать дополнительный аргумент-продолжение, которое будет представлять выражение типа ``aexpr`` с одной дыркой вида ``immexpr``:

.. code-block:: ocaml

    let rec anf (e : expr) (expr_with_hole : immexpr -> aexpr) =
      ...

Задачей функции anf будет заполнее дырок с типом `immexpr` (как правило, с помощью конструктора ``ImmId``)
The job of anf for each case will be to fill in the hole with a immexpr (usually an ImmId) that is the result of the last let-binding needed to evaluate the sub-expressions of e.
Для заполнения дырок мы просто применяем функцию  ``expr_with_hole``.
В базовых случаях констант и идентификаторов мы можем передавать примитивное значение непосредственно:

.. code-block:: ocaml

    let rec anf (e : expr) (expr_with_hole : immexpr -> aexpr) =
      match e with
        | Num(n) -> expr_with_hole (ImmNum n)
        | Id(x) -> expr_with_hole (ImmId x)
        ...

Проводя ANF преобразование, мы не просто хотим конвертировать каждое подвыражение (число или идентификатор) само по себе.
Нам также нужно знать контекст, в котором это выражение будет использоваться.
Для этого используется продолжение ``expr_with_hole``.
Теперь давайте разберемся что происходит в случае бинарной операции.
Сначала преобразуем в ANF левую часть.
Так как функция ``anf`` принимает два аргумента, нам надо решить, как будет выглядеть второй аргумент-фукнция:

.. code-block:: ocaml

    | Plus (left, right) ->  anf left (fun ...)

За счет типов мы знаем, что аргумент этой функции будет с типом ``immexpr``.
Из рассуждения выше, мы может заключить, что это примитивное значение будет представлять результат левого аргумента.
Поэтому нам нужно его использовать как первый аргумент конструктора ``CPlus``:

.. code-block:: ocaml

    | Plus (left, right) ->
        anf left (fun lprim -> CPlus (lprim, ...))

Но нам нужно примитивное выражение для правой части тоже.
Поэтому надо рекурсивно запускать ``anf`` и для правого аргумента.
Поэтому, прежде чем пользоваться ``CPlus`` второй аргумент нужно посчитать:

.. code-block:: ocaml

    | Plus (left, right) ->
        anf left (fun lprim ->
          anf right (fun rprim ->
            CPlus (lprim, rprim)))

Итак мы запускаем ``anf`` на левой и правой части, затем  пользуемся  ``CPlus`` от   аргументов, посчитанных по-отдельности.

В это коде есть кое-что подозрительное, а именно случай для ``Plus`` не использует аргумент
``expr_with_hole`` вообще.
К тому же ошибка типизации: у функции ``expr_with_hole`` тип ``(immexpr -> aexpr)``, а мы возвращаем ``cexpr``, построенный с помощью конструктора ``CPlus``.
Давайте протрассируем нашу подозрительно написанную функцию, что понять что с ней не так.

.. code-block:: ocaml

    anf (Plus (Plus (Num 5, Num 4), Plus (Num 3, Num 2)))

    (* Подставляем большое подвыражение и разбираем случай Plus: *)

    =>  anf (Plus (Num 5, Num 4) (fun lprim ->
          anf (Plus (Num 3, Num 2)) (fun rprim ->
            CPlus (lprim, rprim)))

    (* Делаем рекурсивный вызов, снова случай Plus c аргументами Num 5 и Num 4.
      Не потеряли ли мы какую-то информацию? *)

    =>  anf (Num 5) (fun lprim ->
          anf (Num 4) (fun rprim ->
            CPlus (lprim, rprim)))

    (* Для случая констант мы **применяем** переданное продолжение к ImmNum: *)

    =>  ((fun lprim ->
          anf (Num 4) (fun rprim ->
            CPlus (lprim, rprim)))
         (ImmNum 5))

    =>  (anf (Num 4) (fun rprim -> CPlus (ImmNum 5, rprim)))

    =>  ((fun rprim -> CPlus (ImmNum 5, rprim)) (ImmNum 4))

    =>  CPlus (ImmNum 5, ImmNum 4)

Это не тот ответ, который мы хотели получить, потому что мы потеряли подвыражение ``Plus (Num 3, Num 2)``,
вычисляя левую часть.
Потеря произошла на втором шаге, где мы забыли воспользоваться функцией ``expr_with_hole``.
Поэтому нужно переписать случай конструктора ``Plus`` и воспользоваться аргументом ``expr_with_hole``:

.. code-block:: ocaml

      | Plus (left, right) ->
        anf left (fun lprim ->
          anf right (fun rprim ->
            (* где-то тут должен быть вызов  expr_with_hole... *)
            CPlus (lprim, rprim)))

Согласно рассуждениям выше, нам нужно применить функцию ``expr_with_hole`` к примитивному выражению, которое соответствует текущему выражению.
Другими словами, нужен идентификатор, который будет равен текущему выражению, которое соответствует сумме.
Нужно сделать одно let-связывание, которое равно выражению с конструктором ``Plus`` и передать его в ``expr_with_hole``:

.. code-block:: ocaml

    | Plus (left, right) ->
        anf left (fun lprim ->
          anf right (fun rprim ->
            ALet ("result_of_plus",
                  CPlus (lprim, rprim),
                  expr_with_hole (ImmId "result_of_plus"))))

Последняя вещь, которую надо обсудить, это как вызывать функцию ``and`` на самом верхнем уровне.
Если нам дано одинокое выражение, то что передавать как первое продолжение?
Задачей нашей функции является преобразование оригинального выражения.
Поэтому, если стартовый ``expr_with_hole`` просто возвращает примитивное выражение без изменений, то этого будет достаточно.

.. code-block:: ocaml

    anf original_expr (fun ie -> ACExpr (CImmExpr ie))

will be needed.

.. note:: Упражнение

    Протрассируйте

    .. code-block:: ocaml

        anf (Plus (Plus (Num 5, Num 4), Plus (Num 3, Num 2)))
            (fun ie -> ACExpr(CImmExpr(ie)))

    Is the result what you expected? Does it exactly match the test case we wrote?


Некоторые замечания
===================

Случай с ``let``
****************

Рассмотрим случай конструкции ``let``:

.. code-block:: ocaml

    | Let(x, value, body) ->      ...

Исходя из вышесказанного, нам нужно преобразоваться правую часть ``rhs`` и ``where``, а затем передать примитивное значение, обозначающее результат вычисления ``where`` в продолжение ``expr_with_hole``.
Также нужно не забыть исходный ``let`` с идентификатором, который был введен.

.. code-block:: ocaml

    | Let(x, rhs, where) ->
        anf rhs (fun immval ->
          ALet(x, CImmExpr immval,
            anf where (fun immbody ->
              (expr_with_hole immbody))))

Этот код можно написать чище, используя $\eta$-конверсию.

.. code-block:: ocaml

    | Let(x, rhs, where) ->
        anf rhs (fun immval ->
          ALet(x, CImmExpr immval,
            anf where expr_with_hole))

В примере выше мы просто передаем продолжение дальше по ходу преобразования нашего выражения.

Порождение свежих идентификаторов
*********************************

Другая вещь, которую стоит прояснить --- это порождение свежих имен при использовании конструкторов ``ALet``.
Мы не можем везде писать ``result_of_plus`` как выше, потому что рано или поздно новый ``let`` скорет в области видимости переменную, объявленную выше.

.. code-block:: ocaml
    :caption: Результат  ANF, где новые идентификаторов слились

    (5 + 4) + (3 + 2)
    (* становится *)
    let result_of_plus = 5 + 4 in
    let result_of_plus = 3 + 2 in
    let result_of_plus = result_of_plus + result_of_plus in
    result_of_plus

Программа выше вычисляется не в тот результат, что было задумано.
Поэтому, нужен метод порождения новых идентификаторов на лету так, чтобы они не конфликтовали с предыдущими введенными.
Простейшим вариантом будет использование мутабельного счетчика уже введенных переменных, и функции, которая порождает свежие имена, каждый раз инкрементируя этот счетчик.

.. code-block:: ocaml

    let gen_temp =
      let count = ref 0 in
      fun base ->
        count := !count + 1;
        sprintf "temp_%s_%d" base !count

В этом случае разбор операции сложения будет выглядеть следующим образом:

.. code-block:: ocaml

    | Plus(left, right) ->
        let varname = gen_temp "result_of_plus" in
        anf left (fun lprim ->
          anf right (fun rprim ->
            ALet(varname, CPlus (lprim, rprim),
              expr_with_hole (ImmId varname))))

И в результате получится следующий код:

.. code-block:: ocaml

    (5 + 4) + (3 + 2)
    (* становится *)
    let result_of_plus1 = 5 + 4 in
    let result_of_plus2 = 3 + 2 in
    let result_of_plus3 = result_of_plus1 + result_of_plus2 in
    result_of_plus3

Пример выше вычисляется в 14, т.е. то, что мы ожидали.
Если мы будем использовать "v" вместо "result_of_plus", то получим код, показанный в изначальных примерах.


Борьба с "мусорными" ``let``-связываниями
*****************************************

Рассмотрим следующий пример повнимательнее.


.. code-block:: ocaml

    (5 + 4) + (3 + 2)
    (* становится *)
    let v1 = 5 + 4 in
    let v2 = 3 + 2 in
    let v3 = v1 + v2 in
    v3

Это не вполне соответствует тому, что мы написали в самом начале, так как тут присутвует третий ``let``:

.. code-block:: ocaml

    let v1 = 5 + 4 in
    let v2 = 3 + 2 in
    v1 + v2

Складывается ощущение, что мы делаем какую-то лишнюю работу.
В данном изложении излагается ANF преобразование в самом простом его виде.
Существуют модификации, которые позволяют создавать меньше промежуточных переменных.
Одним из подходов является разделение преобразования на две взаимно рекурсивные функции со следующими сигнатурами:


.. code-block:: ocaml

    let rec anf_c (e : expr) (expr_with_c_hole : cexpr -> aexpr) : aexpr = ...

    let rec anf_imm (e : expr) (expr_with_imm_hole : immexpr -> aexpr) : aexpr = ...

Первая будет вызываться в контексте, когда нужно построить ``cexpr``, а вторая --- примитивное выражение.

Борьба с "мусорными" ``let``-связываниями
*****************************************
