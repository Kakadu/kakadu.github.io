<!DOCTYPE html>

<html lang="ru" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Хвостовая рекурсия. Продолжения &#8212; документация FP и RISC-V </title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css?v=2bf1fcf8" />
    
    <script src="_static/documentation_options.js?v=372fde1a"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=cd1d70c9"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <link rel="index" title="Алфавитный указатель" href="genindex.html" />
    <link rel="search" title="Поиск" href="search.html" />
    <link rel="next" title="ANF представление" href="041anf.html" />
    <link rel="prev" title="Тестирование с помощью QuickCheck" href="036quickcheck.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Навигация</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Алфавитный указатель"
             accesskey="I">указатель</a></li>
        <li class="right" >
          <a href="041anf.html" title="ANF представление"
             accesskey="N">вперёд</a> |</li>
        <li class="right" >
          <a href="036quickcheck.html" title="Тестирование с помощью QuickCheck"
             accesskey="P">назад</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">документация FP и RISC-V </a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Хвостовая рекурсия. Продолжения</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="id1">
<h1><a class="toc-backref" href="#id10" role="doc-backlink">Хвостовая рекурсия. Продолжения</a><a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h1>
<nav class="contents" id="id2">
<p class="topic-title">Оглавление</p>
<ul class="simple">
<li><p><a class="reference internal" href="#id1" id="id10">Хвостовая рекурсия. Продолжения</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id11"><a class="reference internal" href="998glossary.html#term-1"><span class="xref std std-term">Хвостовая рекурсия</span></a></a></p></li>
<li><p><a class="reference internal" href="#id5" id="id12">Демонстрация переполнения стека</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id13"><a class="reference internal" href="998glossary.html#term-Continuation"><span class="xref std std-term">Продолжения</span></a></a></p></li>
</ul>
</li>
</ul>
</nav>
<p>Стиль программирования с использованием продолжений (англ. <a class="reference internal" href="998glossary.html#term-Continuation"><span class="xref std std-term">continuation</span></a>) часто ассоциируется именно с функциональным программированием.
Продолжения</p>
<ul class="simple">
<li><p>позволяют писать корректные программы для больших входных данных, по сравнению с обычным (<a class="reference internal" href="998glossary.html#term-Direct"><span class="xref std std-term">direct</span></a>) стилем написания функций;</p></li>
<li><p>являются подходом к проектированию программ, которые иногда делает программы более понятными.</p></li>
</ul>
<section id="id3">
<h2><a class="toc-backref" href="#id11" role="doc-backlink"><a class="reference internal" href="998glossary.html#term-1"><span class="xref std std-term">Хвостовая рекурсия</span></a></a><a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h2>
<p>Функциональное программирование порицает повсеместное использование циклов, и рекомендует использование рекурсивных функций.
Но их использование чревато появлением неэффективных программ (<a class="reference internal" href="998glossary.html#term-2"><span class="xref std std-term">пессимизация</span></a>) из-за того, что вызовы функций обычно сопровождаются выделением кадров (англ. fram) на стеке.
Для больших входных данных это может привести переполнению стека и аварийному завершению программ.</p>
<p>Чтобы этого не случалось, компиляторы функциональных языков используют <strong>оптимизацию хвостовой рекурсии</strong>, компилируя удачно написанные программы так, чтобы стек не тратился.</p>
<p>Рассмотрим канонический пример факториала. В строке 3 происходит рекурсивный вызов, во время которого происходит создание нового фрейма и потребления стека</p>
<div class="highlight-ocaml notranslate" id="factorialnaive"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">fac</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span><span class="o">&lt;</span><span class="mi">2</span> <span class="k">then</span> <span class="mi">1</span>
<span class="hll">  <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fac</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span></pre></div>
</div>
<div class="admonition- admonition">
<p class="admonition-title">Хвостовой вызов</p>
<p>Вызов в теле функции f какой-то функции g, является хвостовым, если результатом выполнения f является результат этого вызова g. При этом f и g могут быть одной и той же функцией.</p>
</div>
<p>В  <a class="reference internal" href="#factorialnaive"><span class="std std-ref">примере</span></a> выше рекурсивный вызов функции <cite>fac</cite> не является хвостовым, потому что для получения ответа нужно результат рекурсивного вызова ещё домножить на <cite>n</cite>.
Но эту функцию можно легко переписать, чтобы получались рекурсивные вызовы.</p>
<div class="highlight-ocaml notranslate" id="factorialacc"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">fac_helper</span> <span class="n">acc</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span><span class="o">&lt;</span><span class="mi">2</span> <span class="k">then</span> <span class="n">acc</span>
  <span class="k">else</span> <span class="n">fac_helper</span> <span class="o">(</span><span class="n">acc</span><span class="o">*</span><span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>

<span class="k">let</span> <span class="n">fac</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fac_helper</span> <span class="mi">1</span> <span class="n">n</span>
</pre></div>
</div>
<p>Здесь мы создали дополнительную функцию, которая принимает не только число n, но и накапливает посчитанный ответ.
Рекурсивный  вызов функции <cite>fac_helper</cite> является хвостовым по определению.</p>
<div class="highlight-ocaml notranslate" id="oddeven"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">odd</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span> <span class="k">then</span> <span class="bp">true</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span> <span class="k">then</span> <span class="bp">false</span>
  <span class="k">else</span> <span class="n">even</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
<span class="k">and</span> <span class="n">even</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span> <span class="k">then</span> <span class="bp">true</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span> <span class="k">then</span> <span class="bp">false</span>
  <span class="k">else</span> <span class="n">odd</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>
<p>Ещё один пример хвостовой рекурсии: проверка на четность натурального числа весьма неэффективным способом.
В нём производятся хвостовые функции не самой функции, а другой, но компилятор всё ещё оптимизирует такие вызовы.</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="c">(* incompilable code *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">fac</span> <span class="n">n</span> <span class="o">=</span>
<span class="hll">  <span class="k">if</span> <span class="n">n</span><span class="o">&lt;</span><span class="mi">2</span> <span class="k">then</span> <span class="mi">1</span>
</span>  <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="o">(</span><span class="n">fac</span><span class="o">[@</span><span class="n">tailcall</span><span class="o">])</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>
<p>В процессе работы, если программист не уверен, то он может явно аннотировать вызов функции как хвостовой.
В примере выше был так аннотирован <strong>нехвостовой</strong> вызов, поэтому выдаст предупреждение 51: wrong-tailcall-expectation.</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="c">(* incompilable code *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">fac</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">acc</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">1</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span> <span class="k">to</span> <span class="n">n</span> <span class="k">do</span>
    <span class="n">acc</span> <span class="o">:=</span> <span class="o">!</span><span class="n">acc</span> <span class="o">*</span> <span class="n">i</span>
  <span class="k">done</span><span class="o">;</span>
  <span class="o">!</span><span class="n">acc</span>
</pre></div>
</div>
<p>Читатель может подумать, что для хвостовая рекурсия — это искусственная сложность, а на самом деле стоит пользоваться циклами. Действительно, можно реализовать факториал с помощью цикла на OCaml.
Но в данном случае компилятор OCaml породит менее эффективный код, чем с хвостовой рекурсией.
Для вызовов функций аргументы передаются через регистры процессора, и на практике хвостовая рекурсия в OCaml будет примерно эквивалентна вычислению факториала циклом на Си.
В случае использования мутабельных ссылок, компилятор OCaml готовится к тому, чтобы передавать эти мутабельные ссылки как значения в другие функции.
Поэтому он выделяет место под ссылки в куче, что пессимизирует программу.</p>
<p>Оптимизация хвостовой рекурсии возможна и в других языках, не обязательно функциональных. (Например Gcc справляется с оптимизацией факториала и функций odd/even начиная с <cite>-O2</cite>.)
Но если в языке присутствует выделение памяти (например, С++) на стеке, то ситуация <a class="reference external" href="https://quuxplusone.github.io/blog/2021/01/09/tail-call-optimization">осложняется</a>,
так как при удалении фрейма нужно ещё вызывать деструторы локальных значений.</p>
<p>К сожалению, трюк с использованием аккумулятора не всегда срабатывает, а именно непонятно что делать, если функция вызывает себя больше одного раза. Каноническим примером является экспоненциальное  вычисление чисел Фибоначчи.</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">fib_exp</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span><span class="o">&lt;</span><span class="mi">2</span> <span class="k">then</span> <span class="n">n</span>
  <span class="k">else</span> <span class="n">fib_exp</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fib_exp</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">)</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">fib_acc</span> <span class="n">a</span> <span class="n">b</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span> <span class="k">then</span> <span class="n">a</span>
  <span class="k">else</span> <span class="n">fib_acc</span> <span class="n">b</span> <span class="o">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>

<span class="k">let</span> <span class="n">fib</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fib_acc</span> <span class="mi">0</span> <span class="mi">1</span> <span class="n">n</span>
</pre></div>
</div>
<p>Здесь одним аккумултором не обойтись, так как рекурсивные вызовы нужно сначала вычислить, а потому просуммировать результаты.
Для успешного использования аккумуляторов нужно их вводить в двух экземплярах, что помимо оптимизации хвостовой рекурсии превратит экспоненциальную асимптотику в линейную.
Такое переписывание очевидно, если заранее знать ответ, иначе требует некоторой эврики.
Как систематически придумывать такие оптимизации мы коснемся в главе <a class="reference internal" href="998glossary.html#term-0"><span class="xref std std-term">схемы рекурсии</span></a>.</p>
</section>
<section id="id5">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Демонстрация переполнения стека</a><a class="headerlink" href="#id5" title="Ссылка на этот заголовок">¶</a></h2>
<p>Рассмотрим программу с использование деревьев, где слишком большой вход приводит к ошибке времени исполнения.
Будем рассматривать бинарные деревья и писать функцию, которая вычисляет размер деревьев.
Полный код доступен по <a class="reference external" href="https://gitlab.com/Kakadu/fp2020course-materials/-/blob/master/code/cps/cps_main.ml">ссылке</a></p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">tree</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="n">tree</span> <span class="o">*</span> <span class="n">tree</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">make</span> <span class="n">depth</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">depth</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="nc">Leaf</span>
  <span class="k">else</span>
    <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">make</span> <span class="o">(</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="k">if</span> <span class="n">depth</span> <span class="ow">mod</span> <span class="mi">100000</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">r</span> <span class="k">else</span> <span class="nc">Leaf</span> <span class="k">in</span>
    <span class="nc">Node</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>

<span class="k">let</span> <span class="n">size</span> <span class="n">root</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">helper</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="mi">0</span>
    <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">helper</span> <span class="n">l</span> <span class="o">+</span> <span class="n">helper</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">in</span>
  <span class="n">helper</span> <span class="n">root</span>
</pre></div>
</div>
<p>Мы строим дерево заданной глубины с помощью функции <cite>make</cite>, при этом нам не очень важно наполнение дерева, поэтому левое поддерево мы получается невырожденным довольно редко. (Построение полного дерева может исчерпать всю оперативную память.)
В функции <cite>size</cite> мы вычисляем количество конструкторов <cite>Node</cite> два раза вызываясь рекурсивно.</p>
<p>Тестирование показывает, что код работает корректно для глубины 174716, но для глубины на единицу больше — аварийно завершается из-за переполнения стека.</p>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Откуда берется эта магическая константа?</p>
<p>Мы проводим испытания с помощью компилятора OCaml 4.14.2 на платформе GNU/Linux.
Программа компилируется в переносимый байт-код, а не в native code, потому что в последнем случае затруднительно отличить переполнение стека от произвольной ошибки сегментации.
В OCaml версии 5 были разработаны обработчики алгебраических эффектов, и реализация стеков была переработана. При использовании динамически растущих сегментированных стеков (англ. fibers) воспроизвести переполнение стека несколько сложнее. Пользуйтесь заклинанием
<code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">_</span> <span class="pre">=</span> <span class="pre">Gc.set</span> <span class="pre">{</span> <span class="pre">(Gc.get())</span> <span class="pre">with</span> <span class="pre">stack_limit</span> <span class="pre">=</span> <span class="pre">100_000</span> <span class="pre">}</span></code></p>
</div>
<p>Таким образом, перед нами рекурсивная функция, которая не работает для достаточно большого входа, и которую не очевидно как переписать с использованием хвостовой рекурсии.
Заставить её выдавать правильный ответ чаще нам помогут <strong>продолжения</strong>.</p>
</section>
<section id="id7">
<h2><a class="toc-backref" href="#id13" role="doc-backlink"><a class="reference internal" href="998glossary.html#term-Continuation"><span class="xref std std-term">Продолжения</span></a></a><a class="headerlink" href="#id7" title="Ссылка на этот заголовок">¶</a></h2>
<p>Стиль написания кода с использованием продолжений как правило подразумевает</p>
<ul class="simple">
<li><p>в функции передается дополнительный аргумент-продолжение (как правило он называется <cite>k</cite>);</p></li>
<li><p>когда функция досчитала до ответа (сделал свою работу до конца), она <strong>продолжает</strong> исполнение программы, передавая ответ в функцию  <cite>k</cite>.</p></li>
</ul>
<p>Рассмотрим это на примере (специально написанного) вычисления чисел Фибоначчи</p>
<div class="highlight-ocaml notranslate" id="fibanf"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">fib</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span><span class="o">&lt;</span><span class="mi">2</span> <span class="k">then</span> <span class="n">n</span>
  <span class="k">else</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">)</span> <span class="k">in</span>
    <span class="n">a</span><span class="o">+</span><span class="n">b</span>
</pre></div>
</div>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">fibk</span> <span class="n">n</span> <span class="n">k</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span><span class="o">&lt;</span><span class="mi">2</span> <span class="k">then</span> <span class="n">k</span> <span class="n">n</span>
  <span class="k">else</span>
    <span class="n">fibk</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">a</span> <span class="o">-&gt;</span>
      <span class="n">fibk</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">b</span> <span class="o">-&gt;</span>
        <span class="n">k</span> <span class="o">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">)))</span>
</pre></div>
</div>
<p>Только что мы преобразовали функцию <cite>fib</cite> в функцию <cite>fibk</cite>, использующую стиль передачи продолжений (continuation passing style, CPS).
Нам пришлось:</p>
<ul>
<li><p>Добавить дополнительный аргумент <cite>k</cite>.</p></li>
<li><p>в then-ветви добавить вызов функции <cite>k</cite>, имея в виду, что искомое число Фибоначчи — это <cite>n</cite>, и надо продолжить вычисление с ним;</p></li>
<li><dl>
<dt>в else-ветви нам встретились рекурсивные вызовы fib, которые необходимо заменить на новые вызовы <cite>fibk</cite> и придумать содержимое дополнительного аргумента.</dt><dd><dl class="simple">
<dt>Заметим, что исходная функция</dt><dd><ul class="simple">
<li><p>вычисляла (n-1)-e число Фибоначчи и затем <strong>продолжала</strong> исполнение, вычисляя (n-2) число;</p></li>
<li><p>вычисляла (n-2)-e число Фибоначчи и затем <strong>продолжала</strong> исполнение, вычисляя сумму.</p></li>
</ul>
</dd>
</dl>
<p>Поэтому в первом продолжении мы рекурсивно вычисляем (n-2)-e число, а во втором вычисляем сумму и <strong>продолжаем</strong> вычисления с помощью <cite>k</cite>.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Обратите внимание на правило переписывание рекурсивного вызова: выражения вида
<code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">a...b</span> <span class="pre">in</span> <span class="pre">E</span></code> превращаются в <code class="docutils literal notranslate"><span class="pre">fk</span> <span class="pre">a...b</span> <span class="pre">(fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">...</span> <span class="pre">E</span> <span class="pre">...)</span></code></p>
</div>
<div class="admonition hint">
<p class="admonition-title">Подсказка</p>
<p>Такое переписывание программы может показаться чересчур инвазивным.
В принципе, можно подготовиться к переписыванию с помощью CPS-монады, и затем получить CPS реализации заменой конструкции <code class="docutils literal notranslate"><span class="pre">let</span></code> на кострукцию <code class="docutils literal notranslate"><span class="pre">let*</span></code> (она же <code class="docutils literal notranslate"><span class="pre">bind</span></code>).
Однако такой подход более уместен для языка Haskell, чем OCaml, потому что оптимизатор Haskell лучше справляется с таким монадическим кодом.</p>
</div>
<p>Переписывание в CPS изменяет типы функции систематическим образом, а именно функции с типом <code class="docutils literal notranslate"><span class="pre">A-&gt;B</span></code> превращаются в функции с типом <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">(B</span> <span class="pre">-&gt;</span> <span class="pre">'c)</span> <span class="pre">-&gt;</span> <span class="pre">'c</span></code>, где <code class="docutils literal notranslate"><span class="pre">A</span></code> и <code class="docutils literal notranslate"><span class="pre">B</span></code> — это какие-то типы, а <code class="docutils literal notranslate"><span class="pre">'c</span></code> — полиморфная типовая переменная.
Наличие полиморфизма в этом случае важно, оно означает, что продолжать исполнение функции можно в любом контексте: полученное число Фибоначчи можно преобразовывать в <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">string</span></code> или любой другой тип.</p>
<p>Полученная функция <code class="docutils literal notranslate"><span class="pre">fibk</span></code> отличается по сигнатуре от оригинальной функции <code class="docutils literal notranslate"><span class="pre">fib</span></code>: <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">(int</span> <span class="pre">-&gt;</span> <span class="pre">'a)</span> <span class="pre">-&gt;</span> <span class="pre">'a</span></code> vs. <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code>.
Можно получить оригинальную функцию из <code class="docutils literal notranslate"><span class="pre">fibk</span></code>, подставив тождественное отображение вместо продолжения</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">fib</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fib</span> <span class="n">n</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">)</span>
</pre></div>
</div>
<p>При осуществелнии CPS преобразования встречаются две типичные ошибки</p>
<ul class="simple">
<li><p>Можно забыть вызвать продолжение в случае, если в ответе нет вызовов функций (например, в реализации <code class="docutils literal notranslate"><span class="pre">fibk</span></code> написать вместо <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">n</span></code> просто <code class="docutils literal notranslate"><span class="pre">n</span></code>). В этом случае программа скомпилируется, но тип CPS функции сузится до <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">(int</span> <span class="pre">-&gt;</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code> и никакого полиморфизма не будет.</p></li>
<li><p>Можно передавать вырожденное продолжение в рекурсивном вызове, продолжая писать код в direct стиле. В таком случае программ продолжит давать правильный ответ, при этом потребляя стек.</p></li>
</ul>
<div class="literal-block-wrapper docutils container" id="id9">
<div class="code-block-caption"><span class="caption-text">Функция фибоначчи в CPS представлении с двумя ошибками</span><a class="headerlink" href="#id9" title="Ссылка на этот код">¶</a></div>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">fibk</span> <span class="n">n</span> <span class="n">k</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span><span class="o">&lt;</span><span class="mi">2</span> <span class="k">then</span> <span class="n">n</span> <span class="c">(* тут *)</span>
  <span class="k">else</span>
    <span class="n">fibk</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">a</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fibk</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">)</span> <span class="k">in</span> <span class="c">(* и тут *)</span>
      <span class="n">k</span> <span class="o">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">))</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Continuation vs callback</p>
<p>В литературе встречается похоже на продолжение понятие callback.
Это более общее понятие, чем продолжения.
Продолжения должны вызываться один раз в ветви исполнения программы после получения ответа, а callback’и — нет.</p>
</div>
<p>Общая схема трансляции выражений:</p>
<div class="math notranslate nohighlight">
\[\begin{split}C(k,1)  &amp;=  k\ 1 \\
C(k,ident)  &amp;=  k\ ident \\
C(e_1+e_2, k)  &amp;=  C(e_1, (\lambda\ r_1 \rightarrow \\
               &amp;=  C(e_2, (\lambda\ r_2 \rightarrow k(r_1+r_2)))))\\
C(k, f\ e_1 \dots e_n)  &amp;=  f_k\ e_1 \dots\ e_n\end{split}\]</div>
<p>Общая схема трансляции верхнеуровневых let-связываний (<span class="math notranslate nohighlight">\(\kappa\)</span> — свежий идентификатор):</p>
<div class="math notranslate nohighlight">
\[C_{si}(\text{let rec }f\ a_1\ldots a_n\ \textbf{=}\ e_b)  = \text{let rec }f_k\ a_1\ldots a_n =\ \kappa\ \textbf{=}\ CPS(\kappa, e_b)\]</div>
<div class="admonition-todo admonition" id="id8">
<p class="admonition-title">План</p>
<p>контификация</p>
<p>порядок аргументов</p>
</div>
<p><a class="reference external" href="https://ps-tuebingen-courses.github.io/pl1-lecture-notes/15-continuations-1/continuations-1.html">https://ps-tuebingen-courses.github.io/pl1-lecture-notes/15-continuations-1/continuations-1.html</a></p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Оглавление</a></h3>
    <ul>
<li><a class="reference internal" href="#">Хвостовая рекурсия. Продолжения</a><ul>
<li><a class="reference internal" href="#id3"><span class="xref std std-term">Хвостовая рекурсия</span></a></li>
<li><a class="reference internal" href="#id5">Демонстрация переполнения стека</a></li>
<li><a class="reference internal" href="#id7"><span class="xref std std-term">Продолжения</span></a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Предыдущий раздел</h4>
    <p class="topless"><a href="036quickcheck.html"
                          title="предыдущая глава">Тестирование с помощью QuickCheck</a></p>
  </div>
  <div>
    <h4>Следующий раздел</h4>
    <p class="topless"><a href="041anf.html"
                          title="следующая глава"><span class="xref std std-term">ANF</span> представление</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Эта страница</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/040cps.rst.txt"
            rel="nofollow">Исходный текст</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Быстрый поиск</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Искать" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Навигация</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Алфавитный указатель"
             >указатель</a></li>
        <li class="right" >
          <a href="041anf.html" title="ANF представление"
             >вперёд</a> |</li>
        <li class="right" >
          <a href="036quickcheck.html" title="Тестирование с помощью QuickCheck"
             >назад</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">документация FP и RISC-V </a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Хвостовая рекурсия. Продолжения</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Авторские права 2025, Kakadu.
      Создано с использованием <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div>
  </body>
</html>