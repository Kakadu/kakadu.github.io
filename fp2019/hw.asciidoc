:source-highlighter: pygments
:pygments-style: monokai
:local-css-style: pastie
:toc:

Функциональное Программирование (матмех, осень 2019). Домашки
=============================================================
:Author: Dmitrii Kosarev a.k.a. Kakadu
:email:  Dmitrii.Kosarev@protonmail.ch


== Задачки для Скалолазов

Дополнительные, так как у них слишком короткий курс на Степике. Если надо будет ещё задачек -- напишите.

=== Алгоритм DPLL

Задача из мира математической логики про выполнимость формулы языка высказываний. В том году давал на экзамен. Сейчас хочу сам алгоритм  с какими-нибудь оптимизациями (например, hash consing).

Сам алгоритм должен довольно легко гуглиться.

=== Окологеймерская

Запустить моделирование мира, где персонажи что-то делают и куда-то стремятся.

NOTE: Детали обсуждаемы потом

=== Задача про верификацию и триплеты Хоара

Фиксировано AST языка программирования с числами, условиями, присваиваниями и циклами. Программы аннотированы триплетами Хоара. Проверить, что аннотированы корректно.

Про триплеты Хоара по-русски можно читать, например, в книжке Герасимова "Математическая логика".

Выбравшему эту задачу можно упростить себе жизнь, выбрав правильный вариант домашки.

[[hw1234]]
== Домашки 1-4

Дальше идет N тем, которые будут определять задачи вида

. Напишите тип данных для представления программ на мини-языке.
. Сделайте парсер этого языка (как именно делать  будет сказано на лекции и немного в курсе Москвина)
. Сделайте интерпретатор языка (по аналогии с тем как мы писали `eval` для арифметических выражений на паре №2)
. Реализуйте какое-нибудь преобразование программ (детали будут специфичны для задачи).

Заметим, что задачи 2,3,4 зависят от №1, но не друг от друга. В процессе выполнения 2,3 и 4 может оказаться, что нужно поменять представление программ. Это нормально, т.е. то, что вы напишите в решение пункта 1 скорее всего не будет окончательным.

Далее ниже идут описания языков, у них неявно стоит

* приписка "мини"
* приписка "написать подробнее".

А также, если кто-то захочет решать одну и ту же задачу, но на разных языках (по-видимому, это будет Scala и
Haskell), то это нужно предварительно согласовать.

Если кто-то хочет подусложнить задачу и решать одну и ту же на одном и том же языке _вдвоем_, то можно также обсудить.

=== Python

Функции, переменные, присваивания, циклы, ветвления, анонимные функции -- стандартный набор большого количества языков. Потом какие-то языково-специфичные фичи.
Смотрите также на https://chocopy.org/[ChocoPy].

=== Ruby

Примерно как в Питоне.

=== Javascript

Стандартный набор языковых конструкций, прототипное наследование. Реализовать все фичи из
известного https://www.destroyallsoftware.com/talks/wat[видеообзора] Javascript

=== Kotlin

Тут из языково-специфичных фич обязательно должна быть какая-то поддержка ООП и вызова методов.

=== SQL

Язык запросов к реляционным базам данных. Различные конструкции можно погуглить. Задачей номер 4 будет скорее
всего какая-то оптимизация запросов.

=== Haskell

Числа, списки, функции, ленивая стратегия вычислений. Без пользовательских типов данных. В качесве пункта 4 --
хитрые оптимизации

=== LISP

LISP известен своими встроенными макросами. Посмотрите примерный синтаксис Scheme (или Common Lisp, и т.д.)
и напишите интерпретатор, который по дороге дает объявлять и использовать макросы. Вдруг у вас получатся
гигиенические?

=== Scala

Функции, числа и прочий стандартный набор фич. Специфичная для Scala часть языка -- traits.

=== OCaml with objects

Рекурсивные функции, числа, списки, присваивание и... объекты. Наверное, единственный язык, где ООП
сделано нормально (за счет структурной типизации и так называемого row полиморфизма).

Думаю, что тут проще всего будет меня уговорить назначить на двоих.

=== OCaml/Haskell with GADT

Обобщенные алгебраические типы данных, паттерн-матчинг, проверка типов для паттерн-мэтчинга
с использованием GADT.

Наверное, тут тоже можно парочку.

=== Lua

Интересный минималистичный язык, где в качестве универсальной структуры данных используется помесь
массива с хэш-таблицей, а для оптимизации вместо целых чисел используеются Double'ы.

=== Bourne Again SHell

Все, кто трогал линукс, видели эту штуку.

=== AWK

Предшественник языка Perl

=== Ideal Parallel Algol

Стандартный модельный язык для использования в научных ситуациях. Числа, присваивания, циклы, ветвления,
функции, а также операция запуска N кусков кода параллельно.

=== Cи

Интерпретатор языка с поддержкой арфиметики указателей.

=== Assembler

Выберите вид ассемблера, который хорошо работает на вашем компьютере/процессоре и почитайте
виды регистров в данной архитектуре. Реализуйте интерпретатор. Преобразование программ из
задания 4 скорее всего будет про автоматическую векторизацию. Если по дороге окажется, что
Вы научились генерировать настоящий ELF файл, который потом можно отдельно исполнить --
вообще будет круто.

=== Datalog

Простейший представитель логического программирования. Спека должна быть легко находима
в интернетах

=== NFA

Язык задания недетерминированных конченых автоматов, реализовать вычислитель таких автоматов.
В качестве №4 будет конвертация в детерминирванный или что-то подобное.

[[refal]]
=== РеФаЛ

Отечественный язык программирования. Вдохновения черпать
https://github.com/bmstu-iu9/refal-5-lambda[отсюда].

=== Forth

Так называемый стековый язык программирования, мало похож на всё остальное. Считается
языком с легко расширяемым синтаксисом.

=== Promela

Входной язык для утилиты верификации https://en.wikipedia.org/wiki/Promela[Promela].

=== YACC

Язык описания синтаксических анализаторов (парсеров). Скорее всего его придется сильно упростить
(без action code'а, описания ассоциативности и приоритетов операций).
К нему обычно прилагается утилита, которая по описанию генерирует парсер. Сделайте что-то подобное,
генерируя по описанию парсера код на Haskell/Scala, который выполняет синтаксический анализ.
Расширениями генерации можно выбрать, например, устранение левой рекурсии.

[[hw5]]
== Домашки №5

Скорее всего про структуры данных

[[hw6]]
== Домашки №6

Скорее всего про динамическое программирование


ifdef::backend-docbook[]
[index]
Example Index
-------------
////////////////////////////////////////////////////////////////
The index is normally left completely empty, it's contents being
generated automatically by the DocBook toolchain.
////////////////////////////////////////////////////////////////
endif::backend-docbook[]
