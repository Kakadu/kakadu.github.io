:source-highlighter: pygments
:pygments-style: monokai
:local-css-style: pastie
:toc:

Функциональное Программирование (матмех, осень 2019). Домашки
=============================================================
:Author: Dmitrii Kosarev a.k.a. Kakadu
:email:  Dmitrii.Kosarev@protonmail.ch

Переход на link:index.html[главную страницу курса]

// == Задачки для Скалолазов

// Дополнительные, так как у них слишком короткий курс на Степике. Если надо будет ещё задачек -- напишите.

// === Алгоритм DPLL

// Задача из мира математической логики про выполнимость формулы языка высказываний. В том году давал на экзамен. Сейчас хочу сам алгоритм с какими-нибудь оптимизациями (например, hash consing).

// Сам алгоритм должен довольно легко гуглиться.

// === Окологеймерская

// Запустить моделирование мира, где персонажи что-то делают и куда-то стремятся.

// NOTE: Детали обсуждаемы потом

// === Задача про верификацию и триплеты Хоара

// Фиксировано AST языка программирования с числами, условиями, присваиваниями и циклами. Программы аннотированы триплетами Хоара. Проверить, что аннотированы корректно.

// Про триплеты Хоара по-русски можно читать, например, в книжке Герасимова "Математическая логика".

// Выбравшему эту задачу можно упростить себе жизнь, выбрав правильный вариант домашки.

[[hw1234]]
== Домашки 1-4

Дальше идет N тем, которые будут определять задачи вида

. Напишите тип данных для представления программ на мини-языке.
. Сделайте парсер этого языка (как именно делать  будет сказано на лекции и немного в курсе Москвина)
. Сделайте интерпретатор языка (по аналогии с тем как мы писали `eval` для арифметических выражений на паре №2)
. Реализуйте какое-нибудь преобразование программ (детали будут специфичны для задачи).

Заметим, что задачи 2,3,4 зависят от №1, но не друг от друга. В процессе выполнения 2,3 и 4 может оказаться, что нужно поменять представление программ. Это нормально, т.е. то, что вы напишите в решение пункта 1 скорее всего не будет окончательным.

Далее ниже идут описания языков, у них неявно стоит

* приписка "мини"
* приписка "написать подробнее".

А также, если кто-то захочет решать одну и ту же задачу, но на разных языках (по-видимому, это будет Scala и
Haskell), то это нужно предварительно согласовать.

Если кто-то хочет подусложнить задачу и решать одну и ту же на одном и том же языке _вдвоем_, то можно также обсудить.

Проверяться будет как программа работает, а также будут вопросы по коду программы (потому что все задачи гуглятся).
Засылать готовые решения надо с помощью merge request в https://gitlab.com/Kakadu/haskell-course2019-hw[этот репозиторий].

[[lua]]
=== Lua (Цириков)

Интересный минималистичный язык, где в качестве универсальной структуры данных используется помесь
массива с хэш-таблицей, а для оптимизации вместо целых чисел используеются Double'ы.

[[sql]]
=== SQL (Погожельская)

Язык запросов к реляционным базам данных, давал в том году на экзамене. Различные конструкции можно погуглить. Задачей номер 4 будет скорее
всего какая-то оптимизация запросов.

+++ <details><summary> +++
[.underline]#*Подробнее (спойлер)*#
+++ </summary><div> +++

Необходимо реализовать минисистему баз данных. Программа должна уметь дампить информацию в файл, восстанавливать из файла и выполнять (парсер + интерпретатор) запросы к базе данных в интерактивном режиме. Для ввода-вывода данных в/из файл парсер и принтер писать не обязательно, можно обойтись более прямолинейными способами; парсер нужен только для языка запросов SQL. Список запросов возьмем сокращенно-стандартный. Конкретный синтаксис посмотрите в документации к, например, mySQL, здесь я напишу только несколько примеров.

. Создание таблиц. Из типов давайте оставим только Int и String (который в базах данных обычно называется VarChar)
+
--
----
CREATE TABLE table1 ( String FirstName
                    , String LastName
                    , Int Id
                    , Int Age)
----
--
. Добавление данных в таблицу. Если кто-то добавляет Int туда, где ожидался тип String -- выругиваться.
+
--
----
INSERT INTO table1 VALUES ('vasya','pupkin',1,2),
                          ('ivan', 'ivanov',2,2)
----
--
. Выбор данных из таблицы с выдачей табличного результата
+
--
----
SELECT * FROM  table1
----

или

----
SELECT (FirstName,LastName) FROM table1 WHERE Age>18
----
--

. Удаление данных из таблицы
+
----
REMOVE FROM table1 WHERE Age>18
----
. Join (он же inner join) таблиц, который формально является декартовом перемножением всех строчек в таблицах с последующей фильтрацией. Можно также поддержать другие JOIN'ы (LEFT, OUTER, CROSS). Они работают чуть-чуть по-другому.
+
--
----
SELECT (a, tableX.id, tableY.id) FROM tableX
   JOIN tableY
   ON table1.id = table2.somekey
----
или даже вложенные join'ы
----
SELECT * FROM A
  JOIN (B JOIN C ON B.fkC = C.pk)
  ON A.optionalfkB = B.pk
----
--
. Хранимые процедуры (у всех есть, и тут пусть будут)


В качестве задачи 4 будут какие-то оптимизации запросов, например

- Вложенные join'ы должен вычисляться не в стиле generate&filter, а как-нибудь более оптимально.
- Что-то ещё, пока не придумал.

+++ </div></details> +++

=== Bourne Again SHell (Абзалов)

Все, кто трогал линукс, видели эту штуку.

+++ <details><summary> +++
[.underline]#*Подробнее (спойлер)*#
+++ </summary><div> +++

В качестве BASH можно попробовать делать другой shell, если Вам он будет больше нравиться или Вы им постоянно пользуетесь на компьютере. В итоге хочется получить как минимум интерактивный интерпретатор shell, который можно
попробовать запустить вместо того, что у вас запускается сейчас на входе в GNU/Linux. Обратите внимание, что
те слова, которые есть в программе, bash впервую очередь пытается интерпретировать как вызов системной утилиты
(например, у меня на компьютере есть `/usr/bin/[`, но нет `/usr/bin/[[`), а только потом интерпретировать по-своему. Из этого следует, что Ваш интепретатор должен уметь по ходу делать и выполнять IO действия, и поддерживать в каком-то виде сообщения об ошибках. Обратите также внимание, что системный bash работает, как интепретатор, т.е. перемежает исполнение с синтаксическим анализом.
----
$ cat /tmp/1.sh
printf "1\n"
if [[[[ asdfasdf ]]]]; then echo 33; fi
printf "2\n"
$ bash /tmp/1.sh
1
/tmp/1.sh: ligne 2: [[[[ : commande introuvable
2
----
Для тестирования программ часто используют квайны -- программы печатающие сами себя. Протестируйте интерпретатор на десятке квайнов, реализуйте те функции интерпретатора, которые нужна для запуска этих квайнов. Например,
https://frishit.wordpress.com/2010/04/26/paradoxes-self-reproducing-code-and-bash/[это], или
----
$ s='s=\47%s\47; printf "$s" "$s"'; printf "$s" "$s"
s='s=\47%s\47; printf "$s" "$s"'; printf "$s" "$s"
$ echo 'echo $BASH_COMMAND'
echo $BASH_COMMAND
----
Разумеется, нужно поддержать объявления функций и прочие управляющие конструкции, числа, ветвления, строки
+++ </div></details> +++

[[python]]
=== Python (Мирзазянов)

Функции, переменные, присваивания, циклы, ветвления, анонимные функции, массивы/списки -- стандартный набор большого количества языков. Смотрите также на https://chocopy.org/[ChocoPy].

Из языково-специфичных фич, я предлагаю
http://codeblog.dhananjaynene.com/2010/01/dynamically-adding-methods-with-metaprogramming-ruby-and-python/[динамическое дополнение методов].

В 2020м году надо будет добавить интернирование строк для усложнения парсера


[[ruby]]
=== Ruby (Привалихин)

Примерно как в Питоне. Функции, переменные, присваивания, циклы, ветвления, анонимные функции.

Из языково-специфичных фич, я предлагаю динамическое дополнение методов
http://codeblog.dhananjaynene.com/2010/01/dynamically-adding-methods-with-metaprogramming-ruby-and-python/[(как в питоне)]

[[javascript]]
=== Javascript (Рагимов)

Стандартный набор языковых конструкций. Реализовать все фичи из
известного https://www.destroyallsoftware.com/talks/wat[видеообзора] Javascript

Из специфичного для Javascript: прототипное наследование.

[[kotlin]]
=== Kotlin (Влаев + Кузиванов)

+++ <details><summary> +++
[.underline]#*Подробнее (спойлер)*#
+++ </summary><div> +++

AST делаете вместе, из языково-специфичных фич обязательно должны быть:

. Числа, строки, стнадартные операции над ними, массивы.
. Объявления классов и методов, статические тоже нужно, чтобы можно быть `main()` написать.
. Навороченного наследования не требую, наследования классов и интерфейсов не нужно. Пусть только будет в языке один захардкоженный тип `Object`, который надтип всего чего угодно.
. Разумеется `null`. Также давайте RuntimeExceptions -- которые громко падают, их поймать невозможно (т.е. `try` &`catch` добавлять не нужно) и аннотировать методы бросаемыми исключениями тоже не нужно.

Парсер должен легко параллелиться между людьми.

. Парсер в нормальном смысле этого слова
. Вложенные коменнтарии: конструкция `*/` должна заканчивать *последний* открытый комментарий, а не все сразу.
. В некоторых случаях в языке разумно иметь 2-мерный синтаксис, наверное для конструкции switch. Поддержите её и 2-мерный синтаксис там.
. Хочу, чтобы код мжно было писать, используя препроцессор (`#define` и прочее)

Интерпретатор

. Один пишет интерпретатор
. Второй генерирует настоящий JVM bytecode и его исполняет

Преобразования программ

. напишу потом

+++ </div></details> +++

[[awk]]
=== AWK (Афонина)

Предшественник языка Perl. Тут будет стандартный набор фич, плюс вещи специфичные для AWK.
Думаю, что стоит почитать http://www.grymoire.com/Unix/Awk.html[умную ссылку] про то, когда надо применять AWK,
а также подергать оттуда тестовых примеров.

[[haskell]]
=== Haskell (Канашин + Смирнов)

Числа, списки, функции, ленивая стратегия вычислений. Без пользовательских типов данных. В качестве пункта 4 --
хитрые оптимизации. Алгоритм вывода типов склоее всегл писать придется, так как вас двое. Написать
http://okmij.org/ftp/ML/generalization.html[_эффективный_] (почти линейный) алгоритм вывода типов может быть
[.line-through]#сложной# интересной задачей.

Из первых программ для тестирования нужны факториал и фибоначчи. Потом придется разобраться как применять
Scott (или кто там ещё) encoding, чтобы эмулировать индуктивные типы данных, которые в миниязык не добавлены.
Скорее всего будет ещё добавлено CPS преобразование программ и какие-то Haskell-специфичные оптимизации
(вот https://www.microsoft.com/en-us/research/uploads/prod/2019/03/eta.pdf[пример]).


[[lisp]]
=== LISP (Гордиенко)

LISP известен своими встроенными макросами. Посмотрите примерный синтаксис Scheme (или Common Lisp, и т.д.)
и напишите интерпретатор, который по дороге дает объявлять и использовать макросы. Вдруг у вас получатся
гигиенические?

[[C]]
=== Cи (Шапошников)

Как обычно, нужно поддержать основные конструкции языка: числа, строки (массивы чисел), ветвления, цикл
`while` и по желанию `for`, объявления и вызов функций.

Из Си-специфичного: массивы произвольной длины. Можете черпать вдохновение из https://bellard.org/tcc/[минималистичного компилятора].
Не надо пока делать:

. Объявления структур
. Числа отличные от `int` и HEX представление
. Хитрые методы инициализации структур/массивов.

Скорее всего будет подзадача про трансляцию этого мини-языка в x86 ассемблер (для простых функций `fibonacci` и `memcpy` это должно быть очень просто). Скорее всего будет полезно пообщаться с человеком, который решает задачу про assembler.


[[asm]]
=== Assembler (Суханова)

Выберите вид ассемблера, который хорошо работает на вашем компьютере/процессоре и почитайте
виды регистров в данной архитектуре. Реализуйте интерпретатор. Преобразование программ из
задания 4 скорее всего будет про автоматическую векторизацию. Если по дороге окажется, что
Вы научились генерировать настоящий ELF файл, который потом можно отдельно исполнить --
вообще будет круто.

[[datalog]]
=== Datalog (Логунов)

Простейший представитель логического программирования, подмножество Prolog. Итого там должны быть

. Предикаты
. *Произвольные* функциональные символы запрещены, хотя разрешается иметь захардкоженное количество функциаональных символов в программе
. Переменные
. Правила вывода новых фактов (a.k.a. Хорн клозы (Horn clauses))
. Способ задания базы данных известных фактов (a.k.a. аксимом)

Итого, программа состоит из "базы данных" фактов и запроса,  а интерпретатор
проверяет согласованность запроса с базой данных и говорит "да" или "нет". Из-за наложенных ограничений
процесс поиска всегда завершится.

Простейшей программой будет проверка чисел в стиле Пеано на четность/нечетность
(https://www.cs.cmu.edu/~fp/courses/15317-f17/lectures/18-datalog.pdf[страницы 2-3]).
Ну или поиск пути в графе (http://pages.cs.wisc.edu/~paris/cs784-s17/lectures/lecture7.pdf[страницы 1-2]).

[[nfa]]
=== NFA (Дулетов)

Язык задания недетерминированных конченых автоматов, реализовать вычислитель таких автоматов,
а такжен загрузку из файла (наверняка уже придумали какой-то стандартный формат для представления автоматов,
может быть graphviz?)
В качестве №4 будет конвертация в детерминирванный или что-то подобное.

[[promela]]
=== Promela (Лунёв)

Входной язык для утилиты верификации https://en.wikipedia.org/wiki/Promela[Promela]. Думаю, что все
фичи описаны в http://www.lacl.fr/dima/melo/spin.pdf[слайдах]. Весь "язык" компилируется (с помощью `pan`) в
конечный автомат, который умеет моделировать в том числе параллельные потоки. Короче, надо написать интерпретатор программ Promela, там в слайдах есть примеры, за одно разберетесь с примитивами синхронизации параллельных потоков.

[[forth]]
=== Forth (Ахметьянов)

Так называемый стековый язык программирования, мало похож на всё остальное. Считается
языком с легко расширяемым синтаксисом.

Думаю, что в качестве задачи 4 можно писать супероптимизатор такой, как
http://sovietov.com/app/forthwiz.html[тут]. Интерпретатор и парсер можно писать с прицелом на конструкции, используемые в супероптимизаторе

// sovietov's paper
// https://elibrary.ru/item.asp?id=39242589
// Haskellish
// https://groups.google.com/forum/?hl=en-GB#!searchin/comp.lang.forth/funforth%7Csort:date/comp.lang.forth/i9P8T97QDgw/_wxwpqMZlJwJ

//

[[ocaml_oop]]
=== OCaml with objects (Гамаонов)

Наверное, единственный язык, где ООП сделано нормально (за счет структурной типизации и
так называемого row-полиморфизма).

Подробнее:

. Числа, списки, строки и операции над ними
. Объекты и их рекурсивные методы вместо рекурсивных функций, поля объектов (мутабельные или нет)
. Ветвления, first class functions
. Создание (так называемых immediate) объектов, вызов методов, проверка до исполнения, что метод есть (другими словами -- проверка типов)
. Классы и наследование поддерживать не обязательно

Ещё подробнее прочиать и посмотреть какие-нибудь примеры программ и синтаксиса можно
https://ocaml.org/learn/tutorials/objects.html[тут],
https://caml.inria.fr/pub/docs/manual-ocaml/objectexamples.html[тут] или
https://dev.realworldocaml.org/objects.html[тут].


[[refal]]
=== РеФаЛ (Малец)

Отечественный язык программирования. Вдохновения черпать
https://github.com/bmstu-iu9/refal-5-lambda[отсюда].

[[yacc]]
=== YACC

Язык описания синтаксических анализаторов (парсеров). Скорее всего его придется сильно упростить
(без action code'а, описания ассоциативности и приоритетов операций).
К нему обычно прилагается утилита, которая по описанию генерирует парсер. Сделайте что-то подобное,
генерируя по описанию парсера код на Haskell/Scala, который выполняет синтаксический анализ.
Расширениями генерации можно выбрать, например, устранение левой рекурсии.

[[algol]]
=== Ideal Parallel Algol (1 человек)

Стандартный модельный язык для использования в научных ситуациях. Числа, ветвления, присваивания, барьеры
для чтения и записи, а также операция запуска N кусков кода параллельно.
Функции и циклы не добавляю, а хочу, чтобы были реализованы
несколько _моделей памяти_ для данной программы.

- sequentional consistency (SC). Исполнение программы произвольно перемежается между параллельными
участками и выполняет по одной инструкции. Самая интуитивная реализация, ни один процессор такой не соответствует.
- TSO -- модель процессоров x86. В ней возможны интересные поведения.
Если изначально `x = EAX = y = EBX = 0`, то после выполнения этих двух участков параллельного кода,
  x86 может остановиться в состоянии `EAX == 0 && EBX == 0`
....
#  Proc 1                           Proc 2
MOV  [x] ← 1         |         MOV  [y] ← 1
MOV  EAX ← [y]       |         MOV  EBX ← [x]
....

- может быть ещё какая-то модель памяти.

Вот https://people.mpi-sws.org/~viktor/wmc/operational.pdf[это] будет хорошей ссылкой, если уметь разбираться
в исчислениях (я планирую про это как-то рассказывать).

=== Extended Regexps

=== Visual Basic

=== Gallina

=== OCaml/Haskell with GADT (2 человека)

Числа, функции и обобщенные алгебраические типы данных, паттерн-матчинг, проверка типов для паттерн-мэтчинга
с использованием GADT.

Наверное, тут тоже можно парочку.

=== Scala (1-2 человека)

Функции, числа и прочий стандартный набор фич. Специфичная для Scala часть языка -- traits. Вообще, чтобы сделать это правильно там нужно прикручивать движок перебора с возвратами a la Datalog.

Наверное, можно притянуть на 2х человек, если алгоритм под капотом будет годный.

[[hw5]]
== Домашки №5

Скорее всего про структуры данных

[[hw6]]
== Домашки №6

Скорее всего про динамическое программирование


ifdef::backend-docbook[]
[index]
Example Index
-------------
////////////////////////////////////////////////////////////////
The index is normally left completely empty, it's contents being
generated automatically by the DocBook toolchain.
////////////////////////////////////////////////////////////////
endif::backend-docbook[]
