:source-highlighter: pygments
:pygments-style: monokai
:local-css-style: pastie
:toc:

Функциональное Программирование (матмех, осень 2019). Домашки
=============================================================
:Author: Dmitrii Kosarev a.k.a. Kakadu
:email:  Dmitrii.Kosarev@protonmail.ch

Переход на link:index.html[главную страницу курса]

== Задачки для Скалолазов

Дополнительные, так как у них слишком короткий курс на Степике. Если надо будет ещё задачек -- напишите.

=== Алгоритм DPLL

Задача из мира математической логики про выполнимость формулы языка высказываний. В том году давал на экзамен. Сейчас хочу сам алгоритм с какими-нибудь оптимизациями (например, hash consing).

Сам алгоритм должен довольно легко гуглиться.

=== Окологеймерская

Запустить моделирование мира, где персонажи что-то делают и куда-то стремятся.

NOTE: Детали обсуждаемы потом

=== Задача про верификацию и триплеты Хоара

Фиксировано AST языка программирования с числами, условиями, присваиваниями и циклами. Программы аннотированы триплетами Хоара. Проверить, что аннотированы корректно.

Про триплеты Хоара по-русски можно читать, например, в книжке Герасимова "Математическая логика".

Выбравшему эту задачу можно упростить себе жизнь, выбрав правильный вариант домашки.

[[hw1234]]
== Домашки 1-4

Дальше идет N тем, которые будут определять задачи вида

. Напишите тип данных для представления программ на мини-языке.
. Сделайте парсер этого языка (как именно делать  будет сказано на лекции и немного в курсе Москвина)
. Сделайте интерпретатор языка (по аналогии с тем как мы писали `eval` для арифметических выражений на паре №2)
. Реализуйте какое-нибудь преобразование программ (детали будут специфичны для задачи).

Заметим, что задачи 2,3,4 зависят от №1, но не друг от друга. В процессе выполнения 2,3 и 4 может оказаться, что нужно поменять представление программ. Это нормально, т.е. то, что вы напишите в решение пункта 1 скорее всего не будет окончательным.

Далее ниже идут описания языков, у них неявно стоит

* приписка "мини"
* приписка "написать подробнее".

А также, если кто-то захочет решать одну и ту же задачу, но на разных языках (по-видимому, это будет Scala и
Haskell), то это нужно предварительно согласовать.

Если кто-то хочет подусложнить задачу и решать одну и ту же на одном и том же языке _вдвоем_, то можно также обсудить.

Проверяться будет как программа работает, а также будут вопросы по коду программы (потому что все задачи гуглятся).

=== Lua (Цириков)

Интересный минималистичный язык, где в качестве универсальной структуры данных используется помесь
массива с хэш-таблицей, а для оптимизации вместо целых чисел используеются Double'ы.

=== SQL (Погожельская)

Язык запросов к реляционным базам данных, давал в том году на экзамене. Различные конструкции можно погуглить. Задачей номер 4 будет скорее
всего какая-то оптимизация запросов.

+++ <details><summary> +++
[.underline]#*Подробнее (спойлер)*#
+++ </summary><div> +++

Необходимо реализовать минисистему баз данных. Программа должна уметь дампить информацию в файл, восстанавливать из файла и выполнять (парсер + интерпретатор) запросы к базе данных в интерактивном режиме. Для ввода-вывода данных в/из файл парсер и принтер писать не обязательно, можно обойтись более прямолинейными способами; парсер нужен только для языка запросов SQL. Список запросов возьмем сокращенно-стандартный. Конкретный синтаксис посмотрите в документации к, например, mySQL, здесь я напишу только несколько примеров.

. Создание таблиц. Из типов давайте оставим только Int и String (который в базах данных обычно называется VarChar)
+
--
----
CREATE TABLE table1 ( String FirstName
                    , String LastName
                    , Int Id
                    , Int Age)
----
--
. Добавление данных в таблицу. Если кто-то добавляет Int туда, где ожидался тип String -- выругиваться.
+
--
----
INSERT INTO table1 VALUES ('vasya','pupkin',1,2),
                          ('ivan', 'ivanov',2,2)
----
--
. Выбор данных из таблицы с выдачей табличного результата
+
--
----
SELECT * FROM  table1
----

или

----
SELECT (FirstName,LastName) FROM table1 WHERE Age>18
----
--

. Удаление данных из таблицы
+
----
REMOVE FROM table1 WHERE Age>18
----
. Join (он же inner join) таблиц, который формально является декартовом перемножением всех строчек в таблицах с последующей фильтрацией. Можно также поддержать другие JOIN'ы (LEFT, OUTER, CROSS). Они работают чуть-чуть по-другому.
+
--
----
SELECT (a, tableX.id, tableY.id) FROM tableX
   JOIN tableY
   ON table1.id = table2.somekey
----
или даже вложенные join'ы
----
SELECT * FROM A
  JOIN (B JOIN C ON B.fkC = C.pk)
  ON A.optionalfkB = B.pk
----
--
. Хранимые процедуры (у всех есть, и тут пусть будут)


В качестве задачи 4 будут какие-то оптимизации запросов, например

- Вложенные join'ы должен вычисляться не в стиле generate&filter, а как-нибудь более оптимально.
- Что-то ещё, пока не придумал.

+++ </div></details> +++

=== Bourne Again SHell (Абзалов)

Все, кто трогал линукс, видели эту штуку.

+++ <details><summary> +++
[.underline]#*Подробнее (спойлер)*#
+++ </summary><div> +++

В качестве BASH можно попробовать делать другой shell, если Вам он будет больше нравиться или Вы им постоянно пользуетесь на компьютере. В итоге хочется получить как минимум интерактивный интерпретатор shell, который можно
попробовать запустить вместо того, что у вас запускается сейчас на входе в GNU/Linux. Обратите внимание, что
те слова, которые есть в программе, bash впервую очередь пытается интерпретировать как вызов системной утилиты
(например, у меня на компьютере есть `/usr/bin/[`, но нет `/usr/bin/[[`), а только потом интерпретировать по-своему. Из этого следует, что Ваш интепретатор должен уметь по ходу делать и выполнять IO действия, и поддерживать в каком-то виде сообщения об ошибках. Обратите также внимание, что системный bash работает, как интепретатор, т.е. перемежает исполнение с синтаксическим анализом.
----
$ cat /tmp/1.sh
printf "1\n"
if [[[[ asdfasdf ]]]]; then echo 33; fi
printf "2\n"
$ bash /tmp/1.sh
1
/tmp/1.sh: ligne 2: [[[[ : commande introuvable
2
----
Для тестирования программ часто используют квайны -- программы печатающие сами себя. Протестируйте интерпретатор на десятке квайнов, реализуйте те функции интерпретатора, которые нужна для запуска этих квайнов. Например,
https://frishit.wordpress.com/2010/04/26/paradoxes-self-reproducing-code-and-bash/[это], или
----
$ s='s=\47%s\47; printf "$s" "$s"'; printf "$s" "$s"
s='s=\47%s\47; printf "$s" "$s"'; printf "$s" "$s"
$ echo 'echo $BASH_COMMAND'
echo $BASH_COMMAND
----
Разумеется, нужно поддержать объявления функций и прочие управляющие конструкции, числа, ветвления, строки
+++ </div></details> +++

=== Python (Мирзазянов)

Функции, переменные, присваивания, циклы, ветвления, анонимные функции, массивы/списки -- стандартный набор большого количества языков. Смотрите также на https://chocopy.org/[ChocoPy].

Из языково-специфичных фич, я предлагаю
http://codeblog.dhananjaynene.com/2010/01/dynamically-adding-methods-with-metaprogramming-ruby-and-python/[динамическое дополнение методов].


=== Ruby (Привалихин)

Примерно как в Питоне. Функции, переменные, присваивания, циклы, ветвления, анонимные функции.

Из языково-специфичных фич, я предлагаю динамическое дополнение методов
http://codeblog.dhananjaynene.com/2010/01/dynamically-adding-methods-with-metaprogramming-ruby-and-python/[(как в питоне)]

=== Javascript (Рагимов)

Стандартный набор языковых конструкций. Реализовать все фичи из
известного https://www.destroyallsoftware.com/talks/wat[видеообзора] Javascript

Из специфичного для Javascript: прототипное наследование.

=== Kotlin (Влаев + ещё кто-то)

AST делаете вместе, из языково-специфичных фич обязательно должны быть:

. Числа, строки, стнадартные операции над ними, массивы.
. Объявления классов и методов, статические тоже нужно, чтобы можно быть `main()` написать.
. Навороченного наследования не требую, наследования классов и интерфейсов не нужно. Пусть только будет в языке один захардкоженный тип `Object`, который надтип всего чего угодно.
. Разумеется `null`. Также давайте RuntimeExceptions -- которые громко падают, их поймать невозможно (т.е. `try` &`catch` добавлять не нужно) и аннотировать методы бросаемыми исключениями тоже не нужно.

Парсер должен легко параллелиться между людьми.

. Парсер в нормальном смысле этого слова
. Вложенные коменнтарии: конструкция `*/` должна заканчивать *последний* открытый комментарий, а не все сразу.
. В некоторых случаях в языке разумно иметь 2-мерный синтаксис, наверное для конструкции switch. Поддержите её и 2-мерный синтаксис там.
. Хочу, чтобы код мжно было писать, используя препроцессор (`#define` и прочее)

Интерпретатор

. Один пишет интерпретатор
. Второй генерирует настоящий JVM bytecode и его исполняет

Преобразования программ

. напишу потом.


=== AWK (Афонина)

Предшественник языка Perl. Тут будет стандартный набор фич, плюс вещи специфичные для AWK.
Думаю, что стоит почитать http://www.grymoire.com/Unix/Awk.html[умную ссылку] про то, когда надо применять AWK,
а также подергать оттуда тестовых примеров.

=== Haskell (1-2 человека)

Числа, списки, функции, ленивая стратегия вычислений. Без пользовательских типов данных. В качестве пункта 4 --
хитрые оптимизации. Алгоритм вывода типов пока не включаю, но написать
http://okmij.org/ftp/ML/generalization.html[_эффективный_] (почти линейный) алгоритм вывода типов может быть
[.line-through]#сложной# интересной задачей.

Тут легко можно договориться на 2 человека.

=== LISP

LISP известен своими встроенными макросами. Посмотрите примерный синтаксис Scheme (или Common Lisp, и т.д.)
и напишите интерпретатор, который по дороге дает объявлять и использовать макросы. Вдруг у вас получатся
гигиенические?

=== Scala (1-2 человека)

Функции, числа и прочий стандартный набор фич. Специфичная для Scala часть языка -- traits. Вообще, чтобы сделать это правильно там нужно прикручивать движок перебора с возвратами a la Datalog.

Наверное, можно притянуть на 2х человек, если алгоритм под капотом будет годный.

=== OCaml with objects (2 человека)

Числа, списки, присваивание, объекты и их рекурсивные методы вместо рекурсивных функций.
Наверное, единственный язык, где ООП сделано нормально (за счет структурной типизации и
так называемого row-полиморфизма).

Думаю, что тут проще всего будет меня уговорить назначить на двоих.

=== OCaml/Haskell with GADT (2 человека)

Числа, функции и обобщенные алгебраические типы данных, паттерн-матчинг, проверка типов для паттерн-мэтчинга
с использованием GADT.

Наверное, тут тоже можно парочку.


=== Cи

Интерпретатор языка с поддержкой арфиметики указателей. Наверное будет несложно сделать, есть куча проектов в
интернетике про реализацию минималистичного компилятора Си в несколько сотен строчек.

=== Assembler

Выберите вид ассемблера, который хорошо работает на вашем компьютере/процессоре и почитайте
виды регистров в данной архитектуре. Реализуйте интерпретатор. Преобразование программ из
задания 4 скорее всего будет про автоматическую векторизацию. Если по дороге окажется, что
Вы научились генерировать настоящий ELF файл, который потом можно отдельно исполнить --
вообще будет круто.

=== Datalog

Простейший представитель логического программирования. Спека должна быть легко находима
в интернетах

=== NFA

Язык задания недетерминированных конченых автоматов, реализовать вычислитель таких автоматов,
а такжен загрузку из файла (наверняка уже придумали какой-то стандартный формат для представления автоматов,
может быть graphviz?)
В качестве №4 будет конвертация в детерминирванный или что-то подобное.

=== Extended Regexps



[[refal]]
=== РеФаЛ

Отечественный язык программирования. Вдохновения черпать
https://github.com/bmstu-iu9/refal-5-lambda[отсюда].

=== Forth

Так называемый стековый язык программирования, мало похож на всё остальное. Считается
языком с легко расширяемым синтаксисом.

=== Promela

Входной язык для утилиты верификации https://en.wikipedia.org/wiki/Promela[Promela].

=== YACC

Язык описания синтаксических анализаторов (парсеров). Скорее всего его придется сильно упростить
(без action code'а, описания ассоциативности и приоритетов операций).
К нему обычно прилагается утилита, которая по описанию генерирует парсер. Сделайте что-то подобное,
генерируя по описанию парсера код на Haskell/Scala, который выполняет синтаксический анализ.
Расширениями генерации можно выбрать, например, устранение левой рекурсии.

=== Ideal Parallel Algol (1 человек)

Стандартный модельный язык для использования в научных ситуациях. Числа, ветвления, присваивания, барьеры
для чтения и записи, а также операция запуска N кусков кода параллельно.
Функции и циклы не добавляю, а хочу, чтобы были реализованы
несколько _моделей памяти_ для данной программы.

- sequentional consistency (SC). Исполнение программы произвольно перемежается между параллельными
участками и выполняет по одной инструкции. Самая интуитивная реализация, ни один процессор такой не соответствует.
- TSO -- модель процессоров x86. В ней возможны интересные поведения.
Если изначально `x = EAX = y = EBX = 0`, то после выполнения этих двух участков параллельного кода,
  x86 может остановиться в состоянии `EAX == 0 && EBX == 0`
....
#  Proc 1                           Proc 2
MOV  [x] ← 1         |         MOV  [y] ← 1
MOV  EAX ← [y]       |         MOV  EBX ← [x]
....

- может быть ещё какая-то модель памяти.

Вот https://people.mpi-sws.org/~viktor/wmc/operational.pdf[это] будет хорошей ссылкой, если уметь разбираться
в исчислениях (я планирую про это как-то рассказывать).



[[hw5]]
== Домашки №5

Скорее всего про структуры данных

[[hw6]]
== Домашки №6

Скорее всего про динамическое программирование


ifdef::backend-docbook[]
[index]
Example Index
-------------
////////////////////////////////////////////////////////////////
The index is normally left completely empty, it's contents being
generated automatically by the DocBook toolchain.
////////////////////////////////////////////////////////////////
endif::backend-docbook[]
