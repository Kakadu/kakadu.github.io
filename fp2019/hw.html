<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<meta name="author" content="Dmitrii Kosarev a.k.a. Kakadu">
<title>Функциональное Программирование (матмех, осень 2019). Домашки</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="./pygments-monokai.css">
</head>
<body class="article">
<div id="header">
<h1>Функциональное Программирование (матмех, осень 2019). Домашки</h1>
<div class="details">
<span id="author" class="author">Dmitrii Kosarev a.k.a. Kakadu</span><br>
<span id="email" class="email"><a href="mailto:Dmitrii.Kosarev@protonmail.ch">Dmitrii.Kosarev@protonmail.ch</a></span><br>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#hw1234">Домашки 1-4</a>
<ul class="sectlevel2">
<li><a href="#lua">Lua (Цириков)</a></li>
<li><a href="#sql">SQL (Погожельская)</a></li>
<li><a href="#_bourne_again_shell_абзалов">Bourne Again SHell (Абзалов)</a></li>
<li><a href="#python">Python (Мирзазянов)</a></li>
<li><a href="#ruby">Ruby (Привалихин)</a></li>
<li><a href="#javascript">Javascript (Рагимов)</a></li>
<li><a href="#kotlin">Kotlin (Влаев + Кузиванов)</a></li>
<li><a href="#awk">AWK (Афонина)</a></li>
<li><a href="#haskell">Haskell (1-2 человека)</a></li>
<li><a href="#lisp">LISP</a></li>
<li><a href="#_scala_1_2_человека">Scala (1-2 человека)</a></li>
<li><a href="#_ocaml_with_objects_2_человека">OCaml with objects (2 человека)</a></li>
<li><a href="#_ocaml_haskell_with_gadt_2_человека">OCaml/Haskell with GADT (2 человека)</a></li>
<li><a href="#C">Cи (Шапошников)</a></li>
<li><a href="#asm">Assembler</a></li>
<li><a href="#datalog">Datalog</a></li>
<li><a href="#nfa">NFA (Дулетов)</a></li>
<li><a href="#_extended_regexps">Extended Regexps</a></li>
<li><a href="#refal">РеФаЛ</a></li>
<li><a href="#forth">Forth (Ахметьянов)</a></li>
<li><a href="#promela">Promela (Лунёв)</a></li>
<li><a href="#yacc">YACC</a></li>
<li><a href="#algol">Ideal Parallel Algol (1 человек)</a></li>
</ul>
</li>
<li><a href="#hw5">Домашки №5</a></li>
<li><a href="#hw6">Домашки №6</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Переход на <a href="index.html">главную страницу курса</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hw1234">Домашки 1-4</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Дальше идет N тем, которые будут определять задачи вида</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Напишите тип данных для представления программ на мини-языке.</p>
</li>
<li>
<p>Сделайте парсер этого языка (как именно делать  будет сказано на лекции и немного в курсе Москвина)</p>
</li>
<li>
<p>Сделайте интерпретатор языка (по аналогии с тем как мы писали <code>eval</code> для арифметических выражений на паре №2)</p>
</li>
<li>
<p>Реализуйте какое-нибудь преобразование программ (детали будут специфичны для задачи).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Заметим, что задачи 2,3,4 зависят от №1, но не друг от друга. В процессе выполнения 2,3 и 4 может оказаться, что нужно поменять представление программ. Это нормально, т.е. то, что вы напишите в решение пункта 1 скорее всего не будет окончательным.</p>
</div>
<div class="paragraph">
<p>Далее ниже идут описания языков, у них неявно стоит</p>
</div>
<div class="ulist">
<ul>
<li>
<p>приписка "мини"</p>
</li>
<li>
<p>приписка "написать подробнее".</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>А также, если кто-то захочет решать одну и ту же задачу, но на разных языках (по-видимому, это будет Scala и
Haskell), то это нужно предварительно согласовать.</p>
</div>
<div class="paragraph">
<p>Если кто-то хочет подусложнить задачу и решать одну и ту же на одном и том же языке <em>вдвоем</em>, то можно также обсудить.</p>
</div>
<div class="paragraph">
<p>Проверяться будет как программа работает, а также будут вопросы по коду программы (потому что все задачи гуглятся).
Засылать готовые решения надо с помощью merge request в <a href="https://gitlab.com/Kakadu/haskell-course2019-hw">этот репозиторий</a>.</p>
</div>
<div class="sect2">
<h3 id="lua">Lua (Цириков)</h3>
<div class="paragraph">
<p>Интересный минималистичный язык, где в качестве универсальной структуры данных используется помесь
массива с хэш-таблицей, а для оптимизации вместо целых чисел используеются Double&#8217;ы.</p>
</div>
</div>
<div class="sect2">
<h3 id="sql">SQL (Погожельская)</h3>
<div class="paragraph">
<p>Язык запросов к реляционным базам данных, давал в том году на экзамене. Различные конструкции можно погуглить. Задачей номер 4 будет скорее
всего какая-то оптимизация запросов.</p>
</div>
<div class="paragraph">
<p> <details><summary> 
<span class="underline"><strong>Подробнее (спойлер)</strong></span>
 </summary><div> </p>
</div>
<div class="paragraph">
<p>Необходимо реализовать минисистему баз данных. Программа должна уметь дампить информацию в файл, восстанавливать из файла и выполнять (парсер + интерпретатор) запросы к базе данных в интерактивном режиме. Для ввода-вывода данных в/из файл парсер и принтер писать не обязательно, можно обойтись более прямолинейными способами; парсер нужен только для языка запросов SQL. Список запросов возьмем сокращенно-стандартный. Конкретный синтаксис посмотрите в документации к, например, mySQL, здесь я напишу только несколько примеров.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Создание таблиц. Из типов давайте оставим только Int и String (который в базах данных обычно называется VarChar)</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>CREATE TABLE table1 ( String FirstName
                    , String LastName
                    , Int Id
                    , Int Age)</pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Добавление данных в таблицу. Если кто-то добавляет Int туда, где ожидался тип String&#8201;&#8212;&#8201;выругиваться.</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>INSERT INTO table1 VALUES ('vasya','pupkin',1,2),
                          ('ivan', 'ivanov',2,2)</pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Выбор данных из таблицы с выдачей табличного результата</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>SELECT * FROM  table1</pre>
</div>
</div>
<div class="paragraph">
<p>или</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SELECT (FirstName,LastName) FROM table1 WHERE Age&gt;18</pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Удаление данных из таблицы</p>
<div class="listingblock">
<div class="content">
<pre>REMOVE FROM table1 WHERE Age&gt;18</pre>
</div>
</div>
</li>
<li>
<p>Join (он же inner join) таблиц, который формально является декартовом перемножением всех строчек в таблицах с последующей фильтрацией. Можно также поддержать другие JOIN&#8217;ы (LEFT, OUTER, CROSS). Они работают чуть-чуть по-другому.</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>SELECT (a, tableX.id, tableY.id) FROM tableX
   JOIN tableY
   ON table1.id = table2.somekey</pre>
</div>
</div>
<div class="paragraph">
<p>или даже вложенные join&#8217;ы</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SELECT * FROM A
  JOIN (B JOIN C ON B.fkC = C.pk)
  ON A.optionalfkB = B.pk</pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Хранимые процедуры (у всех есть, и тут пусть будут)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>В качестве задачи 4 будут какие-то оптимизации запросов, например</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Вложенные join&#8217;ы должен вычисляться не в стиле generate&amp;filter, а как-нибудь более оптимально.</p>
</li>
<li>
<p>Что-то ещё, пока не придумал.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p> </div></details> </p>
</div>
</div>
<div class="sect2">
<h3 id="_bourne_again_shell_абзалов">Bourne Again SHell (Абзалов)</h3>
<div class="paragraph">
<p>Все, кто трогал линукс, видели эту штуку.</p>
</div>
<div class="paragraph">
<p> <details><summary> 
<span class="underline"><strong>Подробнее (спойлер)</strong></span>
 </summary><div> </p>
</div>
<div class="paragraph">
<p>В качестве BASH можно попробовать делать другой shell, если Вам он будет больше нравиться или Вы им постоянно пользуетесь на компьютере. В итоге хочется получить как минимум интерактивный интерпретатор shell, который можно
попробовать запустить вместо того, что у вас запускается сейчас на входе в GNU/Linux. Обратите внимание, что
те слова, которые есть в программе, bash впервую очередь пытается интерпретировать как вызов системной утилиты
(например, у меня на компьютере есть <code>/usr/bin/[</code>, но нет <code>/usr/bin/[[</code>), а только потом интерпретировать по-своему. Из этого следует, что Ваш интепретатор должен уметь по ходу делать и выполнять IO действия, и поддерживать в каком-то виде сообщения об ошибках. Обратите также внимание, что системный bash работает, как интепретатор, т.е. перемежает исполнение с синтаксическим анализом.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cat /tmp/1.sh
printf "1\n"
if [[[[ asdfasdf ]]]]; then echo 33; fi
printf "2\n"
$ bash /tmp/1.sh
1
/tmp/1.sh: ligne 2: [[[[ : commande introuvable
2</pre>
</div>
</div>
<div class="paragraph">
<p>Для тестирования программ часто используют квайны&#8201;&#8212;&#8201;программы печатающие сами себя. Протестируйте интерпретатор на десятке квайнов, реализуйте те функции интерпретатора, которые нужна для запуска этих квайнов. Например,
<a href="https://frishit.wordpress.com/2010/04/26/paradoxes-self-reproducing-code-and-bash/">это</a>, или</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ s='s=\47%s\47; printf "$s" "$s"'; printf "$s" "$s"
s='s=\47%s\47; printf "$s" "$s"'; printf "$s" "$s"
$ echo 'echo $BASH_COMMAND'
echo $BASH_COMMAND</pre>
</div>
</div>
<div class="paragraph">
<p>Разумеется, нужно поддержать объявления функций и прочие управляющие конструкции, числа, ветвления, строки
 </div></details> </p>
</div>
</div>
<div class="sect2">
<h3 id="python">Python (Мирзазянов)</h3>
<div class="paragraph">
<p>Функции, переменные, присваивания, циклы, ветвления, анонимные функции, массивы/списки&#8201;&#8212;&#8201;стандартный набор большого количества языков. Смотрите также на <a href="https://chocopy.org/">ChocoPy</a>.</p>
</div>
<div class="paragraph">
<p>Из языково-специфичных фич, я предлагаю
<a href="http://codeblog.dhananjaynene.com/2010/01/dynamically-adding-methods-with-metaprogramming-ruby-and-python/">динамическое дополнение методов</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="ruby">Ruby (Привалихин)</h3>
<div class="paragraph">
<p>Примерно как в Питоне. Функции, переменные, присваивания, циклы, ветвления, анонимные функции.</p>
</div>
<div class="paragraph">
<p>Из языково-специфичных фич, я предлагаю динамическое дополнение методов
<a href="http://codeblog.dhananjaynene.com/2010/01/dynamically-adding-methods-with-metaprogramming-ruby-and-python/">(как в питоне)</a></p>
</div>
</div>
<div class="sect2">
<h3 id="javascript">Javascript (Рагимов)</h3>
<div class="paragraph">
<p>Стандартный набор языковых конструкций. Реализовать все фичи из
известного <a href="https://www.destroyallsoftware.com/talks/wat">видеообзора</a> Javascript</p>
</div>
<div class="paragraph">
<p>Из специфичного для Javascript: прототипное наследование.</p>
</div>
</div>
<div class="sect2">
<h3 id="kotlin">Kotlin (Влаев + Кузиванов)</h3>
<div class="paragraph">
<p> <details><summary> 
<span class="underline"><strong>Подробнее (спойлер)</strong></span>
 </summary><div> </p>
</div>
<div class="paragraph">
<p>AST делаете вместе, из языково-специфичных фич обязательно должны быть:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Числа, строки, стнадартные операции над ними, массивы.</p>
</li>
<li>
<p>Объявления классов и методов, статические тоже нужно, чтобы можно быть <code>main()</code> написать.</p>
</li>
<li>
<p>Навороченного наследования не требую, наследования классов и интерфейсов не нужно. Пусть только будет в языке один захардкоженный тип <code>Object</code>, который надтип всего чего угодно.</p>
</li>
<li>
<p>Разумеется <code>null</code>. Также давайте RuntimeExceptions&#8201;&#8212;&#8201;которые громко падают, их поймать невозможно (т.е. <code>try</code> &amp;<code>catch</code> добавлять не нужно) и аннотировать методы бросаемыми исключениями тоже не нужно.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Парсер должен легко параллелиться между людьми.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Парсер в нормальном смысле этого слова</p>
</li>
<li>
<p>Вложенные коменнтарии: конструкция <code>*/</code> должна заканчивать <strong>последний</strong> открытый комментарий, а не все сразу.</p>
</li>
<li>
<p>В некоторых случаях в языке разумно иметь 2-мерный синтаксис, наверное для конструкции switch. Поддержите её и 2-мерный синтаксис там.</p>
</li>
<li>
<p>Хочу, чтобы код мжно было писать, используя препроцессор (<code>#define</code> и прочее)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Интерпретатор</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Один пишет интерпретатор</p>
</li>
<li>
<p>Второй генерирует настоящий JVM bytecode и его исполняет</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Преобразования программ</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>напишу потом</p>
</li>
</ol>
</div>
<div class="paragraph">
<p> </div></details> </p>
</div>
</div>
<div class="sect2">
<h3 id="awk">AWK (Афонина)</h3>
<div class="paragraph">
<p>Предшественник языка Perl. Тут будет стандартный набор фич, плюс вещи специфичные для AWK.
Думаю, что стоит почитать <a href="http://www.grymoire.com/Unix/Awk.html">умную ссылку</a> про то, когда надо применять AWK,
а также подергать оттуда тестовых примеров.</p>
</div>
</div>
<div class="sect2">
<h3 id="haskell">Haskell (1-2 человека)</h3>
<div class="paragraph">
<p>Числа, списки, функции, ленивая стратегия вычислений. Без пользовательских типов данных. В качестве пункта 4&#8201;&#8212;&#8201;хитрые оптимизации. Алгоритм вывода типов пока не включаю, но написать
<a href="http://okmij.org/ftp/ML/generalization.html"><em>эффективный</em></a> (почти линейный) алгоритм вывода типов может быть
<span class="line-through">сложной</span> интересной задачей.</p>
</div>
<div class="paragraph">
<p>Тут легко можно договориться на 2 человека.</p>
</div>
</div>
<div class="sect2">
<h3 id="lisp">LISP</h3>
<div class="paragraph">
<p>LISP известен своими встроенными макросами. Посмотрите примерный синтаксис Scheme (или Common Lisp, и т.д.)
и напишите интерпретатор, который по дороге дает объявлять и использовать макросы. Вдруг у вас получатся
гигиенические?</p>
</div>
</div>
<div class="sect2">
<h3 id="_scala_1_2_человека">Scala (1-2 человека)</h3>
<div class="paragraph">
<p>Функции, числа и прочий стандартный набор фич. Специфичная для Scala часть языка&#8201;&#8212;&#8201;traits. Вообще, чтобы сделать это правильно там нужно прикручивать движок перебора с возвратами a la Datalog.</p>
</div>
<div class="paragraph">
<p>Наверное, можно притянуть на 2х человек, если алгоритм под капотом будет годный.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ocaml_with_objects_2_человека">OCaml with objects (2 человека)</h3>
<div class="paragraph">
<p>Числа, списки, присваивание, объекты и их рекурсивные методы вместо рекурсивных функций.
Наверное, единственный язык, где ООП сделано нормально (за счет структурной типизации и
так называемого row-полиморфизма).</p>
</div>
<div class="paragraph">
<p>Думаю, что тут проще всего будет меня уговорить назначить на двоих.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ocaml_haskell_with_gadt_2_человека">OCaml/Haskell with GADT (2 человека)</h3>
<div class="paragraph">
<p>Числа, функции и обобщенные алгебраические типы данных, паттерн-матчинг, проверка типов для паттерн-мэтчинга
с использованием GADT.</p>
</div>
<div class="paragraph">
<p>Наверное, тут тоже можно парочку.</p>
</div>
</div>
<div class="sect2">
<h3 id="C">Cи (Шапошников)</h3>
<div class="paragraph">
<p>Как обычно, нужно поддержать основные конструкции языка: числа, строки (массивы чисел), ветвления, цикл
<code>while</code> и по желанию <code>for</code>, объявления и вызов функций.</p>
</div>
<div class="paragraph">
<p>Из Си-специфичного: массивы произвольной длины. Можете черпать вдохновение из <a href="https://bellard.org/tcc/">минималистичного компилятора</a>.
Не надо пока делать:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Объявления структур</p>
</li>
<li>
<p>Числа отличные от <code>int</code> и HEX представление</p>
</li>
<li>
<p>Хитрые методы инициализации структур/массивов.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Скорее всего будет подзадача про трансляцию этого мини-языка в x86 ассемблер (для простых функций <code>fibonacci</code> и <code>memcpy</code> это должно быть очень просто). Скорее всего будет полезно пообщаться с человеком, который решает задачу про assembler.</p>
</div>
</div>
<div class="sect2">
<h3 id="asm">Assembler</h3>
<div class="paragraph">
<p>Выберите вид ассемблера, который хорошо работает на вашем компьютере/процессоре и почитайте
виды регистров в данной архитектуре. Реализуйте интерпретатор. Преобразование программ из
задания 4 скорее всего будет про автоматическую векторизацию. Если по дороге окажется, что
Вы научились генерировать настоящий ELF файл, который потом можно отдельно исполнить&#8201;&#8212;&#8201;вообще будет круто.</p>
</div>
</div>
<div class="sect2">
<h3 id="datalog">Datalog</h3>
<div class="paragraph">
<p>Простейший представитель логического программирования, подмножество Prolog. Итого там должны быть</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Предикаты</p>
</li>
<li>
<p><strong>Произвольные</strong> функциональные символы запрещены, хотя разрешается иметь захардкоженное количество функциаональных символов в программе</p>
</li>
<li>
<p>Переменные</p>
</li>
<li>
<p>Правила вывода новых фактов (a.k.a. Хорн клозы (Horn clauses))</p>
</li>
<li>
<p>Способ задания базы данных известных фактов (a.k.a. аксимом)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Итого, программа состоит из "базы данных" фактов и запроса,  а интерпретатор
проверяет согласованность запроса с базой данных и говорит "да" или "нет". Из-за наложенных ограничений
процесс поиска всегда завершится.</p>
</div>
<div class="paragraph">
<p>Простейшей программой будет проверка чисел в стиле Пеано на четность/нечетность
(<a href="https://www.cs.cmu.edu/~fp/courses/15317-f17/lectures/18-datalog.pdf">страницы 2-3</a>).
Ну или поиск пути в графе (<a href="http://pages.cs.wisc.edu/~paris/cs784-s17/lectures/lecture7.pdf">страницы 1-2</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="nfa">NFA (Дулетов)</h3>
<div class="paragraph">
<p>Язык задания недетерминированных конченых автоматов, реализовать вычислитель таких автоматов,
а такжен загрузку из файла (наверняка уже придумали какой-то стандартный формат для представления автоматов,
может быть graphviz?)
В качестве №4 будет конвертация в детерминирванный или что-то подобное.</p>
</div>
</div>
<div class="sect2">
<h3 id="_extended_regexps">Extended Regexps</h3>

</div>
<div class="sect2">
<h3 id="refal">РеФаЛ</h3>
<div class="paragraph">
<p>Отечественный язык программирования. Вдохновения черпать
<a href="https://github.com/bmstu-iu9/refal-5-lambda">отсюда</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="forth">Forth (Ахметьянов)</h3>
<div class="paragraph">
<p>Так называемый стековый язык программирования, мало похож на всё остальное. Считается
языком с легко расширяемым синтаксисом.</p>
</div>
</div>
<div class="sect2">
<h3 id="promela">Promela (Лунёв)</h3>
<div class="paragraph">
<p>Входной язык для утилиты верификации <a href="https://en.wikipedia.org/wiki/Promela">Promela</a>. Думаю, что все
фичи описаны в <a href="http://www.lacl.fr/dima/melo/spin.pdf">слайдах</a>. Весь "язык" компилируется (с помощью <code>pan</code>) в
конечный автомат, который умеет моделировать в том числе параллельные потоки. Короче, надо написать интерпретатор программ Promela, там в слайдах есть примеры, за одно разберетесь с примитивами синхронизации параллельных потоков.</p>
</div>
</div>
<div class="sect2">
<h3 id="yacc">YACC</h3>
<div class="paragraph">
<p>Язык описания синтаксических анализаторов (парсеров). Скорее всего его придется сильно упростить
(без action code&#8217;а, описания ассоциативности и приоритетов операций).
К нему обычно прилагается утилита, которая по описанию генерирует парсер. Сделайте что-то подобное,
генерируя по описанию парсера код на Haskell/Scala, который выполняет синтаксический анализ.
Расширениями генерации можно выбрать, например, устранение левой рекурсии.</p>
</div>
</div>
<div class="sect2">
<h3 id="algol">Ideal Parallel Algol (1 человек)</h3>
<div class="paragraph">
<p>Стандартный модельный язык для использования в научных ситуациях. Числа, ветвления, присваивания, барьеры
для чтения и записи, а также операция запуска N кусков кода параллельно.
Функции и циклы не добавляю, а хочу, чтобы были реализованы
несколько <em>моделей памяти</em> для данной программы.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>sequentional consistency (SC). Исполнение программы произвольно перемежается между параллельными
участками и выполняет по одной инструкции. Самая интуитивная реализация, ни один процессор такой не соответствует.</p>
</li>
<li>
<p>TSO&#8201;&#8212;&#8201;модель процессоров x86. В ней возможны интересные поведения.
Если изначально <code>x = EAX = y = EBX = 0</code>, то после выполнения этих двух участков параллельного кода,
  x86 может остановиться в состоянии <code>EAX == 0 &amp;&amp; EBX == 0</code></p>
</li>
</ul>
</div>
<div class="literalblock">
<div class="content">
<pre>#  Proc 1                           Proc 2
MOV  [x] ← 1         |         MOV  [y] ← 1
MOV  EAX ← [y]       |         MOV  EBX ← [x]</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>может быть ещё какая-то модель памяти.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Вот <a href="https://people.mpi-sws.org/~viktor/wmc/operational.pdf">это</a> будет хорошей ссылкой, если уметь разбираться
в исчислениях (я планирую про это как-то рассказывать).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hw5">Домашки №5</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Скорее всего про структуры данных</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hw6">Домашки №6</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Скорее всего про динамическое программирование</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2019-10-11 13:51:41 MSK
</div>
</div>
</body>
</html>