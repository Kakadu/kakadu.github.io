:source-highlighter: pygments
:pygments-style: monokai
:local-css-style: pastie
:toc:

Список курсовых/миникурсовых
============================
:Author: Dmitrii Kosarev a.k.a. Kakadu
:email:  Dmitrii.Kosarev@protonmail.ch




Задачи
------

Прошлогодние
~~~~~~~~~~~~

Темы и задачи link:../fp2018/projects.html[прошлого года] более-менее актуальны (по-хорошему их надо подредактировать и накопипастить сюда, но потом)

Новые задачи и темы придуманы, но пока не вписаны.


[[incremental]]
Демка инкрементальных вычислений с матрицами
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Есть некоторая тусовка инженеров-исследователей, которые сводять все задачи (например, синтаксический анализ графов) к перемножению матриц (например, инциденций) на GPU. При этом, если меняется одна ячейка в матрице (доабвляется новое ребро в графе) или появляются новые строки/столбцы в матрице (добавляется новая вершина в
граф), то новые результаты перемножения матриц получаются *повторным* перемножением на GPU.

Есть предложение оптимизировать это стандартными способами, например применением *инкрементальных* вычислений.
Идея инкрементальных вычислений заключается в том, что по вычисляемой функции строится некоторая модель
вычисления, зависящая от входных аргументов, и когда меняется один из аргументов, то перевычисляются только
те подвыражения, которые зависят от этих изменившихся аргументов. Например, для случая изменения одной ячейки
матрицы, нам нужно перевычислить некоторое количетсво сумм, линейно пропорциональное размерам матрица, в то
время как перемножение матриц заново имеет квадратичную сложность (пусть и на GPGPU).

Задача заключается в том, чтобы поэкспериментировать с инкрементальными вычислениями матриц (например,
с помощью библиотеки инкрементальных вычислений https://github.com/janestreet/incremental[для языка OCaml])
и попробовать разобраться, можно ли таким способом ускорить перевычисление при изменении матриц.

В планах лежит попытка это опубликовать на тематическм воркшопе GRAPHS NDA.

Руководители mailto:rsdpisuy@gmail.com[Семен Григорьев] и mailto:Dmitrii.Kosarev@protonmail.ch[Дмитрий Косарев]

[[caml_lua]]
Компиляция программ на  OCaml в lua
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

На данный момент при embedded разработке программист строго ограничивается возможностями железа (скоростью
процессора и объемом памяти) и спецификой требований к софту: очень часто приветствуется бинарные
сборки программ, где отсутсвуют код, которые непосредственно не используется в разрабатываемом продукте. Эти
требования существенно осложняют использование проверенных временем библиотек, таких как Qt, boost, и даже glibc.
Очень часто программисты вынуждены использовать более-менее высокоуровневые языки программирования
(Lua или минималистичную реализацию JavaScript) с небольшим рантаймом (десятки килобайт).

Использовать всю мощь функционального программирования не получается в embedded разработке как по объективным
причинам (такие имеют большой объем рантайма, для OCaml -- 200 КБ), таки по не очень доказанным (функциональное
программирование тормозит).

Предлагается научить генерировать по коду на OCaml код на языке Lua взяв за основу одну из двух
уже имеющихся работ по генерации Javascript из OCaml.

* Можно генерирвать Lua непосредственно из исходного кода OCaml по аналогии с проектом Bucklescript.
  Плюсы: читаемый код на выходе. Минусы: необходимо поддерживать весь язык OCaml.
* Можно генерировать Lua и промежуточного представления в компилятор программ на OCaml (так называемый
  Lambda байткод) по аналогии с проектом js_of_ocaml.
  Плюсы: оптимизированный компилятором код на выходе, меньший объем работы. Минусы:  совершенно нечитаемый результат, некоторые проблемы с отладкой такого кода.

Руководители mailto:kirill.k.smirnov@gmail.com[Кирилл Смирнов] и mailto:Dmitrii.Kosarev@protonmail.ch[Дмитрий Косарев]

[[altergo]]
Alt-Ergo (гроб)
~~~~~~~~~~~~~~~

[[merlin]]
merlin
~~~~~~


[[active]]
Active Patterns в OCaml (вроде как занята)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В Haskell они есть (называются Pattern Synonyms), в F# -- тоже, а в OCaml непорядок.

Задача изначально появилась в https://github.com/ocamllabs/compiler-hacking/wiki/Add-a-%22with%22-syntax-for-patterns[Кембридже].
По ссылке есть описание поддержки не их, но сходной фичи; написано в каком порядке что делать, чтобы начать приближаться к Active Pattern'ам.
Иными словами задачи разбивается на две связанные

* With syntax for patterns
* Pattern Synonyms a.k.a. Active Patterns

Про OCaml можно спрашивать людей на https://discuss.ocaml.org/[форуме] или в https://discordapp.com/invite/cCYQbqN[Discord].

Формально это сделано в F# и Haskell, почитать формальный текст можно
https://web.engr.oregonstate.edu/~erwig/papers/PGandTP_Haskell00.pdf[тут] и
https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf[тут].

На форуме OCaml уже https://discuss.ocaml.org/t/musings-on-extended-pattern-matching-syntaxes/3600[началось] обсуждение правильного синтаксиса.
