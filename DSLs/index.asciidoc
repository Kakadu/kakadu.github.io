:source-highlighter: pygments
:pygments-style: monokai
:local-css-style: pastie
:toc-title: Оглавление
:toc:

Разработка предметно-ориентированных встроенных языков
======================================================

:Author: Dmitrii Kosarev a.k.a. Kakadu
:email:  Dmitrii.Kosarev@protonmail.ch

image:United-Kingdom-Flag-PNG-Picture.png[width=5%,scalewidth=1cm] The variant of this report for english-speaking users is link:index_eng.html[here].

Предметно-ориентированные языки (DSL) удобны приразработке программных продуктов тем, что они более удобным образом отражают в своём синтаксисе предметную область, и тем самым облегчают процесс разработки. Предметны-ориентированные языки бывают внешние и встроенные.
Внешние DSL (например, SQL) являются отдельными языками от основного языка программирования, и поэтому требуют некоторых накладных расходов в инфраструктуре, которая будет позволять использовать несколько языков одновременно. Другим недостатком можно назвать то, что они требуют некоторого обучения перед началом использования, по сути сотрудников необходимо  обучать ещё одному языку программирования. Встроенные DSL являются некоторым специальным синтаксисом (или даже набором интерфейсом) для базового языка, в который они встроены. Для таких языков не нужно поддерживать инфраструктуру для разработки одновременно на нескольких языках программирования, затраты на обучение сотрудников также снижаются, так как те по сути всё время используют один и тот же язык программирования. Недостатком встроенных языков может служить тот факт, что технические особенности базового языка программиования могут ограничивать богатство конструкций, которые представимы во встроенном языке.

В рамках работы было разработано несколько программных средств, являющихся различными предметно-ориентированными языками. Все разработанные средства предназначаются для использования с компилятором OCaml версии 4.07.1 и должны устанаваливаться с помощью стандартного (для инфраструктуры OCaml) пакетного менеджера https://opam.ocaml.org[Opam] версии 2.x.


== Разработанные программные средства

[[GT]]
=== Расширяемые преобразования с помощью GT

GT -- это библиотека на основе обобщенного программирования для получения расширяемых преобразований типов данных. Исходный код доступен https://github.com/Kakadu/GT/tree/v0.3.0[на Github].
В неё входят:

* непосредственно библиотека времени выполнения;
* синтаксическое расщирение для Camlp5;
* синтаксическое расширение для PPX.

Установка доступна через Opam с помощью команды

`opam pin add GT git+https://github.com/Kakadu/GT\#v0.3.0`

//Тесты и примеры находятся https://github.com/Kakadu/GT/tree/v0.3.0/regression[в репозитории], а подробные инструкции по установке и использованию https://github.com/Kakadu/GT/blob/v0.3.0/README.md[в README]. Отдельно хотим отметить https://github.com/Kakadu/GT/blob/v0.3.0/regression/test840garrique.ml[пример] на основе работы J.Garrique "Code reuse through polymorphic variants"

[[ostap]]
=== Синтаксический анализ с помощью Ostap

Был разработана библиотека для проведения синтаксического анализа с помощью парсер-комбинаторов, которая состоит из непосредственно библиотеки, и DSL как синтаксического расширения (на основе Camlp5) языка OCaml, которое облегчает написание парсеров. Исходный код для библиотеки с использованием мемоизации находится https://github.com/dboulytchev/ostap/tree/memoCPS[на GitHub]. Для её установки воспользуйтесь командой

`opam pin add ostap git+https://github.com/dboulytchev/ostap\#memoCPS`


//Предыдущий вариант (без использования мемоизации) также доступен https://github.com/Kakadu/ostap/tree/master-very-old[на GitHub] и может быть полезен для сравнения производительности.


[[ocanren]]
=== Реляционное программирования с помощью OCanren

OCanren является членом семейства языков miniKanren, а именно статические типизированным встроенным в OCaml предметно-ориентированным для реляционного программирования. Реляционное программирование является разновидностью логического программирования в ограничениях, с некоторым изменениями реализации поиска, а также оформленное в виде предметно-ориентированного языка. Исходный код доступен
https://github.com/jetbrains-research/ocanren[на GitHub], для установки пользуйтесь командой

`opam pin add OCanren git+https://github.com/JetBrains-Research/OCanren.git`


== Примеры использования

[[LaMa]]
=== Компилятор LaMa

Учебный компилятор, реализованный с использованием описанных выше подходов, находится https://github.com/JetBrains-Research/Lama-devel[на GitHub]. Перед сборкой необходимо установить указанные выше библиотеки.

// Для оценки синтаксического анализатора также был создана отдельная разновидность компилятора ССЫЛКА, на которой сравнение более репрезентативно

В рамках работы над компилятором были реализованы следующие возможности:

* Синтаксический анализ с помощью Ostap
** а также синтакический анализ сокращенного языка LaMa https://github.com/JetBrains-Research/Lama-devel/tree/parsing-experiment[с помощью Menhir] (ради сравнения производительности)
* "Красивый" форматированный вывод программ с помощью GT
** а также с использованием стандартных средств (ради сравнения производительности)
* Средства https://github.com/JetBrains-Research/Lama-devel/tree/1.00/tools[навигации] (go to definition, т.е. resolve имён)
* Средства https://github.com/JetBrains-Research/Lama-devel/tree/1.00/tools[исследования кода] (find usages)
// * Средства преобразования исходного кода (rename, не сделано)
// * Средства анализа потока данных (reaching definitions, не сделано)
// * Оптимизирующие преобразования  (DCE, не сделано)
* Генерация кода в архитектуру x86_32

// == Отчет 2

// === Реализация компилятора, средств исследования, навигации и преобразования исходного кода на базе предложенных подходов и средств (для языка OCaml !?!?!?)

// В рамках работы был разработан <<LaMa>>.

// * средств исследования (find usages, но их пока нет)
// * навигации (go-to-definition, но их пока нет)
// * преобразования исходного кода (rename, но его тоже пока нет)

// === Анализ производительности и эксперименты. Модификация концепции и методов.

// В ходе исследования был разработан с помощью GT модуль для <<LaMa>>,  ответственный за форматирование кода, а также было произведено сравнение со стандартной реализацией без использования GT. Замеры показали, что наш подход работает примерно на 5% медленнее, из-за накладных расходов при использовании объектов языка OCaml. Преимуществом нашего подхода является возможность видоизменять форматтер, не переписывая его заново. С использованием этой возможности был реализован видоизмененный форматтер, который печатает инфиксные операции языка LaMa более удобным способом.

// Тут будет ещё ССЫЛКА


// === Создание прототипов следующих языковых процессоров с использованием разработанного инструментария: синтаксического анализатора, форматтера, анализатора типов, средств анализа потока данных, оптимизирующих преобразований и генерации кода.

// В рамках <<LaMa>> были разработано следующие средства:

// * синактсический анализатор на основе Ostap (ССЫЛКА)
// * форматтер (ССЫЛКА)
// * средства анализа потока данных (reaching definitions, но пока не сделано)
// * оптимизирующие преобразования  (DCE, но пока не сделано)
// * генерация кода в архитектуру x86

ifdef::backend-docbook[]
[index]
Example Index
-------------
////////////////////////////////////////////////////////////////
The index is normally left completely empty, it's contents being
generated automatically by the DocBook toolchain.
////////////////////////////////////////////////////////////////
endif::backend-docbook[]
