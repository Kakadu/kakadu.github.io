:source-highlighter: pygments
:pygments-style: monokai
:local-css-style: pastie
:stylesheet: ./stylesheets/material-teal.css

Задачи второй недели
====================
:Author: Dmitrii Kosarev aka Kakadu
:email:  Dmitrii.Kosarev@protonmail.ch

[[week2]]
Неделя 2
--------

Задачи от М.Симуни
~~~~~~~~~~~~~~~~~~
Составлены М.Симуни (simuni@mail.ru). Вы можете свободно копировать и воспроизводить эти задачи, при условии сохранения ссылки на составителя.

[start=1]
. List item 7.
[arabic, start=1]
..  Описать функцию minlist, которая ищет минимальный элемент в данном списке.
+
Пример вызова: `minlist [3,2,7]`
Ответ должен быть равен 2.
+
NOTE: На самом деле, конечно, в Хаскеле есть такая стандартная функция (называется minimum), но, пожалуйста, в этой задаче вы ее не используйте.
+
..  Описать функцию sumprod, которая для списка `[x1,x2,x3,x4,...,xn]` ищет значение `x1*x2+x2*x3+x3*x4+...`. То есть, сумму произведений всех пар стоящих рядом элементов.
+
Пример вызова: `sumprod [1,3,2,7]`
+
Ответ должен быть равен 1*3+3*2+2*7 = 23.
+
NOTE: Можно считать, что мы точно знаем, что в списке есть хотя бы два элемента.
+
..  Описать функцию `check cond xs`, которая для данного списка xs и логической функции cond проверяет, верно ли, что в списке есть элемент, для которого cond возвращает True. Результат должен быть равен True, если такой элемент есть, и False, если его нет.
+
Примеры вызова: `check (\x->x>5) [3,2,7,4]`
Ответ должен быть равен True, потому что в списке есть число, большее 5 (это число 7).
+
`check (\x->x<1) [3,2,7,4]`
Ответ должен быть равен False, потому что в списке нет чисел, меньших 1.
+
NOTE: Эта задача, конечно, очень похожа на checkPos, которая была на занятии. Но только тут надо проверять не конкретное условие, а условие, которое передается, как параметр.
+
NOTE: В Хаскеле есть такая стандартная функция (называется any). Но, пожалуйста, в этой задаче вы ее не используйте.
+
..  Описать функцию sameDigits, которая возвращает True, если в списке есть два элемента, у которых совпадают последние цифры.
+
Примеры вызова: `sameDigits [13,2,73]`. Ответ должен быть равен True, потому что у 13 и 73 одинаковые последние цифры.
+
`sameDigits [13,2,79,5]`. Ответ должен быть равен False.
+
..  Описать функцию `upDown`, которая проверяет, верно ли, что в данном списке сначала строго возрастают, а потом, с какого-то момента, строго убывают.
--
+
Примеры вызова:
+
  . upDown [2, 6, 9, 7, 3, 1] - должна вернуть True
  . upDown [2, 6, 9, 7, 3, 1, 8] - должна вернуть False, потому что числа возрастают, убывают и потом снова возрастают.
  . upDown [2, 6, 9] - должна вернуть False, потому что числа только возрастают

NOTE: М.б. лучше четко сформулировать, что это значит "сначала возрастают, потом убывают". Имеется в виду, что, если взять все пары стоящих рядом чисел и сравнить числа в парах, то сначала насколько раз (по крайней мере один раз) первое число будет меньше, а потом несколько раз (тоже по крайней мере один раз) первое число будет больше.
+
--
..  Написать функцию parts, которая для данного списка проверяет, можно ли его разбить на несколько строго возрастающих кусков одинаковой длины. Длина кусков должна быть не меньше 2. Кусок может быть и только один.
+
Примеры вызова:
+
  . parts [1, 2, 8, 2, 5, 6]
  . parts [1, 2, 3, 4, 5]
  . parts [1, 2, 1, 2, 3, 4]
  . Во всех этих случаях ответ должен быть равен True.
  . parts [4, 6, 3, 5, 7]
  . Тут ответ должен быть равен False.

NOTE: В этой задаче есть более эффективные решения и менее эффективные. Если у вас будет менее эффективное, то я попрошу вас написать более эффективное (и немного подскажу, как).
..  Написать функцию parts2, которая проверяет, можно ли в данном списке выбрать ровно половину элементов, чтобы
- они строго возрастали
- в оставшейся половине элементы тоже строго возрастали.
+
В этой задаче элементы не обязательно брать подряд.
+
Примеры вызова:
- parts2 [1, 3, 2, 4, 8, 9]. Ответ должен быть True (разбивается, например, на [1, 3, 4] и [2, 8, 9])
- parts2 [2, 3, 4, 6, 1, 8, 9, 7]. Ответ должен быть False.

NOTE: Желательно более-менее эффективное решение

// NOTE: в этой задаче решение должно быть более-менее эффективным. Т.е., если присланное решение покажется мне очень неэффективным, я могу попросить его улучшить, даже если всегда дает правильные результаты.
// NOTE: на самом деле, я знаю очень эффективное решение, без перебора, но его не так просто запрограммировать на Хаскеле. Но если вы просто придумаете эффективный алгоритм, напишите письмо, было бы интересно сравнить решение с моим.
