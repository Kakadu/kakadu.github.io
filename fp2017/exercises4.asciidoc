:source-highlighter: pygments
:pygments-style: monokai
:local-css-style: pastie
:stylesheet: ./stylesheets/material-teal.css

Задачи к третьей неделе
=======================
:Author: Dmitrii Kosarev aka Kakadu
:email:  Dmitrii.Kosarev@protonmail.ch

Про типы данных
---------------

// Задачи от М.Симуни
// ~~~~~~~~~~~~~~~~~~
// Составлены М.Симуни (simuni@mail.ru). Вы можете свободно копировать и воспроизводить эти задачи, при условии сохранения ссылки на составителя.


=== Про https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Maybe.html[`Maybe`]

. Описать функцию которая принимает функцию `f` несколько (пусть 3 или 4) значения типа `Maybe _` и возвращает
  - `Nothing` если хотя бы один из них `Nothing`
  - Применяет `f`  от данных, которые спрятаные внутри `Maybe`

NOTE: OK google, billion-dollar mistake.
+
Решение должно быть лаконичное.

. Та же задача, но вместо нескольких аргументов -- список из `Maybe _`.

=== Числа Пеано

На первом занятии у нас были очень странные функции сложения и умножения, адаптированные для чисел Пеано. Реализуйте для таких чисел арифметические операции.

[source,haskell]
----
data Peano = Zero | Succ Peano
----

=== https://hackage.haskell.org/package/ListZipper-1.2.0.2/docs/Data-List-Zipper.html[`Zipper`] для списков

Есть структура данных, которая инкапсулирует в себе список и позволяет пройти по нему, например, до половины, потом пойти назад, а потом снова вперед. Реализуйте её.

=== Про двоичные деревья

Опишем тип дерева
[source,haskell]
----
data Tree a = Leaf | Node a (Tree a) (Tree a)
----

. Описать стандартные функции для деревьев:

  - поиск наличия элемента в дереве. Какова сложность этой процедуры?
  - `map` для дерева
  - `fold` для дерева. Тут могут возникнуть сложности такого рода: очень легко при реализации `fold` "прибить гвоздями" метод обхода (например, влево-узел-вправо) и столкнуться с невозможностью использования написанного `fold` в тех случаях, когда нужен иной вид обхода. Пока обмозгуйте проблему, к ней мы вернемся на следующих занятиях.
  - Реализуйте дерево поиска. Сложность процедуры поиска должна быть поменьше чем у произвольных деревьев

. Опишите тип деревьев, в которых данные могут храниться и в листовых узлах. Опишите функции выше и для них.

=== Балансировка деревьев

Наиболее известные сбалансированные деревья -- красно-черные. Считается, что процедуру балансировки очень сложно реализовать правильно. Сделайте это на Haskell и на "нормальном" языке (С++/Java/C## или что-нибудь, где нужно руками редактировать поля в структурах)

NOTE: Есть хорошая книжка на русском "Чисто функциональные структуры данных" Криса Окасаки.

=== Лямбда-исчисление

В (бестиповом) лямбда исчислении есть три вида термов: переменная с именем (`var`), лямбда-абстракция (`\ var -> term`) и применение терма к терму.

. Опишите тип данных с тремя конструкторами.
. Опишите функцию поиска свободных переменных в терме.
. Опишите функцию подстановки `subst where var term`, которая заменяет все вхождения свободной перменной `var` в терме `where` на терм `term`.
+
NOTE: Тут есть грабли.
+
. Опишите функцию https://en.wikipedia.org/wiki/Evaluation_strategy[редукции] (вычисления) лямбда-терма. Правильное решение не одно, опишите какие-нибудь.
. Непростое упражнение. Научитесь описывать правила редукции, переисползую предыдущие правила редукции. Например, заменяя в предыдущем только правило обработки применения терма к терму.
