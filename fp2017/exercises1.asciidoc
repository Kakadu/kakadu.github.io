:source-highlighter: pygments
:pygments-style: monokai
:local-css-style: pastie

Задачи первой недели
====================
:Author: Dmitrii Kosarev aka Kakadu
:email:  Dmitrii.Kosarev@protonmail.ch

[[week1]]
Неделя 1
--------
Введение. Рекурсивные функции над числами

Пачка задач со спойлерами
~~~~~~~~~~~~~~~~~~~~~~~~~

- Сложение чисел путём уменьшения слагаемого на 1, пока не превратится в ноль.
[source,haskell]
----
add' 0 = id
add' x | x > 0 = add' (x-1) . (+1)
       | x < 0 = add' (x+1) . (subtract 1)
----
- Аналогично для умножения
- Реализовать вычитание через сложение
- Частное двух чисел
- Остаток от деления
- Количество делителей числа, сумма делителей числа
[source,haskell]
----
isPrime n = iterate 2 where
  n' = abs n
  iterate i | i*i > n'  = True
            | otherwise = rem' n' i /= 0 && iterate (i+1)
----
- https://en.wikipedia.org/wiki/Coprime_integers[Coprime numbers]
- https://en.wikipedia.org/wiki/Euler%27s_totient_function[Функция Эйлера]

Задачи от М.Симуни
~~~~~~~~~~~~~~~~~~
Составлены М.Симуни (simuni@mail.ru). Вы можете свободно копировать и воспроизводить эти задачи, при условии сохранения ссылки на составителя.

. Описать функцию `f n`, которая вычисляет `1+1/(1+1/(1+ ...+1/1))` - n дробей
  **  Пример вызова: `f 3`
  +
    Должно получиться `1+1/(1+1/(1+1/1))`, то есть `1.6666..`.
  +
. Описать функцию `b n`, которая вычисляет `0+1/(1+1/(2+1/(3+ ...+1/n)))` - n дробей
  **  Пример вызова: `b 3`
  +
  Должно получиться `0+1/(1+1/(2+1/3))`, то есть `0.7`
  +
.  Описать функцию `sumsin n = sin(1+2+...+n)/(sin 1+sin 2+...+sin n))`
  В решении желательно (но не обязательно) использовать хвостовую рекурсию и накапливающие параметры.
  ** Пример вызова: `sumsin 2`
  +
  Должно получиться `sin(1+2)/(sin 1+sin 2)`; это равно примерно 0.08
  +
. Описать функцию `sumfact n`:  `sumfact n = 1!+2!+...+n!``
  В решении желательно (но не обязательно) использовать хвостовую рекурсию и накапливающие параметры.
  ** Пример вызова: `sumfact 3`
  +
  Результат должен быть равен 9.
  +
. Сколько существует строго возрастающих последовательностей положительных целых чисел, сумма которых равна данному числу n?
  Например, для n = 9 существуют такие последовательности:
  +
    `1 2 6`, `1 3 5`, `1 8`, `2 3 4`, `2 7`, `3 6`, `4 5`, `9`
  +
  , то есть ответ на вопрос равен 8
  +
  Опишите функцию nseq n, которая вычисляет количество таких последовательностей.
  ** Пример вызова: `nseq 9`
  +
  Результат должен быть равен 8.
  +
. *Дополнительная задача*
  Опишите функцию g, которая для данного целого числа, проверяет, можно ли его представить в виде суммы двух различных простых чисел, и возвращает True или False.
  +
  Замечание: О похожей (но не совсем такой же)задаче написан целый роман см. например: http://royallib.ru/book/doksiadis_apostolos/dyadyushka_petros_i_problema_goldbaha.html
  +
  Примеры вызова:
  ** g 6 должно быть равно False
  ** g 7 должно быть равно True (так как 7 = 2 + 5).
  +

. *Дополнительная задача*
  Опишите функцию `c n`, которая для данного целого числа `n` вычисляет, сколько есть способов представить данное число, как сумму нескольких различных положительных чисел, причем все числа должны быть попарно взаимно простыми.

  NOTE: Эту задачу можно решать используя списки, а можно придумывать формулу.

  Пример вызова:
  +
  `с 10` - должно получиться 6, потому что есть 6 таких последовательностей (`1 2 7`, `1 4 5`, `1 9`, `2 3 5`, `3 7`, `10`).
  +

Задачи про зависимые типы (вернее про их отсутствие)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Для решeния необходимо знать, что такое кортеж (англ. *tuple*)

Также используется понятие вложенных пар -- это когда в паре один из элементов тоже пара, а в нём один из элементов снова пара, и т.д. Например, бывают проавориентированные вложенные пары `(a,(b,(c,d)))` и левоориентированные -- `(((a,b),c),d)`.

В этих задачах не нужно описывать функции для случаев раз, два и три. Нужно предъявить метод, которым можно получать такие функции не приходя в сознание. В задачах про типы данных будет подсказка.

- Научиться описывать функции, которые делают из некаррированной функции каррированную:
[source,haskell]
----
un    :: (a -> b) -> (a -> b)
deux  :: ((a,b) -> c) -> (a -> b -> c)
trois :: ((a,(b,c)) -> d) -> (a -> b -> c -> d)
----
И т.д. до бесконечности.

- Из каррированной -- в некаррированную
[source,haskell]
----
un    :: (a -> b) -> (a -> b)
deux  :: (a -> b -> c) -> (a,b) -> c
trois :: (a -> b -> c -> d) -> (a,(b,c)) -> d
----
- Удаление самого глубокого элемента и приписывание его слева от пары.

[source,haskell]
----
deux  :: (a,b) -> (b,a)
trois :: (a,(b,c)) -> c,(a,b)
----

Упрощенный вариант: извлечения самого глубокого элемента и отбрасывание остальных. Получается композицией `fst` и решения предыдущей задачи.
[source,haskell]
----
deux  :: (a,b) -> b
trois :: (a,(b,c)) -> c
----

- Применение вложенных пар функций в одному значению.
[source,haskell]
----
un    :: a -> (a->b) -> b
deux  :: a -> (a->b, a->c) -> (b,c)
trois :: a -> (a->b, (a->c, a->d)) -> (b,(c,d))
----

Реализация от трех и дальше должна получиться синтаксически одинаковой для всех задач выше

- Задача от Олега (посложнее)
+
Научиться описывать функции, которые принимают произвольное количество аргументов и складывают их в список.
[source,haskell]
----
smth1 un    1     -- [1]
smth2 deux  1 2   -- [1,2]
smth3 trois 1 2 3 -- [1,2,3]
----


////
[glossary]
Example Glossary
----------------
Glossaries are optional. Glossaries entries are an example of a style
of AsciiDoc labeled lists.

[glossary]
A glossary term::
  The corresponding (indented) definition.

A second glossary term::
  The corresponding (indented) definition.
////

ifdef::backend-docbook[]
[index]
Example Index
-------------
////////////////////////////////////////////////////////////////
The index is normally left completely empty, it's contents being
generated automatically by the DocBook toolchain.
////////////////////////////////////////////////////////////////
endif::backend-docbook[]
