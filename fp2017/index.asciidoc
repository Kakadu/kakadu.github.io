:source-highlighter: pygments
:pygments-style: monokai
:local-css-style: pastie

Функциональное Программирование (матмех, осень 2017)
====================================================
:Author: Dmitrii Kosarev aka Kakadu
:email:  Dmitrii.Kosarev@protonmail.ch

[role="col-md-4"]
====
[panel,primary]
.{toc-title}
--
* xref:about[Пролог]
* xref:week1[Первая неделя]
* xref:week2[Вторая неделя]
// * xref:metamodel[Qt objects' metamodel]
// * xref:properties[Adding properties]
// * xref:signals[Adding signals]
// * xref:types[Supported types]
// * xref:building[Build system]
// * xref:no_moc[Using `lablqml` without code generation]
// * xref:conclusion[Conclusion]
// * xref:qt5[P.S. Installing Qt5]
--
====

[[about]]
Пролог
-----

http://ocsigen.org/js_of_ocaml/2.8.4/files/toplevel/index.html[OCaml прямо в браузере]. Может для Haskell'я тоже такое есть...

GHC и WinHugs и как ими пользоваться:

* Самая распостраненый способ уставновить Haskell - это Haskell Platform (http://www.haskell.org/platform).
  Работает для Windows, Linux и Mac. Для курса будет достаточно минимального варианта установки.
* В Haskell Platorm есть простые среды разработки GHCi и WinGHCi. Вот краткая инструкция о том, как начать с ними работать.

Ссылки
~~~~~
http://learnyouahaskell.com/[Learn You a Haskell for Freat Good]

[[week1]]
Неделя 1
--------
Введение. Рекурсивные функции над числами

Пачка задач со спойлерами
~~~~~~~~~~~~~~~~~~~~~~~~~

- Сложение чисел путём уменьшения слагаемого на 1, пока не превратится в ноль.
[source,haskell]
----
add' 0 = id
add' x | x > 0 = add' (x-1) . (+1)
       | x < 0 = add' (x+1) . (subtract 1)
----
- Аналогично для умножения
- Реализовать вычитание через сложение
- Частное двух чисел
- Остаток от деления
- Количество делителей числа, сумма делителей числа
[source,haskell]
----
isPrime n = iterate 2 where
  n' = abs n
  iterate i | i*i > n'  = True
            | otherwise = rem' n' i /= 0 && iterate (i+1)
----
- https://en.wikipedia.org/wiki/Coprime_integers[Coprime numbers]
- https://en.wikipedia.org/wiki/Euler%27s_totient_function[Функция Эйлера]

Задачи от М.Симуни
~~~~~~~~~~~~~~~~~~
Составлены М.Симуни (simuni@mail.ru). Вы можете свободно копировать и воспроизводить эти задачи, при условии сохранения ссылки на составителя.

. Описать функцию `f n`, которая вычисляет `1+1/(1+1/(1+ ...+1/1))` - n дробей
  **  Пример вызова: `f 3`
  +
    Должно получиться `1+1/(1+1/(1+1/1))`, то есть `1.6666..`.
  +
. Описать функцию `b n`, которая вычисляет `0+1/(1+1/(2+1/(3+ ...+1/n)))` - n дробей
  **  Пример вызова: `b 3`
  +
  Должно получиться `0+1/(1+1/(2+1/3))`, то есть `0.7`
  +
.  Описать функцию `sumsin n = sin(1+2+...+n)/(sin 1+sin 2+...+sin n))`
  В решении желательно (но не обязательно) использовать хвостовую рекурсию и накапливающие параметры.
  ** Пример вызова: `sumsin 2`
  +
  Должно получиться `sin(1+2)/(sin 1+sin 2)`; это равно примерно 0.08
  +
. Описать функцию `sumfact n`:  `sumfact n = 1!+2!+...+n!``
  В решении желательно (но не обязательно) использовать хвостовую рекурсию и накапливающие параметры.
  ** Пример вызова: `sumfact 3`
  +
  Результат должен быть равен 9.
  +
. Сколько существует строго возрастающих последовательностей положительных целых чисел, сумма которых равна данному числу n?
  Например, для n = 9 существуют такие последовательности:
  +
    `1 2 6`, `1 3 5`, `1 8`, `2 3 4`, `2 7`, `3 6`, `4 5`, `9`
  +
  , то есть ответ на вопрос равен 8
  +
  Опишите функцию nseq n, которая вычисляет количество таких последовательностей.
  ** Пример вызова: `nseq 9`
  +
  Результат должен быть равен 8.
  +
. *Дополнительная задача*
  Опишите функцию g, которая для данного целого числа, проверяет, можно ли его представить в виде суммы двух различных простых чисел, и возвращает True или False.
  +
  Замечание: О похожей (но не совсем такой же)задаче написан целый роман см. например: http://royallib.ru/book/doksiadis_apostolos/dyadyushka_petros_i_problema_goldbaha.html
  +
  Примеры вызова:
  ** g 6 должно быть равно False
  ** g 7 должно быть равно True (так как 7 = 2 + 5).
  +

. *Дополнительная задача*
  Опишите функцию `c n`, которая для данного целого числа `n` вычисляет, сколько есть способов представить данное число, как сумму нескольких различных положительных чисел, причем все числа должны быть попарно взаимно простыми.
  +
  Замечание: Эту задачу можно решать используя списки, а можно придумывать формулу.
  ** Пример вызова:
  +
     `с 10` - должно получиться 6, потому что есть 6 таких последовательностей (`1 2 7`, `1 4 5`, `1 9`, `2 3 5`, `3 7`, `10`).
  +



[[week2]]
Неделя 2 (11 сентября)
----------------------
Списки и всё с ними связанное.


////
[glossary]
Example Glossary
----------------
Glossaries are optional. Glossaries entries are an example of a style
of AsciiDoc labeled lists.

[glossary]
A glossary term::
  The corresponding (indented) definition.

A second glossary term::
  The corresponding (indented) definition.
////

ifdef::backend-docbook[]
[index]
Example Index
-------------
////////////////////////////////////////////////////////////////
The index is normally left completely empty, it's contents being
generated automatically by the DocBook toolchain.
////////////////////////////////////////////////////////////////
endif::backend-docbook[]
