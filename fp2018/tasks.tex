% Compile using the command
%
%     xelatex -synctex=1 tasks.tex
%
%  Before that something like 
%    sudo apt install cm-super biber fonts-sil-charis fonts-inconsolata texlive-bibtex-extra
%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,14pt]{article}
\usepackage[margin=0.5in]{geometry}
\usepackage[colorlinks=true]{hyperref}

% \input{slides/heading.tex} 


\usepackage{verbatim}
\usepackage{unicode-math}
% % TODO: specify Italic variant of the font 
% \setromanfont[SizeFeatures={Size=16}]{Charis SIL}
% \setsansfont [SizeFeatures={Size=16}]{Liberation Sans}
% \setmathfont [SizeFeatures={Size=16}]{Latin Modern Math}

% \setromanfont{Charis SIL}
% \setsansfont {Liberation Sans}
% \setmathfont {Latin Modern Math}

% \setsansfont [Mapping=tex-text,SizeFeatures={Size=16}]{Liberation Serif}
% \setromanfont[Mapping=tex-text,SizeFeatures={Size=16}]{Liberation Sans}
% \setmonofont [Mapping=tex-text,SizeFeatures={Size=16}]{Liberation Mono}
% \setmathfont [Mapping=tex-text,SizeFeatures={Size=16}]{Latin Modern Math}

\setsansfont [Mapping=tex-text]{Liberation Serif}
\setromanfont[Mapping=tex-text]{Liberation Sans}
\setmonofont [Mapping=tex-text]{Liberation Mono}
\setmathfont [Mapping=tex-text]{Latin Modern Math}


\usepackage{indentfirst}
\usepackage{verbatim}

% \usepackage{tocloft}
% 
% % Font changes to ToC content of sectional units
% \renewcommand{\cftpartfont}{\normalfont\sffamily\bfseries}% \part font in ToC
% \renewcommand{\cftchapfont}{\normalfont\large\itshape}    % \chapter font in ToC
% \renewcommand{\cftsecfont}{\normalfont\slshape}           % \section font in ToC
% \renewcommand{\cftsubsecfont}{\normalfont\itshape}        % \subsection font in ToC
% \renewcommand{\cftsubsubsecfont}{\normalfont\small}       % \subsubsection font in ToC
% 
% % Font changes to document content of sectional units
% \renewcommand{\partfont}{\normalfont\Huge\bfseries}
% \renewcommand{\chapterfont}{\normalfont\huge\bfseries}
% \renewcommand{\sectionfont}{\normalfont\LARGE\bfseries}

\usepackage{xltxtra} % load xunicode
\usepackage{polyglossia}
\setmainlanguage{russian}
\setotherlanguage{english}
\newfontfamily{\cyrillicfonttt}{FreeMono}

\usepackage{xcolor}
% \definecolor{YellowGreen} {HTML}{B5C28C}
% \definecolor{ForestGreen} {HTML}{009B55}
% \definecolor{MyBackground}{HTML}{F0EDAA}

\usepackage{listings}

\usepackage{titlesec}
% Define light and dark Microsoft blue colours
\definecolor{MSBlue}{rgb}{.204,.353,.541}
\definecolor{MSLightBlue}{rgb}{.31,.506,.741}
\newfontfamily\subsubsectionfont[Color=MSLightBlue]{Charis SIL}
\titleformat*{\section}{\huge\bfseries\sffamily}
\titleformat*{\subsection}{\Large\bfseries\sffamily}
% \titleformat*{\subsubsection}{\itshape\subsubsectionfont}
\def\hsinline{\lstinline[language=haskell]}
\lstnewenvironment{hslisting} { \lstset { language=haskell }  }  {}
  
\title{Задачи к экзамену}
\author{Косарев}

\begin{document}

\begin{abstract}
Вот задачи. К первым 22 двум приписаны фамилии назначенных на неё решение. Также есть несколько дополнительных задач на случай, если кому-то совсем не понравится то, что попалось. Уведомляйте меня только, если хотите заменить задачу.

На некоторые задачи назначены по двое. Одни из них выглядят трудоемко, на некоторые мне уважаемые люди ткнули пальцем и сказали, что туда лучше двоих. Изначально я планировал ``раздвоить'' только задачу про трансформеры монад -- она действительно сложная, но зато интересная -- она меня впечатлила за время моей аспирантуры больше, чем всё остальное прочитанное. В любом случае в В.Мясникова и Е.Орачева я верю, так как они присылали домашние задачи. К тому же были прецеденты, что человек справлялся с подобной штукой в одиночку.

Оправданно ли ставить на другие задачи по двое -- я не знаю. Может это кому-то подсластит пилюлю.

Сдавать парные задачи я предлагаю последовательно -- сначала один, потом второй. Желательно даже разным людям. В том году я практиковал конкурентную сдачу: один человек отвечал на вопросы, второй сидел рядом и кивал. У меня сложилось впечатление, что я был недостаточно строг.

В любом случае, я ожидаю, что вы будете ориентироваться в коде, которые будете мне показывать, независимо от того, водиночку вы это делали, парно или нашли код в гугле.

Для некоторых задач выделены обязательные критерии для претендования на четыре или пять. Эти критерии корректны, но условны в том смысле, что если в конце окажется, что вы не знаете законов монад (или т.п.), то вас мало что спасёт от второй попытки сдачи экзамена. Какой формат там будет я пока не думал.

Извините за то, что текст оформлен отвратително.

Извините, если чью-то фамилию напечатал неправильно.
\end{abstract}

\maketitle
\setcounter{tocdepth}{1}
\tableofcontents

% \chapter{Список студентов}

% \chapter{Список задач}

% \makeatletter 
% \@addtoreset{subsection}
% \makeatother
\section{Кирилл. Автомат}

\section{Башкиров. Несколько задач про алгоритмы}

\subsection{Наименьшее натуральное число}
Отыскать наименьшее натуральное число, отсутствующее в заданном конечном множестве натуральных чисел $X$. Множество $X$ задано как список натуральных чисел без повторений, упорядоченных произвольно, например.

\begin{lstlisting}
[ 8,23,9,0,12,11,1,10,12,7,41,4,14,21,5,17,3,19 ]
\end{lstlisting}

Ожидается решение линейной сложности

\subsection{Сортировка попарных сумм}

Пусть A это некоторое линейно упорядоченное множество, а операция
$(+) :: A \rightarrow A \rightarrow A$ -- это такая монотонная бинарная операция на $A$, что $x_1\leq x_2 \wedge y_1 \leq y_2 \Rightarrow x_1+y_1 \leq x_2 + y_2$. Рассмотрим задачу вычисления

\begin{lstlisting}
sortsums :: [A] -> [A] -> [A]
sortsums xs ys = sort [ (x+y) | х <- xs , y <- ys]
\end{lstlisting} 

Сколько операций потребует вычисление \hsinline=sortsums xs ys=, если считать только сравнения и предполагать, что длина как \hsinline=xs=, так и \hsinline=ys= равна n?
Разумеется, $O(n^2 log(n))$ сравнений достаточно. Всего имеется $n^2$ сумм,
а сортировка списка длины
 может быть выполнена с использованием
$О(n^2 log(n))$ сравнений. Эта верхняя оценка не зависит от факта монотон­
ности $(+)$. На самом деле без дополнительной информации относительно $(+)$
и $A$ эта граница является одновременно и нижней. Допущение о монотонности $(+)$ уменьшает лишь константный множитель, не изменяя при этом
асимптотической сложности.
 
 Но предположим теперь, что об операции $(+)$ и множестве $A$ мы знаем
 больше: а именно, что ($(+)$, $A$)  является абелевой группой. Таким образом,
 операция $(+)$ ассоциативна и коммутативна, имеется единица $е$ и такая 
 операция \hsinline=negate :: A -> A=, что \hsinline!x + negate x = e!. Вооружившись этой до полнительной информацией, один француз доказал,
 что \hsinline=sortsums= можно вычислить за $O(n^2)$ сравнений.

\subsection{Оценивание}
\begin{itemize}
 \item[3] Императивное решение обеих задач с использованием мутабельных массивов на Haskell
 \item[4] Чисто функциональное решение первой задачи (она проще)
 \item[5] Чисто функциональное решение обеих
\end{itemize}

\section{DPLL (Усик)}

Необходимо реализовать проверку формул языка высказываний на тавтологичность с помощью алгоритма DPLL. Необходимо реализовать парсер языка высказываний, непосредственно алгоритм и годные тесты. Я уже давал такую задачу в третьей пачке лекций, но тут надо решать именно конкретным алгоритмом. Про алгоритм можно читать много где, например на \href{https://en.wikipedia.org/wiki/DPLL_algorithm}{вики-статье} с картинками.


\section{Про две стратегии вычислений в одном интерпретаторе (Богданов Егор)}

Реализуйте парсер и интерпретатор лямбда-исчисления с call-by-name (или call-by-need) стратегией вычислений. В языке поддерживаем списки, числовые константы, рекурсию. Протестируйте интерпретатор на факториале, числах Фибоначчи и прочих мелких тестах.

Реализуйте вывод простых типов получив в результате модифицированное дерево, где каждый терм языка заменен на пару из терма и типа. Тут есть тонкости, например, с тем, что у функции, которая вычисляет длину списка нет наиболее общего типа в STLC -- надо будет либо сужать каким-то образом тип в конце (разумные умолчания); либо добавить в парсер аннотации типов, которые будет проставлять человек; либо проапгрейдиться до полиморфного лямбда исчисления, либо придумайте сами что-нибудь. Этот бы сделан, чтобы была возможность сформулировать следующий.

Идея взята \href{http://www.haskellforall.com/2017/09/}{отсюда}.
Сделайте интерпретатор, который некоторые куски счиired white sheтает CBN, а некоторые -- CBV. Например, суммирование списка чисел лучше делать через CBV, а unfold числа \hsinline=n= в \hsinline=[1..n]= -- наоборот, так как вызывая каждый раз \hsinline=(:)= он будет проверять что второй аргумент досчитан до конца и итоговая асимптотика будет квадратичная.

% \section{$\qquad$}
% 

 Я не против добавить сюда второго человека, потому что задача мне начала казаться почему-то сложнее чем раньше: думать надо когда можно спотимизировать, а когда не стоит. 

\section{Scott Encoding (Гогина)}

\href{https://www.codewars.com/kata/scott-encoding}{Задача} c Codewars

\section{Простая система переписывания термов (Долгополова)}

Переписывание термов -- это область, которая включает большую часть теории лямбда-исчисления, а также предоставляет фреймворк, где упрощение и символьное дифференцирование задается просто как набор правил. У систем переписывания термов (term rewriting systems, TRS) и лямбда исчисления большинство терминологии совпадает. Например, мы говорим. что TRS завершается если для произвольного не существует бесконечной последовательности переписываний. Говорят, что TRS обладает свойством confluence если, всякий раз когда терм может редуцироваться в два других различных терма, существует ещё один терм, в который эти два терма редуцируются. Мы можем наблюдать, как эти два свойства выполняются для STLC (там это называется сильной нормализацией -- strong normalisation). Далее, отношении редукции может задаваться в форме малого или большого шага (single-step or many-step form). В случае малого шага свойство confluence превращается в weak confluence.

В этой задаче нужно реализовать TRS систему, которая читает набор правил, а потом переключается в режим взаимодействия с пользователем. Каждый раз, когда пользователь что-то вводит, система пытается сопоставить введенное с правилами. Затем применяется первое правило, которое подходит, терм переписывается (rewritten) и печатается. Далее система продолжает повторять действие до тех пор пока сможет. Разумеется, не все наборы правил будут завершаться для произвольного входа.

Пример. Будем жить с сокращенным языком правил, а именно в форме 

\begin{lstlisting}
        read books -> think
        think -> sleep
        sleep -> write books
        find $1 -> read $1
        book -> book 
\end{lstlisting}
Для такого набора правил взаимодействие с системой может проходить примерно так: пользователь после приглашения \hsinline=>= вводит запрос, жмет ENTER и программа выдает процесс переписывания прочитанного терма.
\begin{lstlisting}
        Processed 5 rules.
        > read books
        -> think -> sleep -> write books. 
        > find book
        -> read book -> read book -> read book -> ...
        > find books 
        -> read books -> think -> sleep. 
\end{lstlisting}


% As an extension you can implement the Knuth-Bendix completion algorithm. This extension is quite complicated and requires you to implement also unification and an algorithm that finds so-called critical pairs. Therefore this is merely for very interested students. 

\section{Мини-Prolog (Завадский)}

Нужно минималистично реализовать язык логического программирования Пролог, состоящий из парсера, унификации и алгоритма поиска. Здесь у нас сокращенный вариант Пролога -- без функциональных символов, поэтому унификация чрезвычайно простая.

Программа на Прологе представляется набором правил (clause).

\begin{lstlisting}
        mortal(X) :- human(X), lives(X). 
\end{lstlisting}

Вот пример нерекурсивного (\hsinline=mortal= не встречается справа) правила. Читается как "X смертен, если X -- человек и X жив", т.e. \hsinline=:-= -- это импликация справа налево, а запятая -- это конъюнкция (логическое "И"). Правило заканчивается точкой. 

Во входной программе также может иметься набор фактов (правил без импликации):

\begin{lstlisting}
        human(teacher).
        lives(teacher).
        likes(bob,alice).
\end{lstlisting}

После того, как прочитан набор правил и фактов, человек может начать общаться с Пролог-системой. Получив приглашение \hsinline=?-= человек вводит запрос, а программа печатает ответы: "да", "нет", "ответов не найдено" или "ответ такой-то. Искать дальше?"

\begin{lstlisting}
        ?- human(machine).
        no
        ?- human(teacher).
        yes
        ?- likes(mary,john).
        no
        ?- likes(bob,alice).
        yes
\end{lstlisting}

Правила могут быть рекурсивными и содержать переменные. Задачей является реализовать интерпретатор Prolog на Haskell. 

\section{Язык While (Келим)}

Реализовать парсер, интерпретатор и годные тесты языка While, в котором присутствуют

\begin{itemize}
 \item Числа, арифметика, переменные и присваивание.
 \item Конструкции ``запросить и пользователя число'' и ``распечатать число''.
 \item (Оценка 4) Конструкции IfThenElse и цикл с предусловием While
 \item (Оценка 5) Конструкции break и continue.
 \item Разумеется, нужно поддержать композиции конструкций (if внтури while, который внутри If, который внутри while, и т.д.)
 \item Язык лямбд не нужно добавлять, хотя если вы будете дописывать разобранный в течение семестра интерпретатор, то их будет проще не выкидывать.
\end{itemize}

Хотя в языке нет функций, он достаточно богат, чтобы быть полным по Тьюрингу. А значит можно начать с простых программ (посчитать модуль числа, swap, факториал, Фибоначчи), а потом дополнить интересными программами.

Я нарочито не даю конкретный синтаксис, который надо распарсить. Если вам нравится синтаксис Pascal -- берите его, если Си -- то Си, и т.д.

\section{SQLite на Haskell (Королихин)}

Необходимо реализовать минисистему баз данных. Программа должна уметь дампить информацию в файл, восстанавливать из файла и выполнять (парсер + интерпретатор) запросы к базе данных. Для ввода-вывода данных парсер и принтер писать не нужно, можно обойтись более прямолинейным стандартным способом (тот, кто копался в стандартных классах типов -- меня поймет). Парсер нужен только для языка запросов SQL. Список запросов возьмем сокращенно-стандартный. Конкретный синтаксис посмотрите в документации к какому-нибудь варианту SQL, здесь я напишу только несколько примеров.

\begin{itemize}
 \item Создание таблиц. Из типов давайте оставим только Int и String (который в базах данных обычно называется VarChar)
\begin{lstlisting}[language=sql]
CREATE TABLE table1 ( String FirstName
                    , String LastName
                    , Int Id
                    , Int Age)
\end{lstlisting}
\item  Добавление данных в таблицу. Если кто-то добавляет Int туда, где ожидался тип String -- выругиваться
\begin{lstlisting}[language=sql]
INSERT INTO table1 VALUES ('vasya','pupkin',1,2), 
                          ('ivan', 'ivanov',2,2)
\end{lstlisting}
\item Выбор данных из таблицы с выдачей табличного результата
\begin{lstlisting}[language=sql]
SELECT * FROM  table1
\end{lstlisting} 
или 
\begin{lstlisting}[language=sql]
SELECT (FirstName,LastName) FROM table1 WHERE Age>18
\end{lstlisting}
 
\item Удаление данных из таблицы
\begin{lstlisting}[language=sql]
REMOVE FROM table1 WHERE Age>18
\end{lstlisting}
\item Join (он же inner join) таблиц, который формально является декартовом перемножением всех строчек в таблицах с последующей фильтрацией
\begin{lstlisting}[language=sql]
SELECT (a, tableX.id, tableY.id) FROM tableX 
   JOIN tableY 
   ON table1.id = table2.somekey
\end{lstlisting}
или даже вложенные join'ы
\begin{lstlisting}[language=sql]
SELECT * FROM A
  JOIN (B JOIN C ON B.fkC = C.pk) 
  ON A.optionalfkB = B.pk
\end{lstlisting}
\end{itemize}

Для оценки 4 сделайте пункты выше. 

Для оценки 5 нужно 
\begin{itemize}
 \item Оптимизатор запросов: вложенные join'ы должен вычисляться не в стиле generate\&filter, а как-нибдуь более оптимально.
 \item Поддержите в языке и интепретаторе кроме обычных join'ов другие: LEFT, OUTER, CROSS. Они работают чуть-чуть по-другому.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Символьное интегрирование (Кутленков)}
Научитесь брать аналитически интегралы вида $\int{\frac{P(x)}{Q(x)}dx} $, где $P$ и $Q$ -- многочлены, степень $Q \leq 2$. Чтобы это сделать, надо уметь  
\begin{itemize}
 \item Решать квадратные уравнения.
 \item Разбивать большую дробь на маленькие, решая по дороге систему линейных уравнений.
 \item Может быть делить многочлены с остатком
 \item Интегрировать простые дроби табличными интегралами
\end{itemize}

Напишите также 
% парсер входного языка (синтаксис возьмите из вольфрама, теха или какой-то другой который найдете) и 
тесты для интегратора.

Я нарочито не добавляю сюда требование про парсера, чтобы не раздувать задачу на двоих.

\section{Мини-язык про трансформеры монад (Орачев + Мясников)}

Эта задача без парсеров.

Сделайте AST для мини-языка и "интерпретатор" для него. Тип термов мини-языка должен называться \hsinline=M m r=, где  
\begin{itemize}
 \item \hsinline=M= -- это название вышележащей монады; 
 \item по типу вложенной монады \hsinline=m=  язык будет полиморфен;
 \item \hsinline=r= -- типовый параметр вложенной монады. В некотором смысле, что что мы описываем должно быть изоморфно \hsinline{M (m r)}.
\end{itemize}
 

\begin{hslisting}
class Transformer t where
  promote :: (Monad m) => m a -> t m a  
  observe :: (Monad m) => t m a -> m a 
\end{hslisting}
Функция создания терма мини-языка из вложенной монады будет называться \hsinline=promote=, а вызов интерпретатора и возвращение ответа будет называться \hsinline=observe=.

Для этой задачи будем считать, что вышележащей монадой является монада, которая позволяет сэмулировать вброс исключения, где исключение всегда типа \hsinline=String=.

Что надо сделать (выполнять желательно в указанном порядке):

\begin{enumerate}
 \item Опишите тип для мини-языка как алгебраический тип. Очевидно, там должны присутствовать конструкторы-аналоги для \hsinline=return=, \hsinline!>>=! и для "вброса исключения". Плюс, конструкции специфичные для вышележащей монады (она нам известна). (Подсказка, вроде как должно быть 5 конструкторов). Никаких лямбд, арифметики и парсеров добавлять не нужно. Сделайте также \hsinline=instance Show=.
 \item Напишите интерпретатор миниязыка (полиморфный по внутренней монаде) и какие-нибудь входные программы для него. 
 \item Покажите, что то, что получилось -- это монада (реализуйте три функции: \hsinline=return=, \hsinline!>>=! и \hsinline=fail=). Естественным подходом будет использование композиции уже написанного интерпретатора и/или конструкторов, например \hsinline!return = Return!
 \item Проверьте, что законы монад выполняются.
 \item Какие дополнительные, специфичные для вышележащей монады, законы разумно ввести? 
 \item (Для оценки 4) В получившемся языке получилось некоторое количество конструкторов. Возможно некоторые конструкторы стоят всегда рядом? (или можно применить законы и сделать так, чтобы они стояли всегда рядом) Сократите количество конструкторов с пяти до четырёх, перепишите интерпретатор.
%  \item Какова ассимптотическая сложность интепретации в зависимости от длины терма мини-языка?
%  
 \item (Для оценки 5) Попробуйте каким-нибудь образом переписать интерпретатор так, чтобы можно было избавиться от необходимости введения конструкторов для описания структуры мини-языка (что по сути означает отсутствие необходимости задавать тип для мини-языка), а ограничиться только функциями и композицией функций. (Если вы переписали интерпретатор так, что справа от символа равенства не встречаются конструкторы -- вы на пути к успеху).
 
\end{enumerate}

\section{$\qquad$}




\section{Предок delimited continuations -- callCC (Осипова)}

Такая же задача как следующая, только надо реализовать обыкновенные (undelimited) continuations в лямбда исчислении, они же callCC (call-with-current-continuation). Конструкция Shift называется callCC, конструкции reset -- нет, захват continuation'a происходит до самого конца.

Короче, я обещал задачу про delimCC ещё в начале семестра. Скорее всего вы её сделали. Выкинуть одну конструкцию, чутка исправить интепретатор и сделать новые тесты большого труда составить не должно.

\section{Про Delimited Continuations (Погребной)}

Это прошлогодняя задача, которую я обещал повторить и в этом году.

Реализовать парсер и интерпретатор бестипового лямбда-исчисления с поддержкой арифметики, списков и delimited continuations. Соответственно, во входном языке должны быть следующие конструкции: три для лямбда-исчисления, числовые константы и арифметические операции, IfThenElse, cons и nil для списков, операции isNil, операции head \& tail. Рекурсии нет.

Если что-то вычисляется не от того, что задумано (складываются лямбды, вызывается isHead от чисел, а не от списков), то интерпретатор должен упасть с объяснением почему. Условие в конструкции If вычисляется и проверяется на адекватность: числа $\geq 1$ -- истина, $0$ -- ложь, остальное -- ошибка интерпретации.

Так как это прошлогоднее задание,  приделайте к  тому, что получилось дома годные тесты. 

Полезную информацию стоит искать неподалёку \href{http://okmij.org/ftp/continuations/index.html#tutorial}{отсюда} и где-то \href{http://pllab.is.ocha.ac.jp/~asai/cw2011tutorial/slides.pdf}{здесь}.

\section{Про трансляцию pattern matching в кучу If'ов (Решетников)}

В этой задаче нужно написать интерпретатор мини-языка, трансляцию мини-языка в мини-язык и тесты. Парсера писать не нужно.

У нас есть язык бестипового лямбда-исчисления без рекурсии.  Язык расширяем:
\begin{itemize}
 \item Числами, арифметикой.
 \item IfThenElse. Если в условии If число 0 -- это ложь; 1 -- истина; иное считается ошибкой интерпретации.
 \item Бинарная операция равенства двух чисел. Если числа равны, то 1; не равны -- 0. Если сравниваются не числа, то это ошибка интерпретации. В принципе, если будет удобнее, то можно также добавить сравнение строк на равенство (смотрите ниже про конструкцию \hsinline=tag=).
\end{itemize}
Тип для термов языка должен получиться похожим на этот. Разумеется, можно облегчить себе жизнь с помощью индексов де Брауна, но не обязательно.
\begin{hslisting}
data Op = Add | Mil | Div | Sub | Eq
data Term = App Term   Term
          | Abs String Term
          | Var String
          | IntConst Int 
          | BinOp Op Term Term      
          | ...
\end{hslisting}

Далее расширяем язык ``алгебраическими'' выражениями.
\begin{itemize}
 \item Выражения ``алгебраического'' вида: конструктор с именем (строка с заглавной буквы), а за ним $n\geq0$ выражений.
 \item Функция для работы с ``алгебраическими'' данными \hsinline=tag= -- взятия тега (имени). Операцию \hsinline=tag= можно сделать по-разному: возвращать строку и сравнивать строки, возвращать хэш строки и сравнивать числа, или выберите что-нибудь другое...
 \item Функция для работы с ``алгебраическими'' данными \hsinline=field= -- она ещё часто называется проекцией. Возвращает n-й аргумент конструктора (нумерация с нуля). Определена только для алгебраических значений, падает если значение не состоит из конструктора или если у конструктора нет аргумента с таким номером.
 
 Пример/ \hsinline=Just 5= во входном языке после парсинга превращается в  \hsinline=Constructor "Just" [IntConst 5]= (обозначим это за \hsinline=t=), т.е. конструктор с именем ``Just'' и одним аргументом \hsinline=IntConst 5=. Для него \hsinline=Tag t= должен вычисляться в строку ``Just'' (или хэш от ней). \hsinline=Field 0 t= -- вычисляется в \hsinline=IntConst 5=, проекции с другими номерами ведут к ошибке.
 
 \item Конструкцией паттерн-матчинга как в Haskell, но без pattern guards, patterns synonyms, т.е. минимально простой вариант.
 \item Из паттернов разрешены: wildcard, переменная, числовые константы, имя конструктора а за ним $n\geq0$ паттернов (вложенные паттерны было бы неплохо поддержать), паттерны для списков не поддерживаем.
 \item Выводом типов не занимаемся, если что-то вызвалось не от того, что нужно, то интерпретатор должен закончиться с аварийно, сообщая что именно пошло не так.
\end{itemize}

\begin{hslisting}
data Term = ...
          | Constructor { tname :: String
                        , targs :: [Term] }
          | Tag Term
          | Field Int Term
          | Case { what  :: Term
                 , patts :: [(Pattern, Term)] }
          
data Pattern = PVar String
             | PWildcard
             | PConst Int
             | PConstructor { pname :: String
                            , pargs :: [Pattern] }
\end{hslisting}

Пример. После синтаксического анализа входная строка
\begin{hslisting}
\ x -> case x of 
         Nothing -> 18 
         Just _  -> x
\end{hslisting}
должна превратится в терм
\begin{lstlisting}[mathescape=false]
Abs "x" $ 
  Case (Var "x") 
       [ (PConstructor "Nothing"       [], IntConst 18)
       , (PConstructor "Just" [PWildcard], Var "x")
       ]
\end{lstlisting}

Что надо сделать:
\begin{enumerate}
 \item Интерпретатор языка (который описан выше) с поддержкой ошибок и подсчетом количества вычисленных конструкций IfThenElse. Стратегию вычислений (call-by-value, call-by-name, call-by-need или другое) выберите сами.
 \item Реализуйте преобразование из языка выше в язык, где конструкции pattern matching заменены на IfThenElse и те две дополнительные функции \hsinline=field= и \hsinline=tag=.
 
 \item Преобразование выше можно делать ``в лоб'' -- тогда породится большое количество If'ов, или по-умному. Например, на каждом шаге смотреть на 1й столбец матрицы паттернов, группировать одинаковые и запускать генерацию кода рекурсивно на получившихся подматрицах. Страшная \href{https://dl.acm.org/citation.cfm?id=507641}{ссылка} с описанием подробностей (скачайте её будучи на матмехе, она может оказаться недоступной с айпишников необразовательных подсетей). 
  
  (Оценка 5) Сделайте также оптимизированное преобразование и проверьте, что количество вычисленных If'ов сокращается.
\end{enumerate}


\section{Про трансляцию pattern matching в кучу If'ов (Рыбина)}

Это кусок предыдущий задачи в том смысле, что я одну большую распилил на две.

Здесь нужно написать парсер и интерпретатор для языка из предыдущей задачи. Часть про интерпретатор общая для обеих задач.

Синтаксис входного языка выберите сами: как в Haskell, F\#, OCaml, Scala, двумерный/недвумерный, ... Мне всёравно что вы выберите, выбирайте то, для чего сможете написать парсер. Сложность скорее всего будет заключаться в выборе синтаксиса и парсинга паттернов. С алгебраическими опреациями \hsinline=field= и \hsinline=tag= особых проблем быть не должно -- они сами распарсятся в применения соостветсвующих функций (это будет почти то, что нужно).
 
\section{Корутины (Сергеев)}

Эта и следующая (Scott Encoding) задача с сайта Codewars. Вроде как, если у пользователя есть большой рейтинг, то ему могут показать решение, но я думаю, что вы не поднимете его до нужного уровня за выходные.

\href{https://www.codewars.com/kata/coroutines}{Задача} c Codewars

У меня есть смутное подозрение, что что-то подобное я рассказывал.

\section{Шестиугольный тетрис (Богданов Евгений + Фунт)}

Поле размера m на n (числа должны настраиваться) состоит из сотов, которые выглядят примерно как на рисунке. Три сота сочленяются в одной точке, в этом месте соты можно вращать (всего три степени свободы). Если в какой-то момент в трех соседних сотах находятся одинаковые цифры (от нуля до девяти), то количество очков увеличивается (формулу придумайте сами), соты уничтожаются, соты сверху осыпаются вниз, сверху генерируются новые.

\begin{verbatim}
    _   _   _
   / \ / \ / \
  | 2 | 3 | 3 |
   \_/ \_/ \_/ \
    | 5 | 3 |   .
   / \_/ \_/     .
  | ? | ? |       
   \_/ \_/ \_ ..
\end{verbatim}

Нужно написать симуляцию мира, где на каждом шаге происходит распечатка поля в ASCII графике и вращение с целью максимизировать очки. Когда нельзя увеличить количество очков, то симуляция заканчивается.

Разумеется, никаких парсеров в этой задаче писать не обязательно.

\href{https://www.redblobgames.com/grids/hexagons/}{Умная ссылка} отчасти по теме

\section{$ $}

Уважаемый человек сказал, что задачу про тетрис надо давать на двоих. Я поверил на слово.
 
\section{Рисование резисторов в ASCII графике (Цырендашиев)}

Дана электрическая схема состоящая из резисторов последовательно или параллельно соединенных. Надо научиться считать общее сопротивление схемы (это просто) и красиво рисовать схему в ASCII графике (с этим будут проблемы).

\section{Задача про Cypher (Чернявский)}

Есть такая графовая база данных Neo4j и к ней язык запросов к графам под названием Cypher. Грубо говоря, в вершинах и на ребрах написаны некоторые метки, запрос делается к графу и возвращается подграф подходящих вершин, соединенных подходящими рёбрами. Нужно реализовать парсер подмножества Cypher, интерпретатор и тесты для него.

Довольно много мелких примеров для тестов есть на официальном \href{https://neo4j.com/graphgists}{сайте}. Меня в первую очередь интересуют в языке поиск подграфа с учетом меток на вершинах и ребрах, прочие фичи можете отложить на потом (т.е. навсегда).

То, что выше -- для оценки 4. 

Для оценки 5 я хочу, чтобы граф-ответ выглядел красиво. Можете, например, распечатывать его в формат dot с помощью хаскеллевой \href{http://hackage.haskell.org/package/graphviz-2999.20.0.3/docs/Data-GraphViz-Types.html}{библиотеки}, а потом стандартной утилитой перегонять в картинку PNG.

\section{Lisp (Ярош)}

Нужно написать парсер, интерпретатор и тесты для входного языка \`a la Lisp. Там довольно прямолинейный синтаксис из s-выражений: всё состоит из вложенных списков, вызов функции записывается в префиксной форме, код = данные и т.д.

Напишите парсер входного языка в стиле Lisp (это проще, чем вы думаете), интерпретатор и тесты. В языке должны быть: списки и операции над ними (иначе это не Lisp), арифметика и конструкции лямбда-исчисления.

Также нужно реализовать Lisp-специфичные конструкции Quote и Unquote, которые преобразуют запускаемый код в данные и наоборот. С помощью такой штуки можно запускать квайны (quines): программы, которые возвращают свой код, т.е. вычисляются сами в себя. А потом twine'ы: пары программ, которые вычисляются друг в друга. И даже thrine'ы: тройки программ, где натравливание одной на другую возвращает третью (и так ещё двумя способаим сочетания программ). Если что-то из Nайнов заработает -- можете претендовать на оценку 5.


\section{Задача про симуляцию мира 2D}

Описание нарочито неформальное, чтобы фанатам был доступен простор для фантазии

Нужно реализовать симуляцию мира, населенного NPC. Каждый шаг симуляции сопровождается распечаткой состояния мира на консоль. Симуляция идет потенциально бесконечно.

В идеале должна быть процедурная генерация всего и вся. 

В звёздной системе вращаются планеты, которые потребляют или генерируют товары. Между ними летают корабли, которые будут покупать/перевозить/продавать товары между планетами, чтобы срубить по больше ``денег''. Сделайте симуляцию процедурно-генерируемого мира (оценка 4)

На оценку 5 надо добавить какие-нибудь свои фичи: раздачу квестов на отвезти что-либо куда-либо, квесты для охотников за головами, или ещё что-нибудь.

Не больше одного человека.


\end{document}

