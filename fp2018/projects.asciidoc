:source-highlighter: pygments
:pygments-style: monokai
:local-css-style: pastie

Список курсовых/миникурсовых
============================
:Author: Dmitrii Kosarev a.k.a. Kakadu
:email:  Dmitrii.Kosarev@protonmail.ch

[[reasonml]]
Парсер для ReasonML/OCaml с восстановлением от ошибок
-----------------------------------------------------

Так как быдлопрограммисты на быдлоJava не могут никак осилить синтакси нормальных функциональных языков программирования,
в Bloomberg (а потом и Facebook)
было предложено совершить ход конём и немного [.line-through]#исправить# испортить синтаксис уже умеющегося языка, что он был более 
похож на привычный синтаксис с фигурными скобками и точками с запятой. Хомячкам, получившийся в результате ReasonML, вроде
понравился.

С таким подходом вроде бы всё хорошо, но есть проблема для чистокровных OCaml программистов: язык действительно сильно похож, но
непохожести очень сильно бесят, никак не получается выкинуть из головы выученный синтаксис и пользоваться новым, потому что то, что
видно на экране очень сильно напоминает "старый" синтаксис OCaml. В итоге получаются ошибки, которые очень глупые, но компилятор
ReasonML всёравно не доволен. Например:

Вот пример кода на OCaml:
[source,ocaml]
----
type 'a expr = Const : int     -> 'a expr
             | App   : 'a * 'a -> 'a expr
             | Lam   : string * 'a -> 'a expr
             
let foo e = match e with 
  | Const n -> n
  | App (l,r) -> 
      let () = print_endline "blabla" in
      r
  | Lam (s, b) -> b
----

А вот, что получается при https://reasonml.github.io/en/try[трансляции] в ReasonML.
[source,ocaml]
----
type expr('a) =
  | Const(int): expr('a)
  | App('a, 'a): expr('a)
  | Lam(string, 'a): expr('a);

let foo = e =>
  switch (e) {
  | Const(n) => n
  | App(l, r) =>
    let () = print_endline("blabla");
    r;
  | Lam(s, b) => b
  };

----

https://github.com/facebook/reason/blob/master/src/reason-parser/reason_parser.mly[Парсер] ReasonML на основе Menhir(?).

Хочется в некоторых местах расширить парсер ReasonML, чтобы он мог разбирать также в том случае, если
куски кода были написаны на OCaml (должно случаться, когда программист не успел ещё перестроиться на новй синтаксис).
Таким образом парсер будет в некотором смысле восстанавливаться от некоторых ошибок, и в перспективе сообщать
программисту "нажмите Alt+Enter+Enter, чтобы исправить Ваш OCaml на соответствующий ReasonML".

Предлагается расширить парсер(грамматику) ReasonML дуальными правилами для OCaml конструкций и генерировать 
синтаксическое дерево, где куски AST будут отмечены либо как ReasonML, либо как OCaml. Аналогично, можно
расширять парсер OCaml синтаксом Reason.

Главные грабли, связанные с тем, что объединение однозначных языков может быть неоднозначным языком, случиться не должны.

